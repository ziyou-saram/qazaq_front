{"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/next-async-request-api.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nvar __importDefault = void 0 && (void 0).__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar index_1 = require(\"./lib/async-request-api/index\");\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return __importDefault(index_1).default;\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiaW5kZXhfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL0BuZXh0L2NvZGVtb2QvdHJhbnNmb3Jtcy8iLCJzb3VyY2VzIjpbIm5leHQtYXN5bmMtcmVxdWVzdC1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2xpYi9hc3luYy1yZXF1ZXN0LWFwaS9pbmRleFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChpbmRleF8xKS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1hc3luYy1yZXF1ZXN0LWFwaS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBQ1osSUFBSUEsZUFBZSxHQUFJLFVBQVEsU0FBS0EsZUFBZSxJQUFLLFVBQVVDLEdBQUcsRUFBRTtFQUNuRSxPQUFRQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFJRCxHQUFHLEdBQUc7SUFBRSxTQUFTLEVBQUVBO0VBQUksQ0FBQztBQUM3RCxDQUFDO0FBQ0RFLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0VBQUVDLEtBQUssRUFBRTtBQUFLLENBQUMsQ0FBQztBQUM3REQsT0FBTyxDQUFDRSxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3hCLElBQUlDLE9BQU8sR0FBR0MsT0FBTyxDQUFDLCtCQUErQixDQUFDO0FBQ3RETixNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFNBQVMsRUFBRTtFQUFFSyxVQUFVLEVBQUUsSUFBSTtFQUFFQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFZO0lBQUUsT0FBT1gsZUFBZSxDQUFDUSxPQUFPLENBQUMsQ0FBQ0QsT0FBTztFQUFFO0FBQUUsQ0FBQyxDQUFDIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","default","index_1","require","enumerable","get"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/","sources":["next-async-request-api.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = void 0;\nvar index_1 = require(\"./lib/async-request-api/index\");\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return __importDefault(index_1).default; } });\n//# sourceMappingURL=next-async-request-api.js.map"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,UAAQ,SAAKA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,IAAIC,OAAO,GAAGC,OAAO,CAAC,+BAA+B,CAAC;AACtDN,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,SAAS,EAAE;EAAEK,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOX,eAAe,CAACQ,OAAO,CAAC,CAACD,OAAO;EAAE;AAAE,CAAC,CAAC","ignoreList":[]}},"mtime":1769077344094},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/index.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transform;\nconst next_async_dynamic_prop_1 = require(\"./next-async-dynamic-prop\");\nconst next_async_dynamic_api_1 = require(\"./next-async-dynamic-api\");\nfunction transform(file, api) {\n  const transforms = [next_async_dynamic_prop_1.transformDynamicProps, next_async_dynamic_api_1.transformDynamicAPI];\n  return transforms.reduce((source, transformFn) => {\n    const result = transformFn(source, api, file.path);\n    if (!result) {\n      return source;\n    }\n    return result;\n  }, file.source);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJ0cmFuc2Zvcm0iLCJuZXh0X2FzeW5jX2R5bmFtaWNfcHJvcF8xIiwicmVxdWlyZSIsIm5leHRfYXN5bmNfZHluYW1pY19hcGlfMSIsImZpbGUiLCJhcGkiLCJ0cmFuc2Zvcm1zIiwidHJhbnNmb3JtRHluYW1pY1Byb3BzIiwidHJhbnNmb3JtRHluYW1pY0FQSSIsInJlZHVjZSIsInNvdXJjZSIsInRyYW5zZm9ybUZuIiwicmVzdWx0IiwicGF0aCJdLCJzb3VyY2VSb290IjoiL1VzZXJzL2FsaWtoYW56aHVtYWJheWV2Ly5ucG0vX25weC82YTA5MDY2OWUyMWI0MzAzL25vZGVfbW9kdWxlcy9AbmV4dC9jb2RlbW9kL3RyYW5zZm9ybXMvbGliL2FzeW5jLXJlcXVlc3QtYXBpLyIsInNvdXJjZXMiOlsiaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmFuc2Zvcm07XG5jb25zdCBuZXh0X2FzeW5jX2R5bmFtaWNfcHJvcF8xID0gcmVxdWlyZShcIi4vbmV4dC1hc3luYy1keW5hbWljLXByb3BcIik7XG5jb25zdCBuZXh0X2FzeW5jX2R5bmFtaWNfYXBpXzEgPSByZXF1aXJlKFwiLi9uZXh0LWFzeW5jLWR5bmFtaWMtYXBpXCIpO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGZpbGUsIGFwaSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBbbmV4dF9hc3luY19keW5hbWljX3Byb3BfMS50cmFuc2Zvcm1EeW5hbWljUHJvcHMsIG5leHRfYXN5bmNfZHluYW1pY19hcGlfMS50cmFuc2Zvcm1EeW5hbWljQVBJXTtcbiAgICByZXR1cm4gdHJhbnNmb3Jtcy5yZWR1Y2UoKHNvdXJjZSwgdHJhbnNmb3JtRm4pID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtRm4oc291cmNlLCBhcGksIGZpbGUucGF0aCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmlsZS5zb3VyY2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUNaQSxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUFFQyxLQUFLLEVBQUU7QUFBSyxDQUFDLENBQUM7QUFDN0RELE9BQU8sQ0FBQ0UsT0FBTyxHQUFHQyxTQUFTO0FBQzNCLE1BQU1DLHlCQUF5QixHQUFHQyxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDdEUsTUFBTUMsd0JBQXdCLEdBQUdELE9BQU8sQ0FBQywwQkFBMEIsQ0FBQztBQUNwRSxTQUFTRixTQUFTQSxDQUFDSSxJQUFJLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixNQUFNQyxVQUFVLEdBQUcsQ0FBQ0wseUJBQXlCLENBQUNNLHFCQUFxQixFQUFFSix3QkFBd0IsQ0FBQ0ssbUJBQW1CLENBQUM7RUFDbEgsT0FBT0YsVUFBVSxDQUFDRyxNQUFNLENBQUMsQ0FBQ0MsTUFBTSxFQUFFQyxXQUFXLEtBQUs7SUFDOUMsTUFBTUMsTUFBTSxHQUFHRCxXQUFXLENBQUNELE1BQU0sRUFBRUwsR0FBRyxFQUFFRCxJQUFJLENBQUNTLElBQUksQ0FBQztJQUNsRCxJQUFJLENBQUNELE1BQU0sRUFBRTtNQUNULE9BQU9GLE1BQU07SUFDakI7SUFDQSxPQUFPRSxNQUFNO0VBQ2pCLENBQUMsRUFBRVIsSUFBSSxDQUFDTSxNQUFNLENBQUM7QUFDbkIiLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["Object","defineProperty","exports","value","default","transform","next_async_dynamic_prop_1","require","next_async_dynamic_api_1","file","api","transforms","transformDynamicProps","transformDynamicAPI","reduce","source","transformFn","result","path"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/","sources":["index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = transform;\nconst next_async_dynamic_prop_1 = require(\"./next-async-dynamic-prop\");\nconst next_async_dynamic_api_1 = require(\"./next-async-dynamic-api\");\nfunction transform(file, api) {\n    const transforms = [next_async_dynamic_prop_1.transformDynamicProps, next_async_dynamic_api_1.transformDynamicAPI];\n    return transforms.reduce((source, transformFn) => {\n        const result = transformFn(source, api, file.path);\n        if (!result) {\n            return source;\n        }\n        return result;\n    }, file.source);\n}\n//# sourceMappingURL=index.js.map"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAGC,SAAS;AAC3B,MAAMC,yBAAyB,GAAGC,OAAO,CAAC,2BAA2B,CAAC;AACtE,MAAMC,wBAAwB,GAAGD,OAAO,CAAC,0BAA0B,CAAC;AACpE,SAASF,SAASA,CAACI,IAAI,EAAEC,GAAG,EAAE;EAC1B,MAAMC,UAAU,GAAG,CAACL,yBAAyB,CAACM,qBAAqB,EAAEJ,wBAAwB,CAACK,mBAAmB,CAAC;EAClH,OAAOF,UAAU,CAACG,MAAM,CAAC,CAACC,MAAM,EAAEC,WAAW,KAAK;IAC9C,MAAMC,MAAM,GAAGD,WAAW,CAACD,MAAM,EAAEL,GAAG,EAAED,IAAI,CAACS,IAAI,CAAC;IAClD,IAAI,CAACD,MAAM,EAAE;MACT,OAAOF,MAAM;IACjB;IACA,OAAOE,MAAM;EACjB,CAAC,EAAER,IAAI,CAACM,MAAM,CAAC;AACnB","ignoreList":[]}},"mtime":1769077344092},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/next-async-dynamic-prop.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformDynamicProps = transformDynamicProps;\nconst utils_1 = require(\"./utils\");\nconst parser_1 = require(\"../../../lib/parser\");\nconst PAGE_PROPS = 'props';\n// Find all the member access of the prop, and await them\n// e.g. If there's argument `props`, find all the member access of props.<name>.\n// If the member access can be awaited, await them.\nfunction awaitMemberAccessOfProp(propIdName, path, j) {\n  // search the member access of the prop\n  const functionBody = (0, utils_1.findFunctionBody)(path);\n  const memberAccess = j(functionBody).find(j.MemberExpression, {\n    object: {\n      type: 'Identifier',\n      name: propIdName\n    }\n  });\n  let hasAwaited = false;\n  // await each member access\n  memberAccess.forEach(memberAccessPath => {\n    var _memberAccessPath$par, _parentScopeOfMemberA;\n    const member = memberAccessPath.value;\n    const memberProperty = member.property;\n    const isAccessingMatchedProperty = j.Identifier.check(memberProperty) && utils_1.TARGET_PROP_NAMES.has(memberProperty.name);\n    if (!isAccessingMatchedProperty) {\n      return;\n    }\n    if ((0, utils_1.isParentPromiseAllCallExpression)(memberAccessPath, j)) {\n      return;\n    }\n    // check if it's already awaited\n    if (((_memberAccessPath$par = memberAccessPath.parentPath) === null || _memberAccessPath$par === void 0 ? void 0 : _memberAccessPath$par.value.type) === 'AwaitExpression') {\n      return;\n    }\n    const parentScopeOfMemberAccess = (0, utils_1.findClosetParentFunctionScope)(memberAccessPath, j);\n    // When the parent scope is sync, and it's also not the function itself, which means it's not able to convert to async.\n    if (parentScopeOfMemberAccess && !((_parentScopeOfMemberA = parentScopeOfMemberAccess.value) !== null && _parentScopeOfMemberA !== void 0 && _parentScopeOfMemberA.async) && parentScopeOfMemberAccess.node !== path.node) {\n      // If it's not able to convert, add a comment to the prop access to warn the user\n      // e.g. the parent scope is sync, await keyword can't be applied\n      const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${propIdName}.${memberProperty.name}' is accessed without awaiting.`;\n      (0, utils_1.insertCommentOnce)(member, j, comment);\n      return;\n    }\n    const awaitedExpr = j.awaitExpression(member);\n    const awaitMemberAccess = (0, utils_1.wrapParentheseIfNeeded)(true, j, awaitedExpr);\n    memberAccessPath.replace(awaitMemberAccess);\n    hasAwaited = true;\n  });\n  const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(path.get('body'), j);\n  // If there's any awaited member access, we need to make the function async\n  if (hasAwaited) {\n    if (path.value.async === false && !hasReactHooksUsage) {\n      path.value.async = true;\n      (0, utils_1.turnFunctionReturnTypeToAsync)(path.value, j);\n    }\n  }\n  return hasAwaited;\n}\nfunction applyUseAndRenameAccessedProp(propIdName, path, j) {\n  // search the member access of the prop, and rename the member access to the member value\n  // e.g.\n  // props.params => params\n  // props.params.foo => params.foo\n  // props.searchParams.search => searchParams.search\n  let modified = false;\n  const functionBody = (0, utils_1.findFunctionBody)(path);\n  const memberAccess = j(functionBody).find(j.MemberExpression, {\n    object: {\n      type: 'Identifier',\n      name: propIdName\n    }\n  });\n  const accessedNames = [];\n  // rename each member access\n  memberAccess.forEach(memberAccessPath => {\n    // If the member access expression is first argument of `use()`, we skip\n    if ((0, utils_1.isParentUseCallExpression)(memberAccessPath, j)) {\n      return;\n    }\n    const member = memberAccessPath.value;\n    const memberProperty = member.property;\n    if (j.Identifier.check(memberProperty)) {\n      accessedNames.push(memberProperty.name);\n    } else if (j.MemberExpression.check(memberProperty)) {\n      let currentMember = memberProperty;\n      if (j.Identifier.check(currentMember.object)) {\n        accessedNames.push(currentMember.object.name);\n      }\n    }\n    memberAccessPath.replace(memberProperty);\n  });\n  // If there's any renamed member access, need to call `use()` onto member access\n  // e.g. ['params'] => insert `const params = use(props.params)`\n  if (accessedNames.length > 0) {\n    const accessedPropId = j.identifier(propIdName);\n    const accessedProp = j.memberExpression(accessedPropId, j.identifier(accessedNames[0]));\n    const useCall = j.callExpression(j.identifier('use'), [accessedProp]);\n    const useDeclaration = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(accessedNames[0]), useCall)]);\n    if (functionBody) {\n      functionBody.unshift(useDeclaration);\n    }\n    modified = true;\n  }\n  return modified;\n}\nfunction commentOnMatchedReExports(root, j) {\n  let modified = false;\n  root.find(j.ExportNamedDeclaration).forEach(path => {\n    if (j.ExportSpecifier.check(path.value.specifiers[0])) {\n      const specifiers = path.value.specifiers;\n      for (const specifier of specifiers) {\n        if (j.ExportSpecifier.check(specifier) && (\n        // Find matched named exports and default export\n        utils_1.TARGET_NAMED_EXPORTS.has(specifier.exported.name) || specifier.exported.name === 'default')) {\n          if (j.Literal.check(path.value.source)) {\n            const localName = specifier.local.name;\n            const commentInserted = (0, utils_1.insertCommentOnce)(specifier, j, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} \\`${localName}\\` export is re-exported. Check if this component uses \\`params\\` or \\`searchParams\\``);\n            modified ||= commentInserted;\n          } else if (path.value.source === null) {\n            const localIdentifier = specifier.local;\n            const localName = localIdentifier.name;\n            // search if local identifier is from imports\n            const importDeclaration = root.find(j.ImportDeclaration).filter(importPath => {\n              return importPath.value.specifiers.some(importSpecifier => importSpecifier.local.name === localName);\n            });\n            if (importDeclaration.size() > 0) {\n              const commentInserted = (0, utils_1.insertCommentOnce)(specifier, j, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} \\`${localName}\\` export is re-exported. Check if this component uses \\`params\\` or \\`searchParams\\``);\n              modified ||= commentInserted;\n            }\n          }\n        }\n      }\n    }\n  });\n  return modified;\n}\nfunction modifyTypes(paramTypeAnnotation, propsIdentifier, root, j) {\n  let modified = false;\n  if (paramTypeAnnotation && paramTypeAnnotation.typeAnnotation) {\n    const typeAnnotation = paramTypeAnnotation.typeAnnotation;\n    if (typeAnnotation.type === 'TSTypeLiteral') {\n      const typeLiteral = typeAnnotation;\n      // Find the type property for `params`\n      typeLiteral.members.forEach(member => {\n        if (member.type === 'TSPropertySignature' && member.key.type === 'Identifier' && utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n          // if it's already a Promise, don't wrap it again, return\n          if (member.typeAnnotation && member.typeAnnotation.typeAnnotation && member.typeAnnotation.typeAnnotation.type === 'TSTypeReference' && member.typeAnnotation.typeAnnotation.typeName.type === 'Identifier' && member.typeAnnotation.typeAnnotation.typeName.name === 'Promise') {\n            return;\n          }\n          // Wrap the `params` type in Promise<>\n          if (member.typeAnnotation && member.typeAnnotation.typeAnnotation && j.TSType.check(member.typeAnnotation.typeAnnotation)) {\n            member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([member.typeAnnotation.typeAnnotation]));\n            modified = true;\n          }\n        }\n      });\n    } else if (typeAnnotation.type === 'TSTypeReference') {\n      // If typeAnnotation is a type or interface, change the properties to Promise<type of property>\n      // e.g. interface PageProps { params: { slug: string } } => interface PageProps { params: Promise<{ slug: string }> }\n      const typeReference = typeAnnotation;\n      if (typeReference.typeName.type === 'Identifier') {\n        // Find the actual type of the type reference\n        const foundTypes = findAllTypes(root, j, typeReference.typeName.name);\n        // Deal with interfaces\n        if (foundTypes.interfaces.length > 0) {\n          var _interfaceDeclaration;\n          const interfaceDeclaration = foundTypes.interfaces[0];\n          if (interfaceDeclaration.type === 'TSInterfaceDeclaration' && ((_interfaceDeclaration = interfaceDeclaration.body) === null || _interfaceDeclaration === void 0 ? void 0 : _interfaceDeclaration.type) === 'TSInterfaceBody') {\n            const typeBody = interfaceDeclaration.body.body;\n            // if it's already a Promise, don't wrap it again, return\n            // traverse the typeReference's properties, if any is in propNames, wrap it in Promise<> if needed\n            typeBody.forEach(member => {\n              if (member.type === 'TSPropertySignature' && member.key.type === 'Identifier' && utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                var _member$typeAnnotatio;\n                // if it's already a Promise, don't wrap it again, return\n                if (member.typeAnnotation && member.typeAnnotation.typeAnnotation && ((_member$typeAnnotatio = member.typeAnnotation) === null || _member$typeAnnotatio === void 0 || (_member$typeAnnotatio = _member$typeAnnotatio.typeAnnotation) === null || _member$typeAnnotatio === void 0 || (_member$typeAnnotatio = _member$typeAnnotatio.typeName) === null || _member$typeAnnotatio === void 0 ? void 0 : _member$typeAnnotatio.name) === 'Promise') {\n                  return;\n                }\n                // Wrap the prop type in Promise<>\n                if (member.typeAnnotation && member.typeAnnotation.typeAnnotation &&\n                // check if member name is in propNames\n                utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                  member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([member.typeAnnotation.typeAnnotation]));\n                  modified = true;\n                }\n              }\n            });\n          }\n        }\n        // Deal with type aliases\n        if (foundTypes.typeAliases.length > 0) {\n          const typeAliasDeclaration = foundTypes.typeAliases[0];\n          if (j.TSTypeAliasDeclaration.check(typeAliasDeclaration)) {\n            const typeAlias = typeAliasDeclaration.typeAnnotation;\n            if (j.TSTypeLiteral.check(typeAlias) && typeAlias.members.length > 0) {\n              const typeLiteral = typeAlias;\n              typeLiteral.members.forEach(member => {\n                if (j.TSPropertySignature.check(member) && j.Identifier.check(member.key) && utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                  // if it's already a Promise, don't wrap it again, return\n                  if (member.typeAnnotation && member.typeAnnotation.typeAnnotation && member.typeAnnotation.typeAnnotation.type === 'TSTypeReference' && member.typeAnnotation.typeAnnotation.typeName.type === 'Identifier' && member.typeAnnotation.typeAnnotation.typeName.name === 'Promise') {\n                    return;\n                  }\n                  // Wrap the prop type in Promise<>\n                  if (member.typeAnnotation && j.TSTypeLiteral.check(member.typeAnnotation.typeAnnotation)) {\n                    member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([member.typeAnnotation.typeAnnotation]));\n                    modified = true;\n                  }\n                }\n              });\n            }\n          }\n        }\n        if (foundTypes.imports.length > 0) {\n          // console.log('typeReference.typeName.name', typeReference.typeName.name, foundTypes)\n          // If it's React PropsWithChildren\n          if (typeReference.typeName.name === 'PropsWithChildren') {\n            var _typeReference$typePa;\n            const propType = (_typeReference$typePa = typeReference.typeParameters) === null || _typeReference$typePa === void 0 ? void 0 : _typeReference$typePa.params[0];\n            if (propType && j.TSTypeLiteral.check(propType) && propType.members.length > 0) {\n              const typeLiteral = propType;\n              typeLiteral.members.forEach(member => {\n                if (j.TSPropertySignature.check(member) && j.Identifier.check(member.key) && utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                  // if it's already a Promise, don't wrap it again, return\n                  if (member.typeAnnotation && member.typeAnnotation.typeAnnotation && member.typeAnnotation.typeAnnotation.type === 'TSTypeReference' && member.typeAnnotation.typeAnnotation.typeName.type === 'Identifier' && member.typeAnnotation.typeAnnotation.typeName.name === 'Promise') {\n                    return;\n                  }\n                  // Wrap the prop type in Promise<>\n                  if (member.typeAnnotation && j.TSTypeLiteral.check(member.typeAnnotation.typeAnnotation)) {\n                    member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([member.typeAnnotation.typeAnnotation]));\n                    modified = true;\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n    propsIdentifier.typeAnnotation = paramTypeAnnotation;\n    modified = true;\n  }\n  return modified;\n}\nfunction transformDynamicProps(source, _api, filePath) {\n  const isEntryFile = utils_1.NEXTJS_ENTRY_FILES.test(filePath);\n  if (!isEntryFile) {\n    return null;\n  }\n  let modified = false;\n  let modifiedPropArgument = false;\n  const j = (0, parser_1.createParserFromPath)(filePath);\n  const root = j(source);\n  // Check if 'use' from 'react' needs to be imported\n  let needsReactUseImport = false;\n  // Based on the prop names\n  // e.g. destruct `params` { slug } = params\n  // e.g. destruct `searchParams `{ search } = searchParams\n  let insertedDestructPropNames = new Set();\n  function processAsyncPropOfEntryFile(isClientComponent) {\n    // find `params` and `searchParams` in file, and transform the access to them\n    function renameAsyncPropIfExisted(path, isDefaultExport) {\n      var _decl$id;\n      const decl = path.value;\n      const params = decl.params;\n      let functionName = (_decl$id = decl.id) === null || _decl$id === void 0 ? void 0 : _decl$id.name;\n      // If it's const <id> = function () {}, locate the <id> to get function name\n      if (!decl.id) {\n        var _ref;\n        functionName = (_ref = (0, utils_1.getVariableDeclaratorId)(path, j)) === null || _ref === void 0 ? void 0 : _ref.name;\n      }\n      // target properties mapping, only contains `params` and `searchParams`\n      const propertiesMap = new Map();\n      let allProperties = [];\n      const isRoute = !isDefaultExport && utils_1.TARGET_ROUTE_EXPORTS.has(functionName);\n      // generateMetadata API has 2 params\n      if (functionName === 'generateMetadata') {\n        if (params.length > 2 || params.length === 0) return;\n      } else if (isRoute) {\n        if (params.length !== 2) return;\n      } else {\n        // Page/Layout default export have 1 param\n        if (params.length !== 1) return;\n      }\n      const propsIdentifier = (0, utils_1.generateUniqueIdentifier)(PAGE_PROPS, path, j);\n      const propsArgumentIndex = isRoute ? 1 : 0;\n      const currentParam = params[propsArgumentIndex];\n      if (!currentParam) return;\n      // Argument destructuring case\n      if (currentParam.type === 'ObjectPattern') {\n        // Validate if the properties are not `params` and `searchParams`,\n        // if they are, quit the transformation\n        let foundTargetProp = false;\n        for (const prop of currentParam.properties) {\n          if ('key' in prop && prop.key.type === 'Identifier') {\n            const propName = prop.key.name;\n            if (utils_1.TARGET_PROP_NAMES.has(propName)) {\n              foundTargetProp = true;\n            }\n          }\n        }\n        // If there's no `params` or `searchParams` matched, return\n        if (!foundTargetProp) return;\n        allProperties = currentParam.properties;\n        currentParam.properties.forEach(prop => {\n          if (\n          // Could be `Property` or `ObjectProperty`\n          (j.Property.check(prop) || j.ObjectProperty.check(prop)) && j.Identifier.check(prop.key) && utils_1.TARGET_PROP_NAMES.has(prop.key.name)) {\n            const value = 'value' in prop ? prop.value : null;\n            propertiesMap.set(prop.key.name, value);\n          }\n        });\n        modifiedPropArgument = true;\n      } else if (currentParam.type === 'Identifier') {\n        // case of accessing the props.params.<name>:\n        // Page(props) {}\n        // generateMetadata(props, parent?) {}\n        const argName = currentParam.name;\n        if (isClientComponent) {\n          const modifiedProp = applyUseAndRenameAccessedProp(argName, path, j);\n          if (modifiedProp) {\n            needsReactUseImport = true;\n            modified = true;\n          }\n        } else {\n          // If it's (props.params).<name>, await the member access\n          // const pathOfCurrentParam = path.get('params', propsArgumentIndex)\n          // const paramScope = findClosetParentFunctionScope(pathOfCurrentParam, j)\n          const awaited = awaitMemberAccessOfProp(argName, path, j);\n          modified ||= awaited;\n        }\n        modified ||= modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n        // cases of passing down `props` into any function\n        // Page(props) { callback(props) }\n        // search for all the argument of CallExpression, where currentParam is one of the arguments\n        const callExpressions = j(path).find(j.CallExpression, {\n          arguments: args => {\n            return args.some(arg => {\n              return j.Identifier.check(arg) && arg.name === argName && arg.type === 'Identifier';\n            });\n          }\n        });\n        // Add a comment to warn users that properties of `props` need to be awaited when accessed\n        callExpressions.forEach(callExpression => {\n          // find the argument `currentParam`\n          const args = callExpression.value.arguments;\n          const propPassedAsArg = args.find(arg => j.Identifier.check(arg) && arg.name === argName);\n          const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${argName}' is passed as an argument. Any asynchronous properties of 'props' must be awaited when accessed. `;\n          const inserted = (0, utils_1.insertCommentOnce)(propPassedAsArg, j, comment);\n          modified ||= inserted;\n        });\n        if (modified) {\n          modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n        }\n      }\n      if (modifiedPropArgument) {\n        const isModified = resolveAsyncProp(path, propertiesMap, propsIdentifier.name, allProperties, isDefaultExport);\n        if (isModified) {\n          // Make TS happy\n          if (j.ObjectPattern.check(currentParam)) {\n            modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n          }\n          // Override the first param to `props`\n          params[propsArgumentIndex] = propsIdentifier;\n          modified = true;\n        }\n      } else {\n        // When the prop argument is not destructured, we need to add comments to the spread properties\n        if (j.Identifier.check(currentParam)) {\n          const commented = commentSpreadProps(path, currentParam.name, j);\n          const modifiedTypes = modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n          modified ||= commented || modifiedTypes;\n        }\n      }\n    }\n    // Helper function to insert `const params = await asyncParams;` at the beginning of the function body\n    function resolveAsyncProp(path, propertiesMap, propsIdentifierName, allProperties, isDefaultExport) {\n      var _path$value$id;\n      // Rename props to `prop` argument for the function\n      const insertedRenamedPropFunctionNames = new Set();\n      const node = path.value;\n      // If it's sync default export, and it's also server component, make the function async\n      if (isDefaultExport && !isClientComponent) {\n        const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(path.get('body'), j);\n        if (node.async === false && !hasReactHooksUsage) {\n          node.async = true;\n          (0, utils_1.turnFunctionReturnTypeToAsync)(node, j);\n        }\n      }\n      // If it's arrow function and function body is not block statement, check if the properties are used there\n      if (j.ArrowFunctionExpression.check(path.node) && !j.BlockStatement.check(path.node.body)) {\n        const objectExpression = path.node.body;\n        let hasUsedProps = false;\n        j(objectExpression).find(j.Identifier).forEach(identifierPath => {\n          const idName = identifierPath.value.name;\n          if (propertiesMap.has(idName)) {\n            hasUsedProps = true;\n            return;\n          }\n        });\n        // Turn the function body to block statement, return the object expression\n        if (hasUsedProps) {\n          path.node.body = j.blockStatement([j.returnStatement(objectExpression)]);\n        }\n      }\n      const isAsyncFunc = !!node.async;\n      const functionName = ((_path$value$id = path.value.id) === null || _path$value$id === void 0 ? void 0 : _path$value$id.name) || 'default';\n      const functionBody = (0, utils_1.findFunctionBody)(path);\n      const functionBodyPath = path.get('body');\n      const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(functionBodyPath, j);\n      const hasOtherProperties = allProperties.length > propertiesMap.size;\n      function createDestructuringDeclaration(properties, destructPropsIdentifierName) {\n        const propsToKeep = [];\n        let restProperty = null;\n        // Iterate over the destructured properties\n        properties.forEach(property => {\n          if (j.ObjectProperty.check(property)) {\n            // Handle normal and computed properties\n            const keyName = j.Identifier.check(property.key) ? property.key.name : j.Literal.check(property.key) ? property.key.value : null; // for computed properties\n            if (typeof keyName === 'string') {\n              propsToKeep.push(property);\n            }\n          } else if (j.RestElement.check(property)) {\n            restProperty = property;\n          }\n        });\n        if (propsToKeep.length === 0 && !restProperty) {\n          return null;\n        }\n        if (restProperty) {\n          propsToKeep.push(restProperty);\n        }\n        return j.variableDeclaration('const', [j.variableDeclarator(j.objectPattern(propsToKeep), j.identifier(destructPropsIdentifierName))]);\n      }\n      if (hasOtherProperties) {\n        /**\n         * If there are other properties, we need to keep the original param with destructuring\n         * e.g.\n         * input:\n         * Page({ params: { slug }, otherProp }) {\n         *   const { slug } = await props.params;\n         * }\n         *\n         * output:\n         * Page(props) {\n         *   const { otherProp } = props; // inserted\n         *   // ...rest of the function body\n         * }\n         */\n        const restProperties = allProperties.filter(prop => {\n          const isTargetProps = 'key' in prop && prop.key.type === 'Identifier' && utils_1.TARGET_PROP_NAMES.has(prop.key.name);\n          return !isTargetProps;\n        });\n        const destructionOtherPropertiesDeclaration = createDestructuringDeclaration(restProperties, propsIdentifierName);\n        if (functionBody && destructionOtherPropertiesDeclaration) {\n          functionBody.unshift(destructionOtherPropertiesDeclaration);\n        }\n      }\n      let modifiedPropertyCount = 0;\n      for (const [matchedPropName, paramsProperty] of propertiesMap) {\n        if (!utils_1.TARGET_PROP_NAMES.has(matchedPropName)) {\n          continue;\n        }\n        // In client component, if the param is already wrapped with `use()`, skip the transformation\n        if (isClientComponent) {\n          let shouldSkip = false;\n          const propPaths = j(path).find(j.Identifier, {\n            name: matchedPropName\n          });\n          for (const propPath of propPaths.paths()) {\n            if ((0, utils_1.isParentUseCallExpression)(propPath, j)) {\n              // Skip transformation\n              shouldSkip = true;\n              break;\n            }\n          }\n          if (shouldSkip) {\n            continue;\n          }\n        }\n        const paramsPropertyName = j.Identifier.check(paramsProperty) ? paramsProperty.name : null;\n        const paramPropertyName = paramsPropertyName || matchedPropName;\n        // If propName is an identifier and not used in lower scope,\n        // also skip the transformation.\n        const hasUsedInBody = j(functionBodyPath).find(j.Identifier, {\n          name: paramPropertyName\n        }).size() > 0;\n        if (!hasUsedInBody && j.Identifier.check(paramsProperty)) continue;\n        // Search the usage of propName in the function body,\n        // if they're all awaited or wrapped with use(), skip the transformation\n        const propUsages = j(functionBodyPath).find(j.Identifier, {\n          name: paramPropertyName\n        });\n        // if there's usage of the propName, then do the check\n        if (propUsages.size()) {\n          let hasMissingAwaited = false;\n          propUsages.forEach(propUsage => {\n            var _propUsage$parentPath;\n            // If the parent is not AwaitExpression, it's not awaited\n            const isAwaited = ((_propUsage$parentPath = propUsage.parentPath) === null || _propUsage$parentPath === void 0 ? void 0 : _propUsage$parentPath.value.type) === 'AwaitExpression';\n            const isAwaitedByUse = (0, utils_1.isParentUseCallExpression)(propUsage, j);\n            if (!isAwaited && !isAwaitedByUse) {\n              hasMissingAwaited = true;\n              return;\n            }\n          });\n          // If all the usages of parm are awaited, skip the transformation\n          if (!hasMissingAwaited) {\n            continue;\n          }\n        }\n        modifiedPropertyCount++;\n        const propNameIdentifier = j.identifier(matchedPropName);\n        const propsIdentifier = j.identifier(propsIdentifierName);\n        const accessedPropIdExpr = j.memberExpression(propsIdentifier, propNameIdentifier);\n        // Check param property value, if it's destructed, we need to destruct it as well\n        // e.g.\n        // input: Page({ params: { slug } })\n        // output: const { slug } = await props.params; rather than const props = await props.params;\n        const uid = functionName + ':' + paramPropertyName;\n        if ((paramsProperty === null || paramsProperty === void 0 ? void 0 : paramsProperty.type) === 'ObjectPattern') {\n          const objectPattern = paramsProperty;\n          const objectPatternProperties = objectPattern.properties;\n          // destruct the object pattern, e.g. { slug } => const { slug } = params;\n          const destructedObjectPattern = j.variableDeclaration('const', [j.variableDeclarator(j.objectPattern(objectPatternProperties.map(prop => {\n            if (prop.type === 'Property' && prop.key.type === 'Identifier') {\n              return j.objectProperty(j.identifier(prop.key.name), j.identifier(prop.key.name));\n            }\n            return prop;\n          })), propNameIdentifier)]);\n          if (!insertedDestructPropNames.has(uid) && functionBody) {\n            functionBody.unshift(destructedObjectPattern);\n            insertedDestructPropNames.add(uid);\n          }\n        }\n        if (isAsyncFunc) {\n          // If it's async function, add await to the async props.<propName>\n          const paramAssignment = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(paramPropertyName), j.awaitExpression(accessedPropIdExpr))]);\n          if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n            functionBody.unshift(paramAssignment);\n            insertedRenamedPropFunctionNames.add(uid);\n          }\n        } else {\n          if (!isClientComponent && (0, utils_1.isFunctionType)(node.type) && !hasReactHooksUsage) {\n            // If it's export function, populate the function to async\n            node.async = true;\n            (0, utils_1.turnFunctionReturnTypeToAsync)(node, j);\n            // Insert `const <propName> = await props.<propName>;` at the beginning of the function body\n            const paramAssignment = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(paramPropertyName), j.awaitExpression(accessedPropIdExpr))]);\n            if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n              functionBody.unshift(paramAssignment);\n              insertedRenamedPropFunctionNames.add(uid);\n            }\n          } else {\n            const paramAssignment = j.variableDeclaration('const', [j.variableDeclarator(j.identifier(paramPropertyName), j.callExpression(j.identifier('use'), [accessedPropIdExpr]))]);\n            if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n              needsReactUseImport = true;\n              functionBody.unshift(paramAssignment);\n              insertedRenamedPropFunctionNames.add(uid);\n            }\n          }\n        }\n      }\n      return modifiedPropertyCount > 0;\n    }\n    const defaultExportsDeclarations = root.find(j.ExportDefaultDeclaration);\n    defaultExportsDeclarations.forEach(path => {\n      const functionPath = (0, utils_1.getFunctionPathFromExportPath)(path, j, root, () => true);\n      if (functionPath) {\n        renameAsyncPropIfExisted(functionPath, true);\n      }\n    });\n    // Matching Next.js functional named export of route entry:\n    // - export function <named>(...) { ... }\n    // - export const <named> = ...\n    const namedExportDeclarations = root.find(j.ExportNamedDeclaration);\n    namedExportDeclarations.forEach(path => {\n      const functionPath = (0, utils_1.getFunctionPathFromExportPath)(path, j, root, idName => utils_1.TARGET_NAMED_EXPORTS.has(idName));\n      if (functionPath) {\n        renameAsyncPropIfExisted(functionPath, false);\n      }\n    });\n  }\n  const isClientComponent = (0, utils_1.determineClientDirective)(root, j);\n  // Apply to `params` and `searchParams`\n  processAsyncPropOfEntryFile(isClientComponent);\n  // Add import { use } from 'react' if needed and not already imported\n  if (needsReactUseImport) {\n    (0, utils_1.insertReactUseImport)(root, j);\n  }\n  const commented = commentOnMatchedReExports(root, j);\n  modified ||= commented;\n  return modified ? root.toSource() : null;\n}\nfunction findAllTypes(root, j, typeName) {\n  const types = {\n    interfaces: [],\n    typeAliases: [],\n    imports: [],\n    references: []\n  };\n  // Step 1: Find all interface declarations with the specified name\n  root.find(j.TSInterfaceDeclaration, {\n    id: {\n      type: 'Identifier',\n      name: typeName\n    }\n  }).forEach(path => {\n    types.interfaces.push(path.node);\n  });\n  // Step 2: Find all type alias declarations with the specified name\n  root.find(j.TSTypeAliasDeclaration, {\n    id: {\n      type: 'Identifier',\n      name: typeName\n    }\n  }).forEach(path => {\n    types.typeAliases.push(path.node);\n  });\n  // Step 3: Find all imported types with the specified name\n  root.find(j.ImportSpecifier, {\n    imported: {\n      type: 'Identifier',\n      name: typeName\n    }\n  }).forEach(path => {\n    types.imports.push(path.node);\n  });\n  // Step 4: Find all references to the specified type\n  root.find(j.TSTypeReference, {\n    typeName: {\n      type: 'Identifier',\n      name: typeName\n    }\n  }).forEach(path => {\n    types.references.push(path.node);\n  });\n  return types;\n}\nfunction commentSpreadProps(path, propsIdentifierName, j) {\n  let modified = false;\n  const functionBody = (0, utils_1.findFunctionBody)(path);\n  const functionBodyCollection = j(functionBody);\n  // Find all the usage of spreading properties of `props`\n  const jsxSpreadProperties = functionBodyCollection.find(j.JSXSpreadAttribute, {\n    argument: {\n      name: propsIdentifierName\n    }\n  });\n  const objSpreadProperties = functionBodyCollection.find(j.SpreadElement, {\n    argument: {\n      name: propsIdentifierName\n    }\n  });\n  const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${propsIdentifierName}' is used with spread syntax (...). Any asynchronous properties of '${propsIdentifierName}' must be awaited when accessed. `;\n  // Add comment before it\n  jsxSpreadProperties.forEach(spread => {\n    const inserted = (0, utils_1.insertCommentOnce)(spread.value, j, comment);\n    if (inserted) modified = true;\n  });\n  objSpreadProperties.forEach(spread => {\n    const inserted = (0, utils_1.insertCommentOnce)(spread.value, j, comment);\n    if (inserted) modified = true;\n  });\n  return modified;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRyYW5zZm9ybUR5bmFtaWNQcm9wcyIsInV0aWxzXzEiLCJyZXF1aXJlIiwicGFyc2VyXzEiLCJQQUdFX1BST1BTIiwiYXdhaXRNZW1iZXJBY2Nlc3NPZlByb3AiLCJwcm9wSWROYW1lIiwicGF0aCIsImoiLCJmdW5jdGlvbkJvZHkiLCJmaW5kRnVuY3Rpb25Cb2R5IiwibWVtYmVyQWNjZXNzIiwiZmluZCIsIk1lbWJlckV4cHJlc3Npb24iLCJvYmplY3QiLCJ0eXBlIiwibmFtZSIsImhhc0F3YWl0ZWQiLCJmb3JFYWNoIiwibWVtYmVyQWNjZXNzUGF0aCIsIl9tZW1iZXJBY2Nlc3NQYXRoJHBhciIsIl9wYXJlbnRTY29wZU9mTWVtYmVyQSIsIm1lbWJlciIsIm1lbWJlclByb3BlcnR5IiwicHJvcGVydHkiLCJpc0FjY2Vzc2luZ01hdGNoZWRQcm9wZXJ0eSIsIklkZW50aWZpZXIiLCJjaGVjayIsIlRBUkdFVF9QUk9QX05BTUVTIiwiaGFzIiwiaXNQYXJlbnRQcm9taXNlQWxsQ2FsbEV4cHJlc3Npb24iLCJwYXJlbnRQYXRoIiwicGFyZW50U2NvcGVPZk1lbWJlckFjY2VzcyIsImZpbmRDbG9zZXRQYXJlbnRGdW5jdGlvblNjb3BlIiwiYXN5bmMiLCJub2RlIiwiY29tbWVudCIsIk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVgiLCJpbnNlcnRDb21tZW50T25jZSIsImF3YWl0ZWRFeHByIiwiYXdhaXRFeHByZXNzaW9uIiwiYXdhaXRNZW1iZXJBY2Nlc3MiLCJ3cmFwUGFyZW50aGVzZUlmTmVlZGVkIiwicmVwbGFjZSIsImhhc1JlYWN0SG9va3NVc2FnZSIsImNvbnRhaW5zUmVhY3RIb29rc0NhbGxFeHByZXNzaW9ucyIsImdldCIsInR1cm5GdW5jdGlvblJldHVyblR5cGVUb0FzeW5jIiwiYXBwbHlVc2VBbmRSZW5hbWVBY2Nlc3NlZFByb3AiLCJtb2RpZmllZCIsImFjY2Vzc2VkTmFtZXMiLCJpc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uIiwicHVzaCIsImN1cnJlbnRNZW1iZXIiLCJsZW5ndGgiLCJhY2Nlc3NlZFByb3BJZCIsImlkZW50aWZpZXIiLCJhY2Nlc3NlZFByb3AiLCJtZW1iZXJFeHByZXNzaW9uIiwidXNlQ2FsbCIsImNhbGxFeHByZXNzaW9uIiwidXNlRGVjbGFyYXRpb24iLCJ2YXJpYWJsZURlY2xhcmF0aW9uIiwidmFyaWFibGVEZWNsYXJhdG9yIiwidW5zaGlmdCIsImNvbW1lbnRPbk1hdGNoZWRSZUV4cG9ydHMiLCJyb290IiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsIkV4cG9ydFNwZWNpZmllciIsInNwZWNpZmllcnMiLCJzcGVjaWZpZXIiLCJUQVJHRVRfTkFNRURfRVhQT1JUUyIsImV4cG9ydGVkIiwiTGl0ZXJhbCIsInNvdXJjZSIsImxvY2FsTmFtZSIsImxvY2FsIiwiY29tbWVudEluc2VydGVkIiwibG9jYWxJZGVudGlmaWVyIiwiaW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWNsYXJhdGlvbiIsImZpbHRlciIsImltcG9ydFBhdGgiLCJzb21lIiwiaW1wb3J0U3BlY2lmaWVyIiwic2l6ZSIsIm1vZGlmeVR5cGVzIiwicGFyYW1UeXBlQW5ub3RhdGlvbiIsInByb3BzSWRlbnRpZmllciIsInR5cGVBbm5vdGF0aW9uIiwidHlwZUxpdGVyYWwiLCJtZW1iZXJzIiwia2V5IiwidHlwZU5hbWUiLCJUU1R5cGUiLCJ0c1R5cGVSZWZlcmVuY2UiLCJ0c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uIiwidHlwZVJlZmVyZW5jZSIsImZvdW5kVHlwZXMiLCJmaW5kQWxsVHlwZXMiLCJpbnRlcmZhY2VzIiwiX2ludGVyZmFjZURlY2xhcmF0aW9uIiwiaW50ZXJmYWNlRGVjbGFyYXRpb24iLCJib2R5IiwidHlwZUJvZHkiLCJfbWVtYmVyJHR5cGVBbm5vdGF0aW8iLCJ0eXBlQWxpYXNlcyIsInR5cGVBbGlhc0RlY2xhcmF0aW9uIiwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiIsInR5cGVBbGlhcyIsIlRTVHlwZUxpdGVyYWwiLCJUU1Byb3BlcnR5U2lnbmF0dXJlIiwiaW1wb3J0cyIsIl90eXBlUmVmZXJlbmNlJHR5cGVQYSIsInByb3BUeXBlIiwidHlwZVBhcmFtZXRlcnMiLCJwYXJhbXMiLCJfYXBpIiwiZmlsZVBhdGgiLCJpc0VudHJ5RmlsZSIsIk5FWFRKU19FTlRSWV9GSUxFUyIsInRlc3QiLCJtb2RpZmllZFByb3BBcmd1bWVudCIsImNyZWF0ZVBhcnNlckZyb21QYXRoIiwibmVlZHNSZWFjdFVzZUltcG9ydCIsImluc2VydGVkRGVzdHJ1Y3RQcm9wTmFtZXMiLCJTZXQiLCJwcm9jZXNzQXN5bmNQcm9wT2ZFbnRyeUZpbGUiLCJpc0NsaWVudENvbXBvbmVudCIsInJlbmFtZUFzeW5jUHJvcElmRXhpc3RlZCIsImlzRGVmYXVsdEV4cG9ydCIsIl9kZWNsJGlkIiwiZGVjbCIsImZ1bmN0aW9uTmFtZSIsImlkIiwiX3JlZiIsImdldFZhcmlhYmxlRGVjbGFyYXRvcklkIiwicHJvcGVydGllc01hcCIsIk1hcCIsImFsbFByb3BlcnRpZXMiLCJpc1JvdXRlIiwiVEFSR0VUX1JPVVRFX0VYUE9SVFMiLCJnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIiLCJwcm9wc0FyZ3VtZW50SW5kZXgiLCJjdXJyZW50UGFyYW0iLCJmb3VuZFRhcmdldFByb3AiLCJwcm9wIiwicHJvcGVydGllcyIsInByb3BOYW1lIiwiUHJvcGVydHkiLCJPYmplY3RQcm9wZXJ0eSIsInNldCIsImFyZ05hbWUiLCJtb2RpZmllZFByb3AiLCJhd2FpdGVkIiwiY2FsbEV4cHJlc3Npb25zIiwiQ2FsbEV4cHJlc3Npb24iLCJhcmd1bWVudHMiLCJhcmdzIiwiYXJnIiwicHJvcFBhc3NlZEFzQXJnIiwiaW5zZXJ0ZWQiLCJpc01vZGlmaWVkIiwicmVzb2x2ZUFzeW5jUHJvcCIsIk9iamVjdFBhdHRlcm4iLCJjb21tZW50ZWQiLCJjb21tZW50U3ByZWFkUHJvcHMiLCJtb2RpZmllZFR5cGVzIiwicHJvcHNJZGVudGlmaWVyTmFtZSIsIl9wYXRoJHZhbHVlJGlkIiwiaW5zZXJ0ZWRSZW5hbWVkUHJvcEZ1bmN0aW9uTmFtZXMiLCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiIsIkJsb2NrU3RhdGVtZW50Iiwib2JqZWN0RXhwcmVzc2lvbiIsImhhc1VzZWRQcm9wcyIsImlkZW50aWZpZXJQYXRoIiwiaWROYW1lIiwiYmxvY2tTdGF0ZW1lbnQiLCJyZXR1cm5TdGF0ZW1lbnQiLCJpc0FzeW5jRnVuYyIsImZ1bmN0aW9uQm9keVBhdGgiLCJoYXNPdGhlclByb3BlcnRpZXMiLCJjcmVhdGVEZXN0cnVjdHVyaW5nRGVjbGFyYXRpb24iLCJkZXN0cnVjdFByb3BzSWRlbnRpZmllck5hbWUiLCJwcm9wc1RvS2VlcCIsInJlc3RQcm9wZXJ0eSIsImtleU5hbWUiLCJSZXN0RWxlbWVudCIsIm9iamVjdFBhdHRlcm4iLCJyZXN0UHJvcGVydGllcyIsImlzVGFyZ2V0UHJvcHMiLCJkZXN0cnVjdGlvbk90aGVyUHJvcGVydGllc0RlY2xhcmF0aW9uIiwibW9kaWZpZWRQcm9wZXJ0eUNvdW50IiwibWF0Y2hlZFByb3BOYW1lIiwicGFyYW1zUHJvcGVydHkiLCJzaG91bGRTa2lwIiwicHJvcFBhdGhzIiwicHJvcFBhdGgiLCJwYXRocyIsInBhcmFtc1Byb3BlcnR5TmFtZSIsInBhcmFtUHJvcGVydHlOYW1lIiwiaGFzVXNlZEluQm9keSIsInByb3BVc2FnZXMiLCJoYXNNaXNzaW5nQXdhaXRlZCIsInByb3BVc2FnZSIsIl9wcm9wVXNhZ2UkcGFyZW50UGF0aCIsImlzQXdhaXRlZCIsImlzQXdhaXRlZEJ5VXNlIiwicHJvcE5hbWVJZGVudGlmaWVyIiwiYWNjZXNzZWRQcm9wSWRFeHByIiwidWlkIiwib2JqZWN0UGF0dGVyblByb3BlcnRpZXMiLCJkZXN0cnVjdGVkT2JqZWN0UGF0dGVybiIsIm1hcCIsIm9iamVjdFByb3BlcnR5IiwiYWRkIiwicGFyYW1Bc3NpZ25tZW50IiwiaXNGdW5jdGlvblR5cGUiLCJkZWZhdWx0RXhwb3J0c0RlY2xhcmF0aW9ucyIsIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiIsImZ1bmN0aW9uUGF0aCIsImdldEZ1bmN0aW9uUGF0aEZyb21FeHBvcnRQYXRoIiwibmFtZWRFeHBvcnREZWNsYXJhdGlvbnMiLCJkZXRlcm1pbmVDbGllbnREaXJlY3RpdmUiLCJpbnNlcnRSZWFjdFVzZUltcG9ydCIsInRvU291cmNlIiwidHlwZXMiLCJyZWZlcmVuY2VzIiwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiIsIkltcG9ydFNwZWNpZmllciIsImltcG9ydGVkIiwiVFNUeXBlUmVmZXJlbmNlIiwiZnVuY3Rpb25Cb2R5Q29sbGVjdGlvbiIsImpzeFNwcmVhZFByb3BlcnRpZXMiLCJKU1hTcHJlYWRBdHRyaWJ1dGUiLCJhcmd1bWVudCIsIm9ialNwcmVhZFByb3BlcnRpZXMiLCJTcHJlYWRFbGVtZW50Iiwic3ByZWFkIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL0BuZXh0L2NvZGVtb2QvdHJhbnNmb3Jtcy9saWIvYXN5bmMtcmVxdWVzdC1hcGkvIiwic291cmNlcyI6WyJuZXh0LWFzeW5jLWR5bmFtaWMtcHJvcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJhbnNmb3JtRHluYW1pY1Byb3BzID0gdHJhbnNmb3JtRHluYW1pY1Byb3BzO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL3BhcnNlclwiKTtcbmNvbnN0IFBBR0VfUFJPUFMgPSAncHJvcHMnO1xuLy8gRmluZCBhbGwgdGhlIG1lbWJlciBhY2Nlc3Mgb2YgdGhlIHByb3AsIGFuZCBhd2FpdCB0aGVtXG4vLyBlLmcuIElmIHRoZXJlJ3MgYXJndW1lbnQgYHByb3BzYCwgZmluZCBhbGwgdGhlIG1lbWJlciBhY2Nlc3Mgb2YgcHJvcHMuPG5hbWU+LlxuLy8gSWYgdGhlIG1lbWJlciBhY2Nlc3MgY2FuIGJlIGF3YWl0ZWQsIGF3YWl0IHRoZW0uXG5mdW5jdGlvbiBhd2FpdE1lbWJlckFjY2Vzc09mUHJvcChwcm9wSWROYW1lLCBwYXRoLCBqKSB7XG4gICAgLy8gc2VhcmNoIHRoZSBtZW1iZXIgYWNjZXNzIG9mIHRoZSBwcm9wXG4gICAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gKDAsIHV0aWxzXzEuZmluZEZ1bmN0aW9uQm9keSkocGF0aCk7XG4gICAgY29uc3QgbWVtYmVyQWNjZXNzID0gaihmdW5jdGlvbkJvZHkpLmZpbmQoai5NZW1iZXJFeHByZXNzaW9uLCB7XG4gICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgbmFtZTogcHJvcElkTmFtZSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBsZXQgaGFzQXdhaXRlZCA9IGZhbHNlO1xuICAgIC8vIGF3YWl0IGVhY2ggbWVtYmVyIGFjY2Vzc1xuICAgIG1lbWJlckFjY2Vzcy5mb3JFYWNoKChtZW1iZXJBY2Nlc3NQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IG1lbWJlckFjY2Vzc1BhdGgudmFsdWU7XG4gICAgICAgIGNvbnN0IG1lbWJlclByb3BlcnR5ID0gbWVtYmVyLnByb3BlcnR5O1xuICAgICAgICBjb25zdCBpc0FjY2Vzc2luZ01hdGNoZWRQcm9wZXJ0eSA9IGouSWRlbnRpZmllci5jaGVjayhtZW1iZXJQcm9wZXJ0eSkgJiZcbiAgICAgICAgICAgIHV0aWxzXzEuVEFSR0VUX1BST1BfTkFNRVMuaGFzKG1lbWJlclByb3BlcnR5Lm5hbWUpO1xuICAgICAgICBpZiAoIWlzQWNjZXNzaW5nTWF0Y2hlZFByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUGFyZW50UHJvbWlzZUFsbENhbGxFeHByZXNzaW9uKShtZW1iZXJBY2Nlc3NQYXRoLCBqKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgYWxyZWFkeSBhd2FpdGVkXG4gICAgICAgIGlmIChtZW1iZXJBY2Nlc3NQYXRoLnBhcmVudFBhdGg/LnZhbHVlLnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U2NvcGVPZk1lbWJlckFjY2VzcyA9ICgwLCB1dGlsc18xLmZpbmRDbG9zZXRQYXJlbnRGdW5jdGlvblNjb3BlKShtZW1iZXJBY2Nlc3NQYXRoLCBqKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgcGFyZW50IHNjb3BlIGlzIHN5bmMsIGFuZCBpdCdzIGFsc28gbm90IHRoZSBmdW5jdGlvbiBpdHNlbGYsIHdoaWNoIG1lYW5zIGl0J3Mgbm90IGFibGUgdG8gY29udmVydCB0byBhc3luYy5cbiAgICAgICAgaWYgKHBhcmVudFNjb3BlT2ZNZW1iZXJBY2Nlc3MgJiZcbiAgICAgICAgICAgICFwYXJlbnRTY29wZU9mTWVtYmVyQWNjZXNzLnZhbHVlPy5hc3luYyAmJlxuICAgICAgICAgICAgcGFyZW50U2NvcGVPZk1lbWJlckFjY2Vzcy5ub2RlICE9PSBwYXRoLm5vZGUpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IGFibGUgdG8gY29udmVydCwgYWRkIGEgY29tbWVudCB0byB0aGUgcHJvcCBhY2Nlc3MgdG8gd2FybiB0aGUgdXNlclxuICAgICAgICAgICAgLy8gZS5nLiB0aGUgcGFyZW50IHNjb3BlIGlzIHN5bmMsIGF3YWl0IGtleXdvcmQgY2FuJ3QgYmUgYXBwbGllZFxuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGAgJHt1dGlsc18xLk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVh9ICcke3Byb3BJZE5hbWV9LiR7bWVtYmVyUHJvcGVydHkubmFtZX0nIGlzIGFjY2Vzc2VkIHdpdGhvdXQgYXdhaXRpbmcuYDtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmluc2VydENvbW1lbnRPbmNlKShtZW1iZXIsIGosIGNvbW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF3YWl0ZWRFeHByID0gai5hd2FpdEV4cHJlc3Npb24obWVtYmVyKTtcbiAgICAgICAgY29uc3QgYXdhaXRNZW1iZXJBY2Nlc3MgPSAoMCwgdXRpbHNfMS53cmFwUGFyZW50aGVzZUlmTmVlZGVkKSh0cnVlLCBqLCBhd2FpdGVkRXhwcik7XG4gICAgICAgIG1lbWJlckFjY2Vzc1BhdGgucmVwbGFjZShhd2FpdE1lbWJlckFjY2Vzcyk7XG4gICAgICAgIGhhc0F3YWl0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IGhhc1JlYWN0SG9va3NVc2FnZSA9ICgwLCB1dGlsc18xLmNvbnRhaW5zUmVhY3RIb29rc0NhbGxFeHByZXNzaW9ucykocGF0aC5nZXQoJ2JvZHknKSwgaik7XG4gICAgLy8gSWYgdGhlcmUncyBhbnkgYXdhaXRlZCBtZW1iZXIgYWNjZXNzLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIGFzeW5jXG4gICAgaWYgKGhhc0F3YWl0ZWQpIHtcbiAgICAgICAgaWYgKHBhdGgudmFsdWUuYXN5bmMgPT09IGZhbHNlICYmICFoYXNSZWFjdEhvb2tzVXNhZ2UpIHtcbiAgICAgICAgICAgIHBhdGgudmFsdWUuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEudHVybkZ1bmN0aW9uUmV0dXJuVHlwZVRvQXN5bmMpKHBhdGgudmFsdWUsIGopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNBd2FpdGVkO1xufVxuZnVuY3Rpb24gYXBwbHlVc2VBbmRSZW5hbWVBY2Nlc3NlZFByb3AocHJvcElkTmFtZSwgcGF0aCwgaikge1xuICAgIC8vIHNlYXJjaCB0aGUgbWVtYmVyIGFjY2VzcyBvZiB0aGUgcHJvcCwgYW5kIHJlbmFtZSB0aGUgbWVtYmVyIGFjY2VzcyB0byB0aGUgbWVtYmVyIHZhbHVlXG4gICAgLy8gZS5nLlxuICAgIC8vIHByb3BzLnBhcmFtcyA9PiBwYXJhbXNcbiAgICAvLyBwcm9wcy5wYXJhbXMuZm9vID0+IHBhcmFtcy5mb29cbiAgICAvLyBwcm9wcy5zZWFyY2hQYXJhbXMuc2VhcmNoID0+IHNlYXJjaFBhcmFtcy5zZWFyY2hcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSAoMCwgdXRpbHNfMS5maW5kRnVuY3Rpb25Cb2R5KShwYXRoKTtcbiAgICBjb25zdCBtZW1iZXJBY2Nlc3MgPSBqKGZ1bmN0aW9uQm9keSkuZmluZChqLk1lbWJlckV4cHJlc3Npb24sIHtcbiAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiBwcm9wSWROYW1lLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGFjY2Vzc2VkTmFtZXMgPSBbXTtcbiAgICAvLyByZW5hbWUgZWFjaCBtZW1iZXIgYWNjZXNzXG4gICAgbWVtYmVyQWNjZXNzLmZvckVhY2goKG1lbWJlckFjY2Vzc1BhdGgpID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIG1lbWJlciBhY2Nlc3MgZXhwcmVzc2lvbiBpcyBmaXJzdCBhcmd1bWVudCBvZiBgdXNlKClgLCB3ZSBza2lwXG4gICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uKShtZW1iZXJBY2Nlc3NQYXRoLCBqKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IG1lbWJlckFjY2Vzc1BhdGgudmFsdWU7XG4gICAgICAgIGNvbnN0IG1lbWJlclByb3BlcnR5ID0gbWVtYmVyLnByb3BlcnR5O1xuICAgICAgICBpZiAoai5JZGVudGlmaWVyLmNoZWNrKG1lbWJlclByb3BlcnR5KSkge1xuICAgICAgICAgICAgYWNjZXNzZWROYW1lcy5wdXNoKG1lbWJlclByb3BlcnR5Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGouTWVtYmVyRXhwcmVzc2lvbi5jaGVjayhtZW1iZXJQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TWVtYmVyID0gbWVtYmVyUHJvcGVydHk7XG4gICAgICAgICAgICBpZiAoai5JZGVudGlmaWVyLmNoZWNrKGN1cnJlbnRNZW1iZXIub2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc2VkTmFtZXMucHVzaChjdXJyZW50TWVtYmVyLm9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZW1iZXJBY2Nlc3NQYXRoLnJlcGxhY2UobWVtYmVyUHJvcGVydHkpO1xuICAgIH0pO1xuICAgIC8vIElmIHRoZXJlJ3MgYW55IHJlbmFtZWQgbWVtYmVyIGFjY2VzcywgbmVlZCB0byBjYWxsIGB1c2UoKWAgb250byBtZW1iZXIgYWNjZXNzXG4gICAgLy8gZS5nLiBbJ3BhcmFtcyddID0+IGluc2VydCBgY29uc3QgcGFyYW1zID0gdXNlKHByb3BzLnBhcmFtcylgXG4gICAgaWYgKGFjY2Vzc2VkTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NlZFByb3BJZCA9IGouaWRlbnRpZmllcihwcm9wSWROYW1lKTtcbiAgICAgICAgY29uc3QgYWNjZXNzZWRQcm9wID0gai5tZW1iZXJFeHByZXNzaW9uKGFjY2Vzc2VkUHJvcElkLCBqLmlkZW50aWZpZXIoYWNjZXNzZWROYW1lc1swXSkpO1xuICAgICAgICBjb25zdCB1c2VDYWxsID0gai5jYWxsRXhwcmVzc2lvbihqLmlkZW50aWZpZXIoJ3VzZScpLCBbYWNjZXNzZWRQcm9wXSk7XG4gICAgICAgIGNvbnN0IHVzZURlY2xhcmF0aW9uID0gai52YXJpYWJsZURlY2xhcmF0aW9uKCdjb25zdCcsIFtcbiAgICAgICAgICAgIGoudmFyaWFibGVEZWNsYXJhdG9yKGouaWRlbnRpZmllcihhY2Nlc3NlZE5hbWVzWzBdKSwgdXNlQ2FsbCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoZnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICBmdW5jdGlvbkJvZHkudW5zaGlmdCh1c2VEZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWQ7XG59XG5mdW5jdGlvbiBjb21tZW50T25NYXRjaGVkUmVFeHBvcnRzKHJvb3QsIGopIHtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICByb290LmZpbmQoai5FeHBvcnROYW1lZERlY2xhcmF0aW9uKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChqLkV4cG9ydFNwZWNpZmllci5jaGVjayhwYXRoLnZhbHVlLnNwZWNpZmllcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXJzID0gcGF0aC52YWx1ZS5zcGVjaWZpZXJzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2Ygc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChqLkV4cG9ydFNwZWNpZmllci5jaGVjayhzcGVjaWZpZXIpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgbWF0Y2hlZCBuYW1lZCBleHBvcnRzIGFuZCBkZWZhdWx0IGV4cG9ydFxuICAgICAgICAgICAgICAgICAgICAodXRpbHNfMS5UQVJHRVRfTkFNRURfRVhQT1JUUy5oYXMoc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSA9PT0gJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoai5MaXRlcmFsLmNoZWNrKHBhdGgudmFsdWUuc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gc3BlY2lmaWVyLmxvY2FsLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50SW5zZXJ0ZWQgPSAoMCwgdXRpbHNfMS5pbnNlcnRDb21tZW50T25jZSkoc3BlY2lmaWVyLCBqLCBgICR7dXRpbHNfMS5ORVhUX0NPREVNT0RfRVJST1JfUFJFRklYfSBcXGAke2xvY2FsTmFtZX1cXGAgZXhwb3J0IGlzIHJlLWV4cG9ydGVkLiBDaGVjayBpZiB0aGlzIGNvbXBvbmVudCB1c2VzIFxcYHBhcmFtc1xcYCBvciBcXGBzZWFyY2hQYXJhbXNcXGBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkIHx8PSBjb21tZW50SW5zZXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aC52YWx1ZS5zb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSWRlbnRpZmllciA9IHNwZWNpZmllci5sb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGxvY2FsSWRlbnRpZmllci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGlmIGxvY2FsIGlkZW50aWZpZXIgaXMgZnJvbSBpbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnREZWNsYXJhdGlvbiA9IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZChqLkltcG9ydERlY2xhcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGltcG9ydFBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0UGF0aC52YWx1ZS5zcGVjaWZpZXJzLnNvbWUoKGltcG9ydFNwZWNpZmllcikgPT4gaW1wb3J0U3BlY2lmaWVyLmxvY2FsLm5hbWUgPT09IGxvY2FsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnREZWNsYXJhdGlvbi5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEluc2VydGVkID0gKDAsIHV0aWxzXzEuaW5zZXJ0Q29tbWVudE9uY2UpKHNwZWNpZmllciwgaiwgYCAke3V0aWxzXzEuTkVYVF9DT0RFTU9EX0VSUk9SX1BSRUZJWH0gXFxgJHtsb2NhbE5hbWV9XFxgIGV4cG9ydCBpcyByZS1leHBvcnRlZC4gQ2hlY2sgaWYgdGhpcyBjb21wb25lbnQgdXNlcyBcXGBwYXJhbXNcXGAgb3IgXFxgc2VhcmNoUGFyYW1zXFxgYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgfHw9IGNvbW1lbnRJbnNlcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZDtcbn1cbmZ1bmN0aW9uIG1vZGlmeVR5cGVzKHBhcmFtVHlwZUFubm90YXRpb24sIHByb3BzSWRlbnRpZmllciwgcm9vdCwgaikge1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChwYXJhbVR5cGVBbm5vdGF0aW9uICYmIHBhcmFtVHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgY29uc3QgdHlwZUFubm90YXRpb24gPSBwYXJhbVR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uO1xuICAgICAgICBpZiAodHlwZUFubm90YXRpb24udHlwZSA9PT0gJ1RTVHlwZUxpdGVyYWwnKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlTGl0ZXJhbCA9IHR5cGVBbm5vdGF0aW9uO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdHlwZSBwcm9wZXJ0eSBmb3IgYHBhcmFtc2BcbiAgICAgICAgICAgIHR5cGVMaXRlcmFsLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci50eXBlID09PSAnVFNQcm9wZXJ0eVNpZ25hdHVyZScgJiZcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyLmtleS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5UQVJHRVRfUFJPUF9OQU1FUy5oYXMobWVtYmVyLmtleS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFscmVhZHkgYSBQcm9taXNlLCBkb24ndCB3cmFwIGl0IGFnYWluLCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci50eXBlQW5ub3RhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24udHlwZSA9PT0gJ1RTVHlwZVJlZmVyZW5jZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbi50eXBlTmFtZS50eXBlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLnR5cGVOYW1lLm5hbWUgPT09ICdQcm9taXNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIGBwYXJhbXNgIHR5cGUgaW4gUHJvbWlzZTw+XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIudHlwZUFubm90YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgai5UU1R5cGUuY2hlY2sobWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uID0gai50c1R5cGVSZWZlcmVuY2Uoai5pZGVudGlmaWVyKCdQcm9taXNlJyksIGoudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZUFubm90YXRpb24udHlwZSA9PT0gJ1RTVHlwZVJlZmVyZW5jZScpIHtcbiAgICAgICAgICAgIC8vIElmIHR5cGVBbm5vdGF0aW9uIGlzIGEgdHlwZSBvciBpbnRlcmZhY2UsIGNoYW5nZSB0aGUgcHJvcGVydGllcyB0byBQcm9taXNlPHR5cGUgb2YgcHJvcGVydHk+XG4gICAgICAgICAgICAvLyBlLmcuIGludGVyZmFjZSBQYWdlUHJvcHMgeyBwYXJhbXM6IHsgc2x1Zzogc3RyaW5nIH0gfSA9PiBpbnRlcmZhY2UgUGFnZVByb3BzIHsgcGFyYW1zOiBQcm9taXNlPHsgc2x1Zzogc3RyaW5nIH0+IH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVSZWZlcmVuY2UgPSB0eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlUmVmZXJlbmNlLnR5cGVOYW1lLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGFjdHVhbCB0eXBlIG9mIHRoZSB0eXBlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kVHlwZXMgPSBmaW5kQWxsVHlwZXMocm9vdCwgaiwgdHlwZVJlZmVyZW5jZS50eXBlTmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggaW50ZXJmYWNlc1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFR5cGVzLmludGVyZmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGZvdW5kVHlwZXMuaW50ZXJmYWNlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyZmFjZURlY2xhcmF0aW9uLnR5cGUgPT09ICdUU0ludGVyZmFjZURlY2xhcmF0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlRGVjbGFyYXRpb24uYm9keT8udHlwZSA9PT0gJ1RTSW50ZXJmYWNlQm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVCb2R5ID0gaW50ZXJmYWNlRGVjbGFyYXRpb24uYm9keS5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgUHJvbWlzZSwgZG9uJ3Qgd3JhcCBpdCBhZ2FpbiwgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmF2ZXJzZSB0aGUgdHlwZVJlZmVyZW5jZSdzIHByb3BlcnRpZXMsIGlmIGFueSBpcyBpbiBwcm9wTmFtZXMsIHdyYXAgaXQgaW4gUHJvbWlzZTw+IGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUJvZHkuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci50eXBlID09PSAnVFNQcm9wZXJ0eVNpZ25hdHVyZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLmtleS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5UQVJHRVRfUFJPUF9OQU1FUy5oYXMobWVtYmVyLmtleS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFscmVhZHkgYSBQcm9taXNlLCBkb24ndCB3cmFwIGl0IGFnYWluLCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci50eXBlQW5ub3RhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24/LnR5cGVBbm5vdGF0aW9uPy50eXBlTmFtZT8ubmFtZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUHJvbWlzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSBwcm9wIHR5cGUgaW4gUHJvbWlzZTw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIudHlwZUFubm90YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbWVtYmVyIG5hbWUgaXMgaW4gcHJvcE5hbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLlRBUkdFVF9QUk9QX05BTUVTLmhhcyhtZW1iZXIua2V5Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24gPSBqLnRzVHlwZVJlZmVyZW5jZShqLmlkZW50aWZpZXIoJ1Byb21pc2UnKSwgai50c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggdHlwZSBhbGlhc2VzXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kVHlwZXMudHlwZUFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlQWxpYXNEZWNsYXJhdGlvbiA9IGZvdW5kVHlwZXMudHlwZUFsaWFzZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChqLlRTVHlwZUFsaWFzRGVjbGFyYXRpb24uY2hlY2sodHlwZUFsaWFzRGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlQWxpYXMgPSB0eXBlQWxpYXNEZWNsYXJhdGlvbi50eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqLlRTVHlwZUxpdGVyYWwuY2hlY2sodHlwZUFsaWFzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVBbGlhcy5tZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlTGl0ZXJhbCA9IHR5cGVBbGlhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTGl0ZXJhbC5tZW1iZXJzLmZvckVhY2goKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoai5UU1Byb3BlcnR5U2lnbmF0dXJlLmNoZWNrKG1lbWJlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGouSWRlbnRpZmllci5jaGVjayhtZW1iZXIua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5UQVJHRVRfUFJPUF9OQU1FUy5oYXMobWVtYmVyLmtleS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgUHJvbWlzZSwgZG9uJ3Qgd3JhcCBpdCBhZ2FpbiwgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLnR5cGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUU1R5cGVSZWZlcmVuY2UnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLnR5cGVOYW1lLnR5cGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbi50eXBlTmFtZS5uYW1lID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUHJvbWlzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSBwcm9wIHR5cGUgaW4gUHJvbWlzZTw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnR5cGVBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgai5UU1R5cGVMaXRlcmFsLmNoZWNrKG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24gPSBqLnRzVHlwZVJlZmVyZW5jZShqLmlkZW50aWZpZXIoJ1Byb21pc2UnKSwgai50c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmRUeXBlcy5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3R5cGVSZWZlcmVuY2UudHlwZU5hbWUubmFtZScsIHR5cGVSZWZlcmVuY2UudHlwZU5hbWUubmFtZSwgZm91bmRUeXBlcylcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBSZWFjdCBQcm9wc1dpdGhDaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZVJlZmVyZW5jZS50eXBlTmFtZS5uYW1lID09PSAnUHJvcHNXaXRoQ2hpbGRyZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHR5cGVSZWZlcmVuY2UudHlwZVBhcmFtZXRlcnM/LnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGouVFNUeXBlTGl0ZXJhbC5jaGVjayhwcm9wVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVHlwZS5tZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlTGl0ZXJhbCA9IHByb3BUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVMaXRlcmFsLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqLlRTUHJvcGVydHlTaWduYXR1cmUuY2hlY2sobWVtYmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgai5JZGVudGlmaWVyLmNoZWNrKG1lbWJlci5rZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLlRBUkdFVF9QUk9QX05BTUVTLmhhcyhtZW1iZXIua2V5Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFscmVhZHkgYSBQcm9taXNlLCBkb24ndCB3cmFwIGl0IGFnYWluLCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIudHlwZUFubm90YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24udHlwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RTVHlwZVJlZmVyZW5jZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24udHlwZU5hbWUudHlwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0lkZW50aWZpZXInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uLnR5cGVOYW1lLm5hbWUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdQcm9taXNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIHByb3AgdHlwZSBpbiBQcm9taXNlPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIudHlwZUFubm90YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLlRTVHlwZUxpdGVyYWwuY2hlY2sobWVtYmVyLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbiA9IGoudHNUeXBlUmVmZXJlbmNlKGouaWRlbnRpZmllcignUHJvbWlzZScpLCBqLnRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIudHlwZUFubm90YXRpb24udHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BzSWRlbnRpZmllci50eXBlQW5ub3RhdGlvbiA9IHBhcmFtVHlwZUFubm90YXRpb247XG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmaWVkO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRHluYW1pY1Byb3BzKHNvdXJjZSwgX2FwaSwgZmlsZVBhdGgpIHtcbiAgICBjb25zdCBpc0VudHJ5RmlsZSA9IHV0aWxzXzEuTkVYVEpTX0VOVFJZX0ZJTEVTLnRlc3QoZmlsZVBhdGgpO1xuICAgIGlmICghaXNFbnRyeUZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGxldCBtb2RpZmllZFByb3BBcmd1bWVudCA9IGZhbHNlO1xuICAgIGNvbnN0IGogPSAoMCwgcGFyc2VyXzEuY3JlYXRlUGFyc2VyRnJvbVBhdGgpKGZpbGVQYXRoKTtcbiAgICBjb25zdCByb290ID0gaihzb3VyY2UpO1xuICAgIC8vIENoZWNrIGlmICd1c2UnIGZyb20gJ3JlYWN0JyBuZWVkcyB0byBiZSBpbXBvcnRlZFxuICAgIGxldCBuZWVkc1JlYWN0VXNlSW1wb3J0ID0gZmFsc2U7XG4gICAgLy8gQmFzZWQgb24gdGhlIHByb3AgbmFtZXNcbiAgICAvLyBlLmcuIGRlc3RydWN0IGBwYXJhbXNgIHsgc2x1ZyB9ID0gcGFyYW1zXG4gICAgLy8gZS5nLiBkZXN0cnVjdCBgc2VhcmNoUGFyYW1zIGB7IHNlYXJjaCB9ID0gc2VhcmNoUGFyYW1zXG4gICAgbGV0IGluc2VydGVkRGVzdHJ1Y3RQcm9wTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FzeW5jUHJvcE9mRW50cnlGaWxlKGlzQ2xpZW50Q29tcG9uZW50KSB7XG4gICAgICAgIC8vIGZpbmQgYHBhcmFtc2AgYW5kIGBzZWFyY2hQYXJhbXNgIGluIGZpbGUsIGFuZCB0cmFuc2Zvcm0gdGhlIGFjY2VzcyB0byB0aGVtXG4gICAgICAgIGZ1bmN0aW9uIHJlbmFtZUFzeW5jUHJvcElmRXhpc3RlZChwYXRoLCBpc0RlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2wgPSBwYXRoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gZGVjbC5wYXJhbXM7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gZGVjbC5pZD8ubmFtZTtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgY29uc3QgPGlkPiA9IGZ1bmN0aW9uICgpIHt9LCBsb2NhdGUgdGhlIDxpZD4gdG8gZ2V0IGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgICAgIGlmICghZGVjbC5pZCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9ICgwLCB1dGlsc18xLmdldFZhcmlhYmxlRGVjbGFyYXRvcklkKShwYXRoLCBqKT8ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhcmdldCBwcm9wZXJ0aWVzIG1hcHBpbmcsIG9ubHkgY29udGFpbnMgYHBhcmFtc2AgYW5kIGBzZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgbGV0IGFsbFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGlzUm91dGUgPSAhaXNEZWZhdWx0RXhwb3J0ICYmIHV0aWxzXzEuVEFSR0VUX1JPVVRFX0VYUE9SVFMuaGFzKGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZU1ldGFkYXRhIEFQSSBoYXMgMiBwYXJhbXNcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09ICdnZW5lcmF0ZU1ldGFkYXRhJykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMiB8fCBwYXJhbXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JvdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBhZ2UvTGF5b3V0IGRlZmF1bHQgZXhwb3J0IGhhdmUgMSBwYXJhbVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wc0lkZW50aWZpZXIgPSAoMCwgdXRpbHNfMS5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIpKFBBR0VfUFJPUFMsIHBhdGgsIGopO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNBcmd1bWVudEluZGV4ID0gaXNSb3V0ZSA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcmFtID0gcGFyYW1zW3Byb3BzQXJndW1lbnRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQYXJhbSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBBcmd1bWVudCBkZXN0cnVjdHVyaW5nIGNhc2VcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFyYW0udHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgaWYgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBgcGFyYW1zYCBhbmQgYHNlYXJjaFBhcmFtc2AsXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSBhcmUsIHF1aXQgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kVGFyZ2V0UHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBjdXJyZW50UGFyYW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2tleScgaW4gcHJvcCAmJiBwcm9wLmtleS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcC5rZXkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLlRBUkdFVF9QUk9QX05BTUVTLmhhcyhwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRhcmdldFByb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gYHBhcmFtc2Agb3IgYHNlYXJjaFBhcmFtc2AgbWF0Y2hlZCwgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBhbGxQcm9wZXJ0aWVzID0gY3VycmVudFBhcmFtLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmFtLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIGBQcm9wZXJ0eWAgb3IgYE9iamVjdFByb3BlcnR5YFxuICAgICAgICAgICAgICAgICAgICAoai5Qcm9wZXJ0eS5jaGVjayhwcm9wKSB8fCBqLk9iamVjdFByb3BlcnR5LmNoZWNrKHByb3ApKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgai5JZGVudGlmaWVyLmNoZWNrKHByb3Aua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5UQVJHRVRfUFJPUF9OQU1FUy5oYXMocHJvcC5rZXkubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJ3ZhbHVlJyBpbiBwcm9wID8gcHJvcC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzTWFwLnNldChwcm9wLmtleS5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RpZmllZFByb3BBcmd1bWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50UGFyYW0udHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBvZiBhY2Nlc3NpbmcgdGhlIHByb3BzLnBhcmFtcy48bmFtZT46XG4gICAgICAgICAgICAgICAgLy8gUGFnZShwcm9wcykge31cbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZU1ldGFkYXRhKHByb3BzLCBwYXJlbnQ/KSB7fVxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ05hbWUgPSBjdXJyZW50UGFyYW0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDbGllbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRQcm9wID0gYXBwbHlVc2VBbmRSZW5hbWVBY2Nlc3NlZFByb3AoYXJnTmFtZSwgcGF0aCwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVhY3RVc2VJbXBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIChwcm9wcy5wYXJhbXMpLjxuYW1lPiwgYXdhaXQgdGhlIG1lbWJlciBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcGF0aE9mQ3VycmVudFBhcmFtID0gcGF0aC5nZXQoJ3BhcmFtcycsIHByb3BzQXJndW1lbnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcGFyYW1TY29wZSA9IGZpbmRDbG9zZXRQYXJlbnRGdW5jdGlvblNjb3BlKHBhdGhPZkN1cnJlbnRQYXJhbSwgailcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXdhaXRlZCA9IGF3YWl0TWVtYmVyQWNjZXNzT2ZQcm9wKGFyZ05hbWUsIHBhdGgsIGopO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCB8fD0gYXdhaXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZWQgfHw9IG1vZGlmeVR5cGVzKGN1cnJlbnRQYXJhbS50eXBlQW5ub3RhdGlvbiwgcHJvcHNJZGVudGlmaWVyLCByb290LCBqKTtcbiAgICAgICAgICAgICAgICAvLyBjYXNlcyBvZiBwYXNzaW5nIGRvd24gYHByb3BzYCBpbnRvIGFueSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIFBhZ2UocHJvcHMpIHsgY2FsbGJhY2socHJvcHMpIH1cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGFsbCB0aGUgYXJndW1lbnQgb2YgQ2FsbEV4cHJlc3Npb24sIHdoZXJlIGN1cnJlbnRQYXJhbSBpcyBvbmUgb2YgdGhlIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxFeHByZXNzaW9ucyA9IGoocGF0aCkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzLnNvbWUoKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoai5JZGVudGlmaWVyLmNoZWNrKGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLm5hbWUgPT09IGFyZ05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUgPT09ICdJZGVudGlmaWVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjb21tZW50IHRvIHdhcm4gdXNlcnMgdGhhdCBwcm9wZXJ0aWVzIG9mIGBwcm9wc2AgbmVlZCB0byBiZSBhd2FpdGVkIHdoZW4gYWNjZXNzZWRcbiAgICAgICAgICAgICAgICBjYWxsRXhwcmVzc2lvbnMuZm9yRWFjaCgoY2FsbEV4cHJlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgYXJndW1lbnQgYGN1cnJlbnRQYXJhbWBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGNhbGxFeHByZXNzaW9uLnZhbHVlLmFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcFBhc3NlZEFzQXJnID0gYXJncy5maW5kKChhcmcpID0+IGouSWRlbnRpZmllci5jaGVjayhhcmcpICYmIGFyZy5uYW1lID09PSBhcmdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGAgJHt1dGlsc18xLk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVh9ICcke2FyZ05hbWV9JyBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIEFueSBhc3luY2hyb25vdXMgcHJvcGVydGllcyBvZiAncHJvcHMnIG11c3QgYmUgYXdhaXRlZCB3aGVuIGFjY2Vzc2VkLiBgO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRlZCA9ICgwLCB1dGlsc18xLmluc2VydENvbW1lbnRPbmNlKShwcm9wUGFzc2VkQXNBcmcsIGosIGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCB8fD0gaW5zZXJ0ZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmeVR5cGVzKGN1cnJlbnRQYXJhbS50eXBlQW5ub3RhdGlvbiwgcHJvcHNJZGVudGlmaWVyLCByb290LCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRQcm9wQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc01vZGlmaWVkID0gcmVzb2x2ZUFzeW5jUHJvcChwYXRoLCBwcm9wZXJ0aWVzTWFwLCBwcm9wc0lkZW50aWZpZXIubmFtZSwgYWxsUHJvcGVydGllcywgaXNEZWZhdWx0RXhwb3J0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIFRTIGhhcHB5XG4gICAgICAgICAgICAgICAgICAgIGlmIChqLk9iamVjdFBhdHRlcm4uY2hlY2soY3VycmVudFBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5VHlwZXMoY3VycmVudFBhcmFtLnR5cGVBbm5vdGF0aW9uLCBwcm9wc0lkZW50aWZpZXIsIHJvb3QsIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBmaXJzdCBwYXJhbSB0byBgcHJvcHNgXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1twcm9wc0FyZ3VtZW50SW5kZXhdID0gcHJvcHNJZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcHJvcCBhcmd1bWVudCBpcyBub3QgZGVzdHJ1Y3R1cmVkLCB3ZSBuZWVkIHRvIGFkZCBjb21tZW50cyB0byB0aGUgc3ByZWFkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBpZiAoai5JZGVudGlmaWVyLmNoZWNrKGN1cnJlbnRQYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudGVkID0gY29tbWVudFNwcmVhZFByb3BzKHBhdGgsIGN1cnJlbnRQYXJhbS5uYW1lLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRUeXBlcyA9IG1vZGlmeVR5cGVzKGN1cnJlbnRQYXJhbS50eXBlQW5ub3RhdGlvbiwgcHJvcHNJZGVudGlmaWVyLCByb290LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgfHw9IGNvbW1lbnRlZCB8fCBtb2RpZmllZFR5cGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaW5zZXJ0IGBjb25zdCBwYXJhbXMgPSBhd2FpdCBhc3luY1BhcmFtcztgIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZ1bmN0aW9uIGJvZHlcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jUHJvcChwYXRoLCBwcm9wZXJ0aWVzTWFwLCBwcm9wc0lkZW50aWZpZXJOYW1lLCBhbGxQcm9wZXJ0aWVzLCBpc0RlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgIC8vIFJlbmFtZSBwcm9wcyB0byBgcHJvcGAgYXJndW1lbnQgZm9yIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0ZWRSZW5hbWVkUHJvcEZ1bmN0aW9uTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcGF0aC52YWx1ZTtcbiAgICAgICAgICAgIC8vIElmIGl0J3Mgc3luYyBkZWZhdWx0IGV4cG9ydCwgYW5kIGl0J3MgYWxzbyBzZXJ2ZXIgY29tcG9uZW50LCBtYWtlIHRoZSBmdW5jdGlvbiBhc3luY1xuICAgICAgICAgICAgaWYgKGlzRGVmYXVsdEV4cG9ydCAmJiAhaXNDbGllbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNSZWFjdEhvb2tzVXNhZ2UgPSAoMCwgdXRpbHNfMS5jb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnMpKHBhdGguZ2V0KCdib2R5JyksIGopO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmFzeW5jID09PSBmYWxzZSAmJiAhaGFzUmVhY3RIb29rc1VzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS50dXJuRnVuY3Rpb25SZXR1cm5UeXBlVG9Bc3luYykobm9kZSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBhcnJvdyBmdW5jdGlvbiBhbmQgZnVuY3Rpb24gYm9keSBpcyBub3QgYmxvY2sgc3RhdGVtZW50LCBjaGVjayBpZiB0aGUgcHJvcGVydGllcyBhcmUgdXNlZCB0aGVyZVxuICAgICAgICAgICAgaWYgKGouQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24uY2hlY2socGF0aC5ub2RlKSAmJlxuICAgICAgICAgICAgICAgICFqLkJsb2NrU3RhdGVtZW50LmNoZWNrKHBhdGgubm9kZS5ib2R5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdEV4cHJlc3Npb24gPSBwYXRoLm5vZGUuYm9keTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzVXNlZFByb3BzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaihvYmplY3RFeHByZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICAuZmluZChqLklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChpZGVudGlmaWVyUGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZE5hbWUgPSBpZGVudGlmaWVyUGF0aC52YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc01hcC5oYXMoaWROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVXNlZFByb3BzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFR1cm4gdGhlIGZ1bmN0aW9uIGJvZHkgdG8gYmxvY2sgc3RhdGVtZW50LCByZXR1cm4gdGhlIG9iamVjdCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VzZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLm5vZGUuYm9keSA9IGouYmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgai5yZXR1cm5TdGF0ZW1lbnQob2JqZWN0RXhwcmVzc2lvbiksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzQXN5bmNGdW5jID0gISFub2RlLmFzeW5jO1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gcGF0aC52YWx1ZS5pZD8ubmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSAoMCwgdXRpbHNfMS5maW5kRnVuY3Rpb25Cb2R5KShwYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQm9keVBhdGggPSBwYXRoLmdldCgnYm9keScpO1xuICAgICAgICAgICAgY29uc3QgaGFzUmVhY3RIb29rc1VzYWdlID0gKDAsIHV0aWxzXzEuY29udGFpbnNSZWFjdEhvb2tzQ2FsbEV4cHJlc3Npb25zKShmdW5jdGlvbkJvZHlQYXRoLCBqKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc090aGVyUHJvcGVydGllcyA9IGFsbFByb3BlcnRpZXMubGVuZ3RoID4gcHJvcGVydGllc01hcC5zaXplO1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGVzdHJ1Y3R1cmluZ0RlY2xhcmF0aW9uKHByb3BlcnRpZXMsIGRlc3RydWN0UHJvcHNJZGVudGlmaWVyTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9LZWVwID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHJlc3RQcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkZXN0cnVjdHVyZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGouT2JqZWN0UHJvcGVydHkuY2hlY2socHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbm9ybWFsIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlOYW1lID0gai5JZGVudGlmaWVyLmNoZWNrKHByb3BlcnR5LmtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBqLkxpdGVyYWwuY2hlY2socHJvcGVydHkua2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BlcnR5LmtleS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7IC8vIGZvciBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNUb0tlZXAucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoai5SZXN0RWxlbWVudC5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RQcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzVG9LZWVwLmxlbmd0aCA9PT0gMCAmJiAhcmVzdFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzVG9LZWVwLnB1c2gocmVzdFByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGoudmFyaWFibGVEZWNsYXJhdGlvbignY29uc3QnLCBbXG4gICAgICAgICAgICAgICAgICAgIGoudmFyaWFibGVEZWNsYXJhdG9yKGoub2JqZWN0UGF0dGVybihwcm9wc1RvS2VlcCksIGouaWRlbnRpZmllcihkZXN0cnVjdFByb3BzSWRlbnRpZmllck5hbWUpKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNPdGhlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVyZSBhcmUgb3RoZXIgcHJvcGVydGllcywgd2UgbmVlZCB0byBrZWVwIHRoZSBvcmlnaW5hbCBwYXJhbSB3aXRoIGRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgKiBlLmcuXG4gICAgICAgICAgICAgICAgICogaW5wdXQ6XG4gICAgICAgICAgICAgICAgICogUGFnZSh7IHBhcmFtczogeyBzbHVnIH0sIG90aGVyUHJvcCB9KSB7XG4gICAgICAgICAgICAgICAgICogICBjb25zdCB7IHNsdWcgfSA9IGF3YWl0IHByb3BzLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBvdXRwdXQ6XG4gICAgICAgICAgICAgICAgICogUGFnZShwcm9wcykge1xuICAgICAgICAgICAgICAgICAqICAgY29uc3QgeyBvdGhlclByb3AgfSA9IHByb3BzOyAvLyBpbnNlcnRlZFxuICAgICAgICAgICAgICAgICAqICAgLy8gLi4ucmVzdCBvZiB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCByZXN0UHJvcGVydGllcyA9IGFsbFByb3BlcnRpZXMuZmlsdGVyKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVGFyZ2V0UHJvcHMgPSAna2V5JyBpbiBwcm9wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmtleS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuVEFSR0VUX1BST1BfTkFNRVMuaGFzKHByb3Aua2V5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzVGFyZ2V0UHJvcHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdHJ1Y3Rpb25PdGhlclByb3BlcnRpZXNEZWNsYXJhdGlvbiA9IGNyZWF0ZURlc3RydWN0dXJpbmdEZWNsYXJhdGlvbihyZXN0UHJvcGVydGllcywgcHJvcHNJZGVudGlmaWVyTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQm9keSAmJiBkZXN0cnVjdGlvbk90aGVyUHJvcGVydGllc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQm9keS51bnNoaWZ0KGRlc3RydWN0aW9uT3RoZXJQcm9wZXJ0aWVzRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb2RpZmllZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbWF0Y2hlZFByb3BOYW1lLCBwYXJhbXNQcm9wZXJ0eV0gb2YgcHJvcGVydGllc01hcCkge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbHNfMS5UQVJHRVRfUFJPUF9OQU1FUy5oYXMobWF0Y2hlZFByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gY2xpZW50IGNvbXBvbmVudCwgaWYgdGhlIHBhcmFtIGlzIGFscmVhZHkgd3JhcHBlZCB3aXRoIGB1c2UoKWAsIHNraXAgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xpZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRTa2lwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BQYXRocyA9IGoocGF0aCkuZmluZChqLklkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdGNoZWRQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcFBhdGggb2YgcHJvcFBhdGhzLnBhdGhzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uKShwcm9wUGF0aCwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1Byb3BlcnR5TmFtZSA9IGouSWRlbnRpZmllci5jaGVjayhwYXJhbXNQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXNQcm9wZXJ0eS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbVByb3BlcnR5TmFtZSA9IHBhcmFtc1Byb3BlcnR5TmFtZSB8fCBtYXRjaGVkUHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvcE5hbWUgaXMgYW4gaWRlbnRpZmllciBhbmQgbm90IHVzZWQgaW4gbG93ZXIgc2NvcGUsXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBza2lwIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNVc2VkSW5Cb2R5ID0gaihmdW5jdGlvbkJvZHlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAuZmluZChqLklkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1Qcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNpemUoKSA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNVc2VkSW5Cb2R5ICYmIGouSWRlbnRpZmllci5jaGVjayhwYXJhbXNQcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgdXNhZ2Ugb2YgcHJvcE5hbWUgaW4gdGhlIGZ1bmN0aW9uIGJvZHksXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSdyZSBhbGwgYXdhaXRlZCBvciB3cmFwcGVkIHdpdGggdXNlKCksIHNraXAgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFVzYWdlcyA9IGooZnVuY3Rpb25Cb2R5UGF0aCkuZmluZChqLklkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1Qcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyB1c2FnZSBvZiB0aGUgcHJvcE5hbWUsIHRoZW4gZG8gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgaWYgKHByb3BVc2FnZXMuc2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNNaXNzaW5nQXdhaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wVXNhZ2VzLmZvckVhY2goKHByb3BVc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBpcyBub3QgQXdhaXRFeHByZXNzaW9uLCBpdCdzIG5vdCBhd2FpdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0F3YWl0ZWQgPSBwcm9wVXNhZ2UucGFyZW50UGF0aD8udmFsdWUudHlwZSA9PT0gJ0F3YWl0RXhwcmVzc2lvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0F3YWl0ZWRCeVVzZSA9ICgwLCB1dGlsc18xLmlzUGFyZW50VXNlQ2FsbEV4cHJlc3Npb24pKHByb3BVc2FnZSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXdhaXRlZCAmJiAhaXNBd2FpdGVkQnlVc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNzaW5nQXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWxsIHRoZSB1c2FnZXMgb2YgcGFybSBhcmUgYXdhaXRlZCwgc2tpcCB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNNaXNzaW5nQXdhaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRQcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWVJZGVudGlmaWVyID0gai5pZGVudGlmaWVyKG1hdGNoZWRQcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNJZGVudGlmaWVyID0gai5pZGVudGlmaWVyKHByb3BzSWRlbnRpZmllck5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc2VkUHJvcElkRXhwciA9IGoubWVtYmVyRXhwcmVzc2lvbihwcm9wc0lkZW50aWZpZXIsIHByb3BOYW1lSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyYW0gcHJvcGVydHkgdmFsdWUsIGlmIGl0J3MgZGVzdHJ1Y3RlZCwgd2UgbmVlZCB0byBkZXN0cnVjdCBpdCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgICAgIC8vIGlucHV0OiBQYWdlKHsgcGFyYW1zOiB7IHNsdWcgfSB9KVxuICAgICAgICAgICAgICAgIC8vIG91dHB1dDogY29uc3QgeyBzbHVnIH0gPSBhd2FpdCBwcm9wcy5wYXJhbXM7IHJhdGhlciB0aGFuIGNvbnN0IHByb3BzID0gYXdhaXQgcHJvcHMucGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpZCA9IGZ1bmN0aW9uTmFtZSArICc6JyArIHBhcmFtUHJvcGVydHlOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNQcm9wZXJ0eT8udHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFBhdHRlcm4gPSBwYXJhbXNQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0UGF0dGVyblByb3BlcnRpZXMgPSBvYmplY3RQYXR0ZXJuLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc3RydWN0IHRoZSBvYmplY3QgcGF0dGVybiwgZS5nLiB7IHNsdWcgfSA9PiBjb25zdCB7IHNsdWcgfSA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdHJ1Y3RlZE9iamVjdFBhdHRlcm4gPSBqLnZhcmlhYmxlRGVjbGFyYXRpb24oJ2NvbnN0JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgai52YXJpYWJsZURlY2xhcmF0b3Ioai5vYmplY3RQYXR0ZXJuKG9iamVjdFBhdHRlcm5Qcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdQcm9wZXJ0eScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC5rZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqLm9iamVjdFByb3BlcnR5KGouaWRlbnRpZmllcihwcm9wLmtleS5uYW1lKSwgai5pZGVudGlmaWVyKHByb3Aua2V5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIHByb3BOYW1lSWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2VydGVkRGVzdHJ1Y3RQcm9wTmFtZXMuaGFzKHVpZCkgJiYgZnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkJvZHkudW5zaGlmdChkZXN0cnVjdGVkT2JqZWN0UGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZERlc3RydWN0UHJvcE5hbWVzLmFkZCh1aWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jRnVuYykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFzeW5jIGZ1bmN0aW9uLCBhZGQgYXdhaXQgdG8gdGhlIGFzeW5jIHByb3BzLjxwcm9wTmFtZT5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1Bc3NpZ25tZW50ID0gai52YXJpYWJsZURlY2xhcmF0aW9uKCdjb25zdCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGoudmFyaWFibGVEZWNsYXJhdG9yKGouaWRlbnRpZmllcihwYXJhbVByb3BlcnR5TmFtZSksIGouYXdhaXRFeHByZXNzaW9uKGFjY2Vzc2VkUHJvcElkRXhwcikpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNlcnRlZFJlbmFtZWRQcm9wRnVuY3Rpb25OYW1lcy5oYXModWlkKSAmJiBmdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQm9keS51bnNoaWZ0KHBhcmFtQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZFJlbmFtZWRQcm9wRnVuY3Rpb25OYW1lcy5hZGQodWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NsaWVudENvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuaXNGdW5jdGlvblR5cGUpKG5vZGUudHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFoYXNSZWFjdEhvb2tzVXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgZXhwb3J0IGZ1bmN0aW9uLCBwb3B1bGF0ZSB0aGUgZnVuY3Rpb24gdG8gYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudHVybkZ1bmN0aW9uUmV0dXJuVHlwZVRvQXN5bmMpKG5vZGUsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGBjb25zdCA8cHJvcE5hbWU+ID0gYXdhaXQgcHJvcHMuPHByb3BOYW1lPjtgIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZ1bmN0aW9uIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtQXNzaWdubWVudCA9IGoudmFyaWFibGVEZWNsYXJhdGlvbignY29uc3QnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai52YXJpYWJsZURlY2xhcmF0b3Ioai5pZGVudGlmaWVyKHBhcmFtUHJvcGVydHlOYW1lKSwgai5hd2FpdEV4cHJlc3Npb24oYWNjZXNzZWRQcm9wSWRFeHByKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5zZXJ0ZWRSZW5hbWVkUHJvcEZ1bmN0aW9uTmFtZXMuaGFzKHVpZCkgJiYgZnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Cb2R5LnVuc2hpZnQocGFyYW1Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZFJlbmFtZWRQcm9wRnVuY3Rpb25OYW1lcy5hZGQodWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtQXNzaWdubWVudCA9IGoudmFyaWFibGVEZWNsYXJhdGlvbignY29uc3QnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai52YXJpYWJsZURlY2xhcmF0b3Ioai5pZGVudGlmaWVyKHBhcmFtUHJvcGVydHlOYW1lKSwgai5jYWxsRXhwcmVzc2lvbihqLmlkZW50aWZpZXIoJ3VzZScpLCBbYWNjZXNzZWRQcm9wSWRFeHByXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2VydGVkUmVuYW1lZFByb3BGdW5jdGlvbk5hbWVzLmhhcyh1aWQpICYmIGZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVhY3RVc2VJbXBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQm9keS51bnNoaWZ0KHBhcmFtQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRSZW5hbWVkUHJvcEZ1bmN0aW9uTmFtZXMuYWRkKHVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZWRQcm9wZXJ0eUNvdW50ID4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0RXhwb3J0c0RlY2xhcmF0aW9ucyA9IHJvb3QuZmluZChqLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbik7XG4gICAgICAgIGRlZmF1bHRFeHBvcnRzRGVjbGFyYXRpb25zLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGF0aCA9ICgwLCB1dGlsc18xLmdldEZ1bmN0aW9uUGF0aEZyb21FeHBvcnRQYXRoKShwYXRoLCBqLCByb290LCAoKSA9PiB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvblBhdGgpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVBc3luY1Byb3BJZkV4aXN0ZWQoZnVuY3Rpb25QYXRoLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1hdGNoaW5nIE5leHQuanMgZnVuY3Rpb25hbCBuYW1lZCBleHBvcnQgb2Ygcm91dGUgZW50cnk6XG4gICAgICAgIC8vIC0gZXhwb3J0IGZ1bmN0aW9uIDxuYW1lZD4oLi4uKSB7IC4uLiB9XG4gICAgICAgIC8vIC0gZXhwb3J0IGNvbnN0IDxuYW1lZD4gPSAuLi5cbiAgICAgICAgY29uc3QgbmFtZWRFeHBvcnREZWNsYXJhdGlvbnMgPSByb290LmZpbmQoai5FeHBvcnROYW1lZERlY2xhcmF0aW9uKTtcbiAgICAgICAgbmFtZWRFeHBvcnREZWNsYXJhdGlvbnMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25QYXRoID0gKDAsIHV0aWxzXzEuZ2V0RnVuY3Rpb25QYXRoRnJvbUV4cG9ydFBhdGgpKHBhdGgsIGosIHJvb3QsIChpZE5hbWUpID0+IHV0aWxzXzEuVEFSR0VUX05BTUVEX0VYUE9SVFMuaGFzKGlkTmFtZSkpO1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uUGF0aCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZUFzeW5jUHJvcElmRXhpc3RlZChmdW5jdGlvblBhdGgsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzQ2xpZW50Q29tcG9uZW50ID0gKDAsIHV0aWxzXzEuZGV0ZXJtaW5lQ2xpZW50RGlyZWN0aXZlKShyb290LCBqKTtcbiAgICAvLyBBcHBseSB0byBgcGFyYW1zYCBhbmQgYHNlYXJjaFBhcmFtc2BcbiAgICBwcm9jZXNzQXN5bmNQcm9wT2ZFbnRyeUZpbGUoaXNDbGllbnRDb21wb25lbnQpO1xuICAgIC8vIEFkZCBpbXBvcnQgeyB1c2UgfSBmcm9tICdyZWFjdCcgaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBpbXBvcnRlZFxuICAgIGlmIChuZWVkc1JlYWN0VXNlSW1wb3J0KSB7XG4gICAgICAgICgwLCB1dGlsc18xLmluc2VydFJlYWN0VXNlSW1wb3J0KShyb290LCBqKTtcbiAgICB9XG4gICAgY29uc3QgY29tbWVudGVkID0gY29tbWVudE9uTWF0Y2hlZFJlRXhwb3J0cyhyb290LCBqKTtcbiAgICBtb2RpZmllZCB8fD0gY29tbWVudGVkO1xuICAgIHJldHVybiBtb2RpZmllZCA/IHJvb3QudG9Tb3VyY2UoKSA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQWxsVHlwZXMocm9vdCwgaiwgdHlwZU5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgICAgaW50ZXJmYWNlczogW10sXG4gICAgICAgIHR5cGVBbGlhc2VzOiBbXSxcbiAgICAgICAgaW1wb3J0czogW10sXG4gICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgIH07XG4gICAgLy8gU3RlcCAxOiBGaW5kIGFsbCBpbnRlcmZhY2UgZGVjbGFyYXRpb25zIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgcm9vdFxuICAgICAgICAuZmluZChqLlRTSW50ZXJmYWNlRGVjbGFyYXRpb24sIHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgIG5hbWU6IHR5cGVOYW1lLFxuICAgICAgICB9LFxuICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIHR5cGVzLmludGVyZmFjZXMucHVzaChwYXRoLm5vZGUpO1xuICAgIH0pO1xuICAgIC8vIFN0ZXAgMjogRmluZCBhbGwgdHlwZSBhbGlhcyBkZWNsYXJhdGlvbnMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICByb290XG4gICAgICAgIC5maW5kKGouVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiwge1xuICAgICAgICBpZDoge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgbmFtZTogdHlwZU5hbWUsXG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAgICAgLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgdHlwZXMudHlwZUFsaWFzZXMucHVzaChwYXRoLm5vZGUpO1xuICAgIH0pO1xuICAgIC8vIFN0ZXAgMzogRmluZCBhbGwgaW1wb3J0ZWQgdHlwZXMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICByb290XG4gICAgICAgIC5maW5kKGouSW1wb3J0U3BlY2lmaWVyLCB7XG4gICAgICAgIGltcG9ydGVkOiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiB0eXBlTmFtZSxcbiAgICAgICAgfSxcbiAgICB9KVxuICAgICAgICAuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICB0eXBlcy5pbXBvcnRzLnB1c2gocGF0aC5ub2RlKTtcbiAgICB9KTtcbiAgICAvLyBTdGVwIDQ6IEZpbmQgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHNwZWNpZmllZCB0eXBlXG4gICAgcm9vdFxuICAgICAgICAuZmluZChqLlRTVHlwZVJlZmVyZW5jZSwge1xuICAgICAgICB0eXBlTmFtZToge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgbmFtZTogdHlwZU5hbWUsXG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAgICAgLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgdHlwZXMucmVmZXJlbmNlcy5wdXNoKHBhdGgubm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZnVuY3Rpb24gY29tbWVudFNwcmVhZFByb3BzKHBhdGgsIHByb3BzSWRlbnRpZmllck5hbWUsIGopIHtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSAoMCwgdXRpbHNfMS5maW5kRnVuY3Rpb25Cb2R5KShwYXRoKTtcbiAgICBjb25zdCBmdW5jdGlvbkJvZHlDb2xsZWN0aW9uID0gaihmdW5jdGlvbkJvZHkpO1xuICAgIC8vIEZpbmQgYWxsIHRoZSB1c2FnZSBvZiBzcHJlYWRpbmcgcHJvcGVydGllcyBvZiBgcHJvcHNgXG4gICAgY29uc3QganN4U3ByZWFkUHJvcGVydGllcyA9IGZ1bmN0aW9uQm9keUNvbGxlY3Rpb24uZmluZChqLkpTWFNwcmVhZEF0dHJpYnV0ZSwgeyBhcmd1bWVudDogeyBuYW1lOiBwcm9wc0lkZW50aWZpZXJOYW1lIH0gfSk7XG4gICAgY29uc3Qgb2JqU3ByZWFkUHJvcGVydGllcyA9IGZ1bmN0aW9uQm9keUNvbGxlY3Rpb24uZmluZChqLlNwcmVhZEVsZW1lbnQsIHtcbiAgICAgICAgYXJndW1lbnQ6IHsgbmFtZTogcHJvcHNJZGVudGlmaWVyTmFtZSB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGNvbW1lbnQgPSBgICR7dXRpbHNfMS5ORVhUX0NPREVNT0RfRVJST1JfUFJFRklYfSAnJHtwcm9wc0lkZW50aWZpZXJOYW1lfScgaXMgdXNlZCB3aXRoIHNwcmVhZCBzeW50YXggKC4uLikuIEFueSBhc3luY2hyb25vdXMgcHJvcGVydGllcyBvZiAnJHtwcm9wc0lkZW50aWZpZXJOYW1lfScgbXVzdCBiZSBhd2FpdGVkIHdoZW4gYWNjZXNzZWQuIGA7XG4gICAgLy8gQWRkIGNvbW1lbnQgYmVmb3JlIGl0XG4gICAganN4U3ByZWFkUHJvcGVydGllcy5mb3JFYWNoKChzcHJlYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSAoMCwgdXRpbHNfMS5pbnNlcnRDb21tZW50T25jZSkoc3ByZWFkLnZhbHVlLCBqLCBjb21tZW50KTtcbiAgICAgICAgaWYgKGluc2VydGVkKVxuICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIG9ialNwcmVhZFByb3BlcnRpZXMuZm9yRWFjaCgoc3ByZWFkKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkID0gKDAsIHV0aWxzXzEuaW5zZXJ0Q29tbWVudE9uY2UpKHNwcmVhZC52YWx1ZSwgaiwgY29tbWVudCk7XG4gICAgICAgIGlmIChpbnNlcnRlZClcbiAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kaWZpZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXh0LWFzeW5jLWR5bmFtaWMtcHJvcC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBQ1pBLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0VBQUVDLEtBQUssRUFBRTtBQUFLLENBQUMsQ0FBQztBQUM3REQsT0FBTyxDQUFDRSxxQkFBcUIsR0FBR0EscUJBQXFCO0FBQ3JELE1BQU1DLE9BQU8sR0FBR0MsT0FBTyxDQUFDLFNBQVMsQ0FBQztBQUNsQyxNQUFNQyxRQUFRLEdBQUdELE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQztBQUMvQyxNQUFNRSxVQUFVLEdBQUcsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTQyx1QkFBdUJBLENBQUNDLFVBQVUsRUFBRUMsSUFBSSxFQUFFQyxDQUFDLEVBQUU7RUFDbEQ7RUFDQSxN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","map":{"version":3,"names":["Object","defineProperty","exports","value","transformDynamicProps","utils_1","require","parser_1","PAGE_PROPS","awaitMemberAccessOfProp","propIdName","path","j","functionBody","findFunctionBody","memberAccess","find","MemberExpression","object","type","name","hasAwaited","forEach","memberAccessPath","_memberAccessPath$par","_parentScopeOfMemberA","member","memberProperty","property","isAccessingMatchedProperty","Identifier","check","TARGET_PROP_NAMES","has","isParentPromiseAllCallExpression","parentPath","parentScopeOfMemberAccess","findClosetParentFunctionScope","async","node","comment","NEXT_CODEMOD_ERROR_PREFIX","insertCommentOnce","awaitedExpr","awaitExpression","awaitMemberAccess","wrapParentheseIfNeeded","replace","hasReactHooksUsage","containsReactHooksCallExpressions","get","turnFunctionReturnTypeToAsync","applyUseAndRenameAccessedProp","modified","accessedNames","isParentUseCallExpression","push","currentMember","length","accessedPropId","identifier","accessedProp","memberExpression","useCall","callExpression","useDeclaration","variableDeclaration","variableDeclarator","unshift","commentOnMatchedReExports","root","ExportNamedDeclaration","ExportSpecifier","specifiers","specifier","TARGET_NAMED_EXPORTS","exported","Literal","source","localName","local","commentInserted","localIdentifier","importDeclaration","ImportDeclaration","filter","importPath","some","importSpecifier","size","modifyTypes","paramTypeAnnotation","propsIdentifier","typeAnnotation","typeLiteral","members","key","typeName","TSType","tsTypeReference","tsTypeParameterInstantiation","typeReference","foundTypes","findAllTypes","interfaces","_interfaceDeclaration","interfaceDeclaration","body","typeBody","_member$typeAnnotatio","typeAliases","typeAliasDeclaration","TSTypeAliasDeclaration","typeAlias","TSTypeLiteral","TSPropertySignature","imports","_typeReference$typePa","propType","typeParameters","params","_api","filePath","isEntryFile","NEXTJS_ENTRY_FILES","test","modifiedPropArgument","createParserFromPath","needsReactUseImport","insertedDestructPropNames","Set","processAsyncPropOfEntryFile","isClientComponent","renameAsyncPropIfExisted","isDefaultExport","_decl$id","decl","functionName","id","_ref","getVariableDeclaratorId","propertiesMap","Map","allProperties","isRoute","TARGET_ROUTE_EXPORTS","generateUniqueIdentifier","propsArgumentIndex","currentParam","foundTargetProp","prop","properties","propName","Property","ObjectProperty","set","argName","modifiedProp","awaited","callExpressions","CallExpression","arguments","args","arg","propPassedAsArg","inserted","isModified","resolveAsyncProp","ObjectPattern","commented","commentSpreadProps","modifiedTypes","propsIdentifierName","_path$value$id","insertedRenamedPropFunctionNames","ArrowFunctionExpression","BlockStatement","objectExpression","hasUsedProps","identifierPath","idName","blockStatement","returnStatement","isAsyncFunc","functionBodyPath","hasOtherProperties","createDestructuringDeclaration","destructPropsIdentifierName","propsToKeep","restProperty","keyName","RestElement","objectPattern","restProperties","isTargetProps","destructionOtherPropertiesDeclaration","modifiedPropertyCount","matchedPropName","paramsProperty","shouldSkip","propPaths","propPath","paths","paramsPropertyName","paramPropertyName","hasUsedInBody","propUsages","hasMissingAwaited","propUsage","_propUsage$parentPath","isAwaited","isAwaitedByUse","propNameIdentifier","accessedPropIdExpr","uid","objectPatternProperties","destructedObjectPattern","map","objectProperty","add","paramAssignment","isFunctionType","defaultExportsDeclarations","ExportDefaultDeclaration","functionPath","getFunctionPathFromExportPath","namedExportDeclarations","determineClientDirective","insertReactUseImport","toSource","types","references","TSInterfaceDeclaration","ImportSpecifier","imported","TSTypeReference","functionBodyCollection","jsxSpreadProperties","JSXSpreadAttribute","argument","objSpreadProperties","SpreadElement","spread"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/","sources":["next-async-dynamic-prop.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transformDynamicProps = transformDynamicProps;\nconst utils_1 = require(\"./utils\");\nconst parser_1 = require(\"../../../lib/parser\");\nconst PAGE_PROPS = 'props';\n// Find all the member access of the prop, and await them\n// e.g. If there's argument `props`, find all the member access of props.<name>.\n// If the member access can be awaited, await them.\nfunction awaitMemberAccessOfProp(propIdName, path, j) {\n    // search the member access of the prop\n    const functionBody = (0, utils_1.findFunctionBody)(path);\n    const memberAccess = j(functionBody).find(j.MemberExpression, {\n        object: {\n            type: 'Identifier',\n            name: propIdName,\n        },\n    });\n    let hasAwaited = false;\n    // await each member access\n    memberAccess.forEach((memberAccessPath) => {\n        const member = memberAccessPath.value;\n        const memberProperty = member.property;\n        const isAccessingMatchedProperty = j.Identifier.check(memberProperty) &&\n            utils_1.TARGET_PROP_NAMES.has(memberProperty.name);\n        if (!isAccessingMatchedProperty) {\n            return;\n        }\n        if ((0, utils_1.isParentPromiseAllCallExpression)(memberAccessPath, j)) {\n            return;\n        }\n        // check if it's already awaited\n        if (memberAccessPath.parentPath?.value.type === 'AwaitExpression') {\n            return;\n        }\n        const parentScopeOfMemberAccess = (0, utils_1.findClosetParentFunctionScope)(memberAccessPath, j);\n        // When the parent scope is sync, and it's also not the function itself, which means it's not able to convert to async.\n        if (parentScopeOfMemberAccess &&\n            !parentScopeOfMemberAccess.value?.async &&\n            parentScopeOfMemberAccess.node !== path.node) {\n            // If it's not able to convert, add a comment to the prop access to warn the user\n            // e.g. the parent scope is sync, await keyword can't be applied\n            const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${propIdName}.${memberProperty.name}' is accessed without awaiting.`;\n            (0, utils_1.insertCommentOnce)(member, j, comment);\n            return;\n        }\n        const awaitedExpr = j.awaitExpression(member);\n        const awaitMemberAccess = (0, utils_1.wrapParentheseIfNeeded)(true, j, awaitedExpr);\n        memberAccessPath.replace(awaitMemberAccess);\n        hasAwaited = true;\n    });\n    const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(path.get('body'), j);\n    // If there's any awaited member access, we need to make the function async\n    if (hasAwaited) {\n        if (path.value.async === false && !hasReactHooksUsage) {\n            path.value.async = true;\n            (0, utils_1.turnFunctionReturnTypeToAsync)(path.value, j);\n        }\n    }\n    return hasAwaited;\n}\nfunction applyUseAndRenameAccessedProp(propIdName, path, j) {\n    // search the member access of the prop, and rename the member access to the member value\n    // e.g.\n    // props.params => params\n    // props.params.foo => params.foo\n    // props.searchParams.search => searchParams.search\n    let modified = false;\n    const functionBody = (0, utils_1.findFunctionBody)(path);\n    const memberAccess = j(functionBody).find(j.MemberExpression, {\n        object: {\n            type: 'Identifier',\n            name: propIdName,\n        },\n    });\n    const accessedNames = [];\n    // rename each member access\n    memberAccess.forEach((memberAccessPath) => {\n        // If the member access expression is first argument of `use()`, we skip\n        if ((0, utils_1.isParentUseCallExpression)(memberAccessPath, j)) {\n            return;\n        }\n        const member = memberAccessPath.value;\n        const memberProperty = member.property;\n        if (j.Identifier.check(memberProperty)) {\n            accessedNames.push(memberProperty.name);\n        }\n        else if (j.MemberExpression.check(memberProperty)) {\n            let currentMember = memberProperty;\n            if (j.Identifier.check(currentMember.object)) {\n                accessedNames.push(currentMember.object.name);\n            }\n        }\n        memberAccessPath.replace(memberProperty);\n    });\n    // If there's any renamed member access, need to call `use()` onto member access\n    // e.g. ['params'] => insert `const params = use(props.params)`\n    if (accessedNames.length > 0) {\n        const accessedPropId = j.identifier(propIdName);\n        const accessedProp = j.memberExpression(accessedPropId, j.identifier(accessedNames[0]));\n        const useCall = j.callExpression(j.identifier('use'), [accessedProp]);\n        const useDeclaration = j.variableDeclaration('const', [\n            j.variableDeclarator(j.identifier(accessedNames[0]), useCall),\n        ]);\n        if (functionBody) {\n            functionBody.unshift(useDeclaration);\n        }\n        modified = true;\n    }\n    return modified;\n}\nfunction commentOnMatchedReExports(root, j) {\n    let modified = false;\n    root.find(j.ExportNamedDeclaration).forEach((path) => {\n        if (j.ExportSpecifier.check(path.value.specifiers[0])) {\n            const specifiers = path.value.specifiers;\n            for (const specifier of specifiers) {\n                if (j.ExportSpecifier.check(specifier) &&\n                    // Find matched named exports and default export\n                    (utils_1.TARGET_NAMED_EXPORTS.has(specifier.exported.name) ||\n                        specifier.exported.name === 'default')) {\n                    if (j.Literal.check(path.value.source)) {\n                        const localName = specifier.local.name;\n                        const commentInserted = (0, utils_1.insertCommentOnce)(specifier, j, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} \\`${localName}\\` export is re-exported. Check if this component uses \\`params\\` or \\`searchParams\\``);\n                        modified ||= commentInserted;\n                    }\n                    else if (path.value.source === null) {\n                        const localIdentifier = specifier.local;\n                        const localName = localIdentifier.name;\n                        // search if local identifier is from imports\n                        const importDeclaration = root\n                            .find(j.ImportDeclaration)\n                            .filter((importPath) => {\n                            return importPath.value.specifiers.some((importSpecifier) => importSpecifier.local.name === localName);\n                        });\n                        if (importDeclaration.size() > 0) {\n                            const commentInserted = (0, utils_1.insertCommentOnce)(specifier, j, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} \\`${localName}\\` export is re-exported. Check if this component uses \\`params\\` or \\`searchParams\\``);\n                            modified ||= commentInserted;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    return modified;\n}\nfunction modifyTypes(paramTypeAnnotation, propsIdentifier, root, j) {\n    let modified = false;\n    if (paramTypeAnnotation && paramTypeAnnotation.typeAnnotation) {\n        const typeAnnotation = paramTypeAnnotation.typeAnnotation;\n        if (typeAnnotation.type === 'TSTypeLiteral') {\n            const typeLiteral = typeAnnotation;\n            // Find the type property for `params`\n            typeLiteral.members.forEach((member) => {\n                if (member.type === 'TSPropertySignature' &&\n                    member.key.type === 'Identifier' &&\n                    utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                    // if it's already a Promise, don't wrap it again, return\n                    if (member.typeAnnotation &&\n                        member.typeAnnotation.typeAnnotation &&\n                        member.typeAnnotation.typeAnnotation.type === 'TSTypeReference' &&\n                        member.typeAnnotation.typeAnnotation.typeName.type ===\n                            'Identifier' &&\n                        member.typeAnnotation.typeAnnotation.typeName.name === 'Promise') {\n                        return;\n                    }\n                    // Wrap the `params` type in Promise<>\n                    if (member.typeAnnotation &&\n                        member.typeAnnotation.typeAnnotation &&\n                        j.TSType.check(member.typeAnnotation.typeAnnotation)) {\n                        member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([\n                            member.typeAnnotation.typeAnnotation,\n                        ]));\n                        modified = true;\n                    }\n                }\n            });\n        }\n        else if (typeAnnotation.type === 'TSTypeReference') {\n            // If typeAnnotation is a type or interface, change the properties to Promise<type of property>\n            // e.g. interface PageProps { params: { slug: string } } => interface PageProps { params: Promise<{ slug: string }> }\n            const typeReference = typeAnnotation;\n            if (typeReference.typeName.type === 'Identifier') {\n                // Find the actual type of the type reference\n                const foundTypes = findAllTypes(root, j, typeReference.typeName.name);\n                // Deal with interfaces\n                if (foundTypes.interfaces.length > 0) {\n                    const interfaceDeclaration = foundTypes.interfaces[0];\n                    if (interfaceDeclaration.type === 'TSInterfaceDeclaration' &&\n                        interfaceDeclaration.body?.type === 'TSInterfaceBody') {\n                        const typeBody = interfaceDeclaration.body.body;\n                        // if it's already a Promise, don't wrap it again, return\n                        // traverse the typeReference's properties, if any is in propNames, wrap it in Promise<> if needed\n                        typeBody.forEach((member) => {\n                            if (member.type === 'TSPropertySignature' &&\n                                member.key.type === 'Identifier' &&\n                                utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                                // if it's already a Promise, don't wrap it again, return\n                                if (member.typeAnnotation &&\n                                    member.typeAnnotation.typeAnnotation &&\n                                    member.typeAnnotation?.typeAnnotation?.typeName?.name ===\n                                        'Promise') {\n                                    return;\n                                }\n                                // Wrap the prop type in Promise<>\n                                if (member.typeAnnotation &&\n                                    member.typeAnnotation.typeAnnotation &&\n                                    // check if member name is in propNames\n                                    utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                                    member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([\n                                        member.typeAnnotation.typeAnnotation,\n                                    ]));\n                                    modified = true;\n                                }\n                            }\n                        });\n                    }\n                }\n                // Deal with type aliases\n                if (foundTypes.typeAliases.length > 0) {\n                    const typeAliasDeclaration = foundTypes.typeAliases[0];\n                    if (j.TSTypeAliasDeclaration.check(typeAliasDeclaration)) {\n                        const typeAlias = typeAliasDeclaration.typeAnnotation;\n                        if (j.TSTypeLiteral.check(typeAlias) &&\n                            typeAlias.members.length > 0) {\n                            const typeLiteral = typeAlias;\n                            typeLiteral.members.forEach((member) => {\n                                if (j.TSPropertySignature.check(member) &&\n                                    j.Identifier.check(member.key) &&\n                                    utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                                    // if it's already a Promise, don't wrap it again, return\n                                    if (member.typeAnnotation &&\n                                        member.typeAnnotation.typeAnnotation &&\n                                        member.typeAnnotation.typeAnnotation.type ===\n                                            'TSTypeReference' &&\n                                        member.typeAnnotation.typeAnnotation.typeName.type ===\n                                            'Identifier' &&\n                                        member.typeAnnotation.typeAnnotation.typeName.name ===\n                                            'Promise') {\n                                        return;\n                                    }\n                                    // Wrap the prop type in Promise<>\n                                    if (member.typeAnnotation &&\n                                        j.TSTypeLiteral.check(member.typeAnnotation.typeAnnotation)) {\n                                        member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([\n                                            member.typeAnnotation.typeAnnotation,\n                                        ]));\n                                        modified = true;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n                if (foundTypes.imports.length > 0) {\n                    // console.log('typeReference.typeName.name', typeReference.typeName.name, foundTypes)\n                    // If it's React PropsWithChildren\n                    if (typeReference.typeName.name === 'PropsWithChildren') {\n                        const propType = typeReference.typeParameters?.params[0];\n                        if (propType &&\n                            j.TSTypeLiteral.check(propType) &&\n                            propType.members.length > 0) {\n                            const typeLiteral = propType;\n                            typeLiteral.members.forEach((member) => {\n                                if (j.TSPropertySignature.check(member) &&\n                                    j.Identifier.check(member.key) &&\n                                    utils_1.TARGET_PROP_NAMES.has(member.key.name)) {\n                                    // if it's already a Promise, don't wrap it again, return\n                                    if (member.typeAnnotation &&\n                                        member.typeAnnotation.typeAnnotation &&\n                                        member.typeAnnotation.typeAnnotation.type ===\n                                            'TSTypeReference' &&\n                                        member.typeAnnotation.typeAnnotation.typeName.type ===\n                                            'Identifier' &&\n                                        member.typeAnnotation.typeAnnotation.typeName.name ===\n                                            'Promise') {\n                                        return;\n                                    }\n                                    // Wrap the prop type in Promise<>\n                                    if (member.typeAnnotation &&\n                                        j.TSTypeLiteral.check(member.typeAnnotation.typeAnnotation)) {\n                                        member.typeAnnotation.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), j.tsTypeParameterInstantiation([\n                                            member.typeAnnotation.typeAnnotation,\n                                        ]));\n                                        modified = true;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        propsIdentifier.typeAnnotation = paramTypeAnnotation;\n        modified = true;\n    }\n    return modified;\n}\nfunction transformDynamicProps(source, _api, filePath) {\n    const isEntryFile = utils_1.NEXTJS_ENTRY_FILES.test(filePath);\n    if (!isEntryFile) {\n        return null;\n    }\n    let modified = false;\n    let modifiedPropArgument = false;\n    const j = (0, parser_1.createParserFromPath)(filePath);\n    const root = j(source);\n    // Check if 'use' from 'react' needs to be imported\n    let needsReactUseImport = false;\n    // Based on the prop names\n    // e.g. destruct `params` { slug } = params\n    // e.g. destruct `searchParams `{ search } = searchParams\n    let insertedDestructPropNames = new Set();\n    function processAsyncPropOfEntryFile(isClientComponent) {\n        // find `params` and `searchParams` in file, and transform the access to them\n        function renameAsyncPropIfExisted(path, isDefaultExport) {\n            const decl = path.value;\n            const params = decl.params;\n            let functionName = decl.id?.name;\n            // If it's const <id> = function () {}, locate the <id> to get function name\n            if (!decl.id) {\n                functionName = (0, utils_1.getVariableDeclaratorId)(path, j)?.name;\n            }\n            // target properties mapping, only contains `params` and `searchParams`\n            const propertiesMap = new Map();\n            let allProperties = [];\n            const isRoute = !isDefaultExport && utils_1.TARGET_ROUTE_EXPORTS.has(functionName);\n            // generateMetadata API has 2 params\n            if (functionName === 'generateMetadata') {\n                if (params.length > 2 || params.length === 0)\n                    return;\n            }\n            else if (isRoute) {\n                if (params.length !== 2)\n                    return;\n            }\n            else {\n                // Page/Layout default export have 1 param\n                if (params.length !== 1)\n                    return;\n            }\n            const propsIdentifier = (0, utils_1.generateUniqueIdentifier)(PAGE_PROPS, path, j);\n            const propsArgumentIndex = isRoute ? 1 : 0;\n            const currentParam = params[propsArgumentIndex];\n            if (!currentParam)\n                return;\n            // Argument destructuring case\n            if (currentParam.type === 'ObjectPattern') {\n                // Validate if the properties are not `params` and `searchParams`,\n                // if they are, quit the transformation\n                let foundTargetProp = false;\n                for (const prop of currentParam.properties) {\n                    if ('key' in prop && prop.key.type === 'Identifier') {\n                        const propName = prop.key.name;\n                        if (utils_1.TARGET_PROP_NAMES.has(propName)) {\n                            foundTargetProp = true;\n                        }\n                    }\n                }\n                // If there's no `params` or `searchParams` matched, return\n                if (!foundTargetProp)\n                    return;\n                allProperties = currentParam.properties;\n                currentParam.properties.forEach((prop) => {\n                    if (\n                    // Could be `Property` or `ObjectProperty`\n                    (j.Property.check(prop) || j.ObjectProperty.check(prop)) &&\n                        j.Identifier.check(prop.key) &&\n                        utils_1.TARGET_PROP_NAMES.has(prop.key.name)) {\n                        const value = 'value' in prop ? prop.value : null;\n                        propertiesMap.set(prop.key.name, value);\n                    }\n                });\n                modifiedPropArgument = true;\n            }\n            else if (currentParam.type === 'Identifier') {\n                // case of accessing the props.params.<name>:\n                // Page(props) {}\n                // generateMetadata(props, parent?) {}\n                const argName = currentParam.name;\n                if (isClientComponent) {\n                    const modifiedProp = applyUseAndRenameAccessedProp(argName, path, j);\n                    if (modifiedProp) {\n                        needsReactUseImport = true;\n                        modified = true;\n                    }\n                }\n                else {\n                    // If it's (props.params).<name>, await the member access\n                    // const pathOfCurrentParam = path.get('params', propsArgumentIndex)\n                    // const paramScope = findClosetParentFunctionScope(pathOfCurrentParam, j)\n                    const awaited = awaitMemberAccessOfProp(argName, path, j);\n                    modified ||= awaited;\n                }\n                modified ||= modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n                // cases of passing down `props` into any function\n                // Page(props) { callback(props) }\n                // search for all the argument of CallExpression, where currentParam is one of the arguments\n                const callExpressions = j(path).find(j.CallExpression, {\n                    arguments: (args) => {\n                        return args.some((arg) => {\n                            return (j.Identifier.check(arg) &&\n                                arg.name === argName &&\n                                arg.type === 'Identifier');\n                        });\n                    },\n                });\n                // Add a comment to warn users that properties of `props` need to be awaited when accessed\n                callExpressions.forEach((callExpression) => {\n                    // find the argument `currentParam`\n                    const args = callExpression.value.arguments;\n                    const propPassedAsArg = args.find((arg) => j.Identifier.check(arg) && arg.name === argName);\n                    const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${argName}' is passed as an argument. Any asynchronous properties of 'props' must be awaited when accessed. `;\n                    const inserted = (0, utils_1.insertCommentOnce)(propPassedAsArg, j, comment);\n                    modified ||= inserted;\n                });\n                if (modified) {\n                    modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n                }\n            }\n            if (modifiedPropArgument) {\n                const isModified = resolveAsyncProp(path, propertiesMap, propsIdentifier.name, allProperties, isDefaultExport);\n                if (isModified) {\n                    // Make TS happy\n                    if (j.ObjectPattern.check(currentParam)) {\n                        modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n                    }\n                    // Override the first param to `props`\n                    params[propsArgumentIndex] = propsIdentifier;\n                    modified = true;\n                }\n            }\n            else {\n                // When the prop argument is not destructured, we need to add comments to the spread properties\n                if (j.Identifier.check(currentParam)) {\n                    const commented = commentSpreadProps(path, currentParam.name, j);\n                    const modifiedTypes = modifyTypes(currentParam.typeAnnotation, propsIdentifier, root, j);\n                    modified ||= commented || modifiedTypes;\n                }\n            }\n        }\n        // Helper function to insert `const params = await asyncParams;` at the beginning of the function body\n        function resolveAsyncProp(path, propertiesMap, propsIdentifierName, allProperties, isDefaultExport) {\n            // Rename props to `prop` argument for the function\n            const insertedRenamedPropFunctionNames = new Set();\n            const node = path.value;\n            // If it's sync default export, and it's also server component, make the function async\n            if (isDefaultExport && !isClientComponent) {\n                const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(path.get('body'), j);\n                if (node.async === false && !hasReactHooksUsage) {\n                    node.async = true;\n                    (0, utils_1.turnFunctionReturnTypeToAsync)(node, j);\n                }\n            }\n            // If it's arrow function and function body is not block statement, check if the properties are used there\n            if (j.ArrowFunctionExpression.check(path.node) &&\n                !j.BlockStatement.check(path.node.body)) {\n                const objectExpression = path.node.body;\n                let hasUsedProps = false;\n                j(objectExpression)\n                    .find(j.Identifier)\n                    .forEach((identifierPath) => {\n                    const idName = identifierPath.value.name;\n                    if (propertiesMap.has(idName)) {\n                        hasUsedProps = true;\n                        return;\n                    }\n                });\n                // Turn the function body to block statement, return the object expression\n                if (hasUsedProps) {\n                    path.node.body = j.blockStatement([\n                        j.returnStatement(objectExpression),\n                    ]);\n                }\n            }\n            const isAsyncFunc = !!node.async;\n            const functionName = path.value.id?.name || 'default';\n            const functionBody = (0, utils_1.findFunctionBody)(path);\n            const functionBodyPath = path.get('body');\n            const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(functionBodyPath, j);\n            const hasOtherProperties = allProperties.length > propertiesMap.size;\n            function createDestructuringDeclaration(properties, destructPropsIdentifierName) {\n                const propsToKeep = [];\n                let restProperty = null;\n                // Iterate over the destructured properties\n                properties.forEach((property) => {\n                    if (j.ObjectProperty.check(property)) {\n                        // Handle normal and computed properties\n                        const keyName = j.Identifier.check(property.key)\n                            ? property.key.name\n                            : j.Literal.check(property.key)\n                                ? property.key.value\n                                : null; // for computed properties\n                        if (typeof keyName === 'string') {\n                            propsToKeep.push(property);\n                        }\n                    }\n                    else if (j.RestElement.check(property)) {\n                        restProperty = property;\n                    }\n                });\n                if (propsToKeep.length === 0 && !restProperty) {\n                    return null;\n                }\n                if (restProperty) {\n                    propsToKeep.push(restProperty);\n                }\n                return j.variableDeclaration('const', [\n                    j.variableDeclarator(j.objectPattern(propsToKeep), j.identifier(destructPropsIdentifierName)),\n                ]);\n            }\n            if (hasOtherProperties) {\n                /**\n                 * If there are other properties, we need to keep the original param with destructuring\n                 * e.g.\n                 * input:\n                 * Page({ params: { slug }, otherProp }) {\n                 *   const { slug } = await props.params;\n                 * }\n                 *\n                 * output:\n                 * Page(props) {\n                 *   const { otherProp } = props; // inserted\n                 *   // ...rest of the function body\n                 * }\n                 */\n                const restProperties = allProperties.filter((prop) => {\n                    const isTargetProps = 'key' in prop &&\n                        prop.key.type === 'Identifier' &&\n                        utils_1.TARGET_PROP_NAMES.has(prop.key.name);\n                    return !isTargetProps;\n                });\n                const destructionOtherPropertiesDeclaration = createDestructuringDeclaration(restProperties, propsIdentifierName);\n                if (functionBody && destructionOtherPropertiesDeclaration) {\n                    functionBody.unshift(destructionOtherPropertiesDeclaration);\n                }\n            }\n            let modifiedPropertyCount = 0;\n            for (const [matchedPropName, paramsProperty] of propertiesMap) {\n                if (!utils_1.TARGET_PROP_NAMES.has(matchedPropName)) {\n                    continue;\n                }\n                // In client component, if the param is already wrapped with `use()`, skip the transformation\n                if (isClientComponent) {\n                    let shouldSkip = false;\n                    const propPaths = j(path).find(j.Identifier, {\n                        name: matchedPropName,\n                    });\n                    for (const propPath of propPaths.paths()) {\n                        if ((0, utils_1.isParentUseCallExpression)(propPath, j)) {\n                            // Skip transformation\n                            shouldSkip = true;\n                            break;\n                        }\n                    }\n                    if (shouldSkip) {\n                        continue;\n                    }\n                }\n                const paramsPropertyName = j.Identifier.check(paramsProperty)\n                    ? paramsProperty.name\n                    : null;\n                const paramPropertyName = paramsPropertyName || matchedPropName;\n                // If propName is an identifier and not used in lower scope,\n                // also skip the transformation.\n                const hasUsedInBody = j(functionBodyPath)\n                    .find(j.Identifier, {\n                    name: paramPropertyName,\n                })\n                    .size() > 0;\n                if (!hasUsedInBody && j.Identifier.check(paramsProperty))\n                    continue;\n                // Search the usage of propName in the function body,\n                // if they're all awaited or wrapped with use(), skip the transformation\n                const propUsages = j(functionBodyPath).find(j.Identifier, {\n                    name: paramPropertyName,\n                });\n                // if there's usage of the propName, then do the check\n                if (propUsages.size()) {\n                    let hasMissingAwaited = false;\n                    propUsages.forEach((propUsage) => {\n                        // If the parent is not AwaitExpression, it's not awaited\n                        const isAwaited = propUsage.parentPath?.value.type === 'AwaitExpression';\n                        const isAwaitedByUse = (0, utils_1.isParentUseCallExpression)(propUsage, j);\n                        if (!isAwaited && !isAwaitedByUse) {\n                            hasMissingAwaited = true;\n                            return;\n                        }\n                    });\n                    // If all the usages of parm are awaited, skip the transformation\n                    if (!hasMissingAwaited) {\n                        continue;\n                    }\n                }\n                modifiedPropertyCount++;\n                const propNameIdentifier = j.identifier(matchedPropName);\n                const propsIdentifier = j.identifier(propsIdentifierName);\n                const accessedPropIdExpr = j.memberExpression(propsIdentifier, propNameIdentifier);\n                // Check param property value, if it's destructed, we need to destruct it as well\n                // e.g.\n                // input: Page({ params: { slug } })\n                // output: const { slug } = await props.params; rather than const props = await props.params;\n                const uid = functionName + ':' + paramPropertyName;\n                if (paramsProperty?.type === 'ObjectPattern') {\n                    const objectPattern = paramsProperty;\n                    const objectPatternProperties = objectPattern.properties;\n                    // destruct the object pattern, e.g. { slug } => const { slug } = params;\n                    const destructedObjectPattern = j.variableDeclaration('const', [\n                        j.variableDeclarator(j.objectPattern(objectPatternProperties.map((prop) => {\n                            if (prop.type === 'Property' &&\n                                prop.key.type === 'Identifier') {\n                                return j.objectProperty(j.identifier(prop.key.name), j.identifier(prop.key.name));\n                            }\n                            return prop;\n                        })), propNameIdentifier),\n                    ]);\n                    if (!insertedDestructPropNames.has(uid) && functionBody) {\n                        functionBody.unshift(destructedObjectPattern);\n                        insertedDestructPropNames.add(uid);\n                    }\n                }\n                if (isAsyncFunc) {\n                    // If it's async function, add await to the async props.<propName>\n                    const paramAssignment = j.variableDeclaration('const', [\n                        j.variableDeclarator(j.identifier(paramPropertyName), j.awaitExpression(accessedPropIdExpr)),\n                    ]);\n                    if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n                        functionBody.unshift(paramAssignment);\n                        insertedRenamedPropFunctionNames.add(uid);\n                    }\n                }\n                else {\n                    if (!isClientComponent &&\n                        (0, utils_1.isFunctionType)(node.type) &&\n                        !hasReactHooksUsage) {\n                        // If it's export function, populate the function to async\n                        node.async = true;\n                        (0, utils_1.turnFunctionReturnTypeToAsync)(node, j);\n                        // Insert `const <propName> = await props.<propName>;` at the beginning of the function body\n                        const paramAssignment = j.variableDeclaration('const', [\n                            j.variableDeclarator(j.identifier(paramPropertyName), j.awaitExpression(accessedPropIdExpr)),\n                        ]);\n                        if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n                            functionBody.unshift(paramAssignment);\n                            insertedRenamedPropFunctionNames.add(uid);\n                        }\n                    }\n                    else {\n                        const paramAssignment = j.variableDeclaration('const', [\n                            j.variableDeclarator(j.identifier(paramPropertyName), j.callExpression(j.identifier('use'), [accessedPropIdExpr])),\n                        ]);\n                        if (!insertedRenamedPropFunctionNames.has(uid) && functionBody) {\n                            needsReactUseImport = true;\n                            functionBody.unshift(paramAssignment);\n                            insertedRenamedPropFunctionNames.add(uid);\n                        }\n                    }\n                }\n            }\n            return modifiedPropertyCount > 0;\n        }\n        const defaultExportsDeclarations = root.find(j.ExportDefaultDeclaration);\n        defaultExportsDeclarations.forEach((path) => {\n            const functionPath = (0, utils_1.getFunctionPathFromExportPath)(path, j, root, () => true);\n            if (functionPath) {\n                renameAsyncPropIfExisted(functionPath, true);\n            }\n        });\n        // Matching Next.js functional named export of route entry:\n        // - export function <named>(...) { ... }\n        // - export const <named> = ...\n        const namedExportDeclarations = root.find(j.ExportNamedDeclaration);\n        namedExportDeclarations.forEach((path) => {\n            const functionPath = (0, utils_1.getFunctionPathFromExportPath)(path, j, root, (idName) => utils_1.TARGET_NAMED_EXPORTS.has(idName));\n            if (functionPath) {\n                renameAsyncPropIfExisted(functionPath, false);\n            }\n        });\n    }\n    const isClientComponent = (0, utils_1.determineClientDirective)(root, j);\n    // Apply to `params` and `searchParams`\n    processAsyncPropOfEntryFile(isClientComponent);\n    // Add import { use } from 'react' if needed and not already imported\n    if (needsReactUseImport) {\n        (0, utils_1.insertReactUseImport)(root, j);\n    }\n    const commented = commentOnMatchedReExports(root, j);\n    modified ||= commented;\n    return modified ? root.toSource() : null;\n}\nfunction findAllTypes(root, j, typeName) {\n    const types = {\n        interfaces: [],\n        typeAliases: [],\n        imports: [],\n        references: [],\n    };\n    // Step 1: Find all interface declarations with the specified name\n    root\n        .find(j.TSInterfaceDeclaration, {\n        id: {\n            type: 'Identifier',\n            name: typeName,\n        },\n    })\n        .forEach((path) => {\n        types.interfaces.push(path.node);\n    });\n    // Step 2: Find all type alias declarations with the specified name\n    root\n        .find(j.TSTypeAliasDeclaration, {\n        id: {\n            type: 'Identifier',\n            name: typeName,\n        },\n    })\n        .forEach((path) => {\n        types.typeAliases.push(path.node);\n    });\n    // Step 3: Find all imported types with the specified name\n    root\n        .find(j.ImportSpecifier, {\n        imported: {\n            type: 'Identifier',\n            name: typeName,\n        },\n    })\n        .forEach((path) => {\n        types.imports.push(path.node);\n    });\n    // Step 4: Find all references to the specified type\n    root\n        .find(j.TSTypeReference, {\n        typeName: {\n            type: 'Identifier',\n            name: typeName,\n        },\n    })\n        .forEach((path) => {\n        types.references.push(path.node);\n    });\n    return types;\n}\nfunction commentSpreadProps(path, propsIdentifierName, j) {\n    let modified = false;\n    const functionBody = (0, utils_1.findFunctionBody)(path);\n    const functionBodyCollection = j(functionBody);\n    // Find all the usage of spreading properties of `props`\n    const jsxSpreadProperties = functionBodyCollection.find(j.JSXSpreadAttribute, { argument: { name: propsIdentifierName } });\n    const objSpreadProperties = functionBodyCollection.find(j.SpreadElement, {\n        argument: { name: propsIdentifierName },\n    });\n    const comment = ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} '${propsIdentifierName}' is used with spread syntax (...). Any asynchronous properties of '${propsIdentifierName}' must be awaited when accessed. `;\n    // Add comment before it\n    jsxSpreadProperties.forEach((spread) => {\n        const inserted = (0, utils_1.insertCommentOnce)(spread.value, j, comment);\n        if (inserted)\n            modified = true;\n    });\n    objSpreadProperties.forEach((spread) => {\n        const inserted = (0, utils_1.insertCommentOnce)(spread.value, j, comment);\n        if (inserted)\n            modified = true;\n    });\n    return modified;\n}\n//# sourceMappingURL=next-async-dynamic-prop.js.map"],"mappings":"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","ignoreList":[]}},"mtime":1769077344094},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/utils.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isReactHookName = exports.TARGET_PROP_NAMES = exports.TARGET_NAMED_EXPORTS = exports.TARGET_ROUTE_EXPORTS = exports.NEXT_CODEMOD_ERROR_PREFIX = exports.NEXTJS_ENTRY_FILES = void 0;\nexports.isFunctionType = isFunctionType;\nexports.isMatchedFunctionExported = isMatchedFunctionExported;\nexports.determineClientDirective = determineClientDirective;\nexports.isPromiseType = isPromiseType;\nexports.turnFunctionReturnTypeToAsync = turnFunctionReturnTypeToAsync;\nexports.insertReactUseImport = insertReactUseImport;\nexports.generateUniqueIdentifier = generateUniqueIdentifier;\nexports.isFunctionScope = isFunctionScope;\nexports.findClosetParentFunctionScope = findClosetParentFunctionScope;\nexports.getFunctionPathFromExportPath = getFunctionPathFromExportPath;\nexports.wrapParentheseIfNeeded = wrapParentheseIfNeeded;\nexports.insertCommentOnce = insertCommentOnce;\nexports.getVariableDeclaratorId = getVariableDeclaratorId;\nexports.findFunctionBody = findFunctionBody;\nexports.containsReactHooksCallExpressions = containsReactHooksCallExpressions;\nexports.isParentUseCallExpression = isParentUseCallExpression;\nexports.isParentPromiseAllCallExpression = isParentPromiseAllCallExpression;\nexports.NEXTJS_ENTRY_FILES = /([\\\\/]|^)(page|layout|route|default)\\.(t|j)sx?$/;\nexports.NEXT_CODEMOD_ERROR_PREFIX = '@next-codemod-error';\nconst NEXT_CODEMOD_IGNORE_ERROR_PREFIX = '@next-codemod-ignore';\nexports.TARGET_ROUTE_EXPORTS = new Set(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']);\nexports.TARGET_NAMED_EXPORTS = new Set([\n// For page and layout\n'generateMetadata', 'generateViewport', ...exports.TARGET_ROUTE_EXPORTS]);\nexports.TARGET_PROP_NAMES = new Set(['params', 'searchParams']);\nfunction isFunctionType(type) {\n  return type === 'FunctionDeclaration' || type === 'FunctionExpression' || type === 'ArrowFunctionExpression';\n}\nfunction isMatchedFunctionExported(path, j) {\n  const matchedFunctionNameFilter = idName => exports.TARGET_NAMED_EXPORTS.has(idName);\n  const directNamedExport = j(path).closest(j.ExportNamedDeclaration, {\n    declaration: {\n      type: 'FunctionDeclaration',\n      id: {\n        name: matchedFunctionNameFilter\n      }\n    }\n  });\n  if (directNamedExport.size() > 0) {\n    return true;\n  }\n  // Check for default export (`export default function() {}`)\n  const isDefaultExport = j(path).closest(j.ExportDefaultDeclaration).size() > 0;\n  if (isDefaultExport) {\n    return true;\n  }\n  // Look for named export elsewhere in the file (`export { <named> }`)\n  const root = j(path).closestScope().closest(j.Program);\n  const isNamedExport = root.find(j.ExportNamedDeclaration, {\n    specifiers: [{\n      type: 'ExportSpecifier',\n      exported: {\n        name: matchedFunctionNameFilter\n      }\n    }]\n  }).size() > 0;\n  // Look for variable export but still function, e.g. `export const <named> = function() {}`,\n  // also check if variable is a function or arrow function\n  const isVariableExport = root.find(j.ExportNamedDeclaration, {\n    declaration: {\n      declarations: [{\n        type: 'VariableDeclarator',\n        id: {\n          type: 'Identifier',\n          name: matchedFunctionNameFilter\n        },\n        init: {\n          type: isFunctionType\n        }\n      }]\n    }\n  }).size() > 0;\n  if (isVariableExport) return true;\n  return isNamedExport;\n}\n// directive is not parsed into AST, so we need to manually find it\n// by going through the tokens. Use the 1st string token as the directive\nfunction determineClientDirective(root, j) {\n  const {\n    program\n  } = root.get().node;\n  const directive = program.directives[0];\n  if (j.Directive.check(directive)) {\n    return directive.value.value === 'use client';\n  }\n  return false;\n}\nfunction isPromiseType(typeAnnotation) {\n  return typeAnnotation.type === 'TSTypeReference' && typeAnnotation.typeName.name === 'Promise';\n}\nfunction turnFunctionReturnTypeToAsync(node, j) {\n  if (j.FunctionDeclaration.check(node) || j.FunctionExpression.check(node) || j.ArrowFunctionExpression.check(node)) {\n    if (node.returnType) {\n      const returnTypeAnnotation = node.returnType.typeAnnotation;\n      const isReturnTypePromise = isPromiseType(returnTypeAnnotation);\n      // Turn <return type> to Promise<return type>\n      // e.g. () => { slug: string } to () => Promise<{ slug: string }>\n      // e.g. Anything to Promise<Anything>\n      if (!isReturnTypePromise) {\n        if (node.returnType && j.TSTypeAnnotation.check(node.returnType) && (j.TSTypeReference.check(node.returnType.typeAnnotation) || j.TSUnionType.check(node.returnType.typeAnnotation) || j.TSTypePredicate.check(node.returnType.typeAnnotation))) {\n          // Change the return type to Promise<void>\n          node.returnType.typeAnnotation = j.tsTypeReference(j.identifier('Promise'),\n          // @ts-ignore ignore the super strict type checking on the type annotation\n          j.tsTypeParameterInstantiation([returnTypeAnnotation]));\n        }\n      }\n    }\n  }\n}\nfunction insertReactUseImport(root, j) {\n  const hasReactUseImport = root.find(j.ImportSpecifier, {\n    imported: {\n      type: 'Identifier',\n      name: 'use'\n    }\n  }).size() > 0;\n  if (!hasReactUseImport) {\n    const reactImportDeclaration = root.find(j.ImportDeclaration, {\n      source: {\n        value: 'react'\n      },\n      // Skip the type only react imports\n      importKind: 'value'\n    });\n    if (reactImportDeclaration.size() > 0) {\n      const importNode = reactImportDeclaration.get().node;\n      // Add 'use' to existing 'react' import declaration\n      importNode.specifiers.push(j.importSpecifier(j.identifier('use')));\n    } else {\n      // Final all type imports to 'react'\n      if (reactImportDeclaration.size() > 0) {\n        reactImportDeclaration.get().node.specifiers.push(j.importSpecifier(j.identifier('use')));\n      } else {\n        // Add new import declaration for 'react' and 'use'\n        root.get().node.program.body.unshift(j.importDeclaration([j.importSpecifier(j.identifier('use'))], j.literal('react')));\n      }\n    }\n  }\n}\nfunction findSubScopeArgumentIdentifier(path, j, argName) {\n  const defCount = j(path).find(j.Identifier, {\n    name: argName\n  }).size();\n  return defCount > 0;\n}\nfunction generateUniqueIdentifier(defaultIdName, path, j) {\n  let idName = defaultIdName;\n  let idNameSuffix = 0;\n  while (findSubScopeArgumentIdentifier(path, j, idName)) {\n    idName = defaultIdName + idNameSuffix;\n    idNameSuffix++;\n  }\n  const propsIdentifier = j.identifier(idName);\n  return propsIdentifier;\n}\nfunction isFunctionScope(path, j) {\n  if (!path) return false;\n  const node = path.node;\n  // Check if the node is a function (declaration, expression, or arrow function)\n  return j.FunctionDeclaration.check(node) || j.FunctionExpression.check(node) || j.ArrowFunctionExpression.check(node);\n}\nfunction findClosetParentFunctionScope(path, j) {\n  if (!path.scope) return null;\n  let parentFunctionPath = path.scope.path;\n  while (parentFunctionPath && !isFunctionScope(parentFunctionPath, j)) {\n    parentFunctionPath = parentFunctionPath.parent;\n  }\n  return parentFunctionPath;\n}\nfunction getFunctionNodeFromBinding(bindingPath, idName, j, root) {\n  const bindingNode = bindingPath.node;\n  if (j.FunctionDeclaration.check(bindingNode) || j.FunctionExpression.check(bindingNode) || j.ArrowFunctionExpression.check(bindingNode)) {\n    return bindingPath;\n  } else if (j.VariableDeclarator.check(bindingNode)) {\n    const init = bindingNode.init;\n    // If the initializer is a function (arrow or function expression), record it\n    if (j.FunctionExpression.check(init) || j.ArrowFunctionExpression.check(init)) {\n      return bindingPath.get('init');\n    }\n  } else if (j.Identifier.check(bindingNode)) {\n    const variablePath = root.find(j.VariableDeclaration, {\n      // declarations, each is VariableDeclarator\n      declarations: [{\n        // VariableDeclarator\n        type: 'VariableDeclarator',\n        // id is Identifier\n        id: {\n          type: 'Identifier',\n          name: idName\n        }\n      }]\n    });\n    if (variablePath.size()) {\n      var _variablePath$get;\n      const variableDeclarator = (_variablePath$get = variablePath.get()) === null || _variablePath$get === void 0 || (_variablePath$get = _variablePath$get.node) === null || _variablePath$get === void 0 || (_variablePath$get = _variablePath$get.declarations) === null || _variablePath$get === void 0 ? void 0 : _variablePath$get[0];\n      if (j.VariableDeclarator.check(variableDeclarator)) {\n        const init = variableDeclarator.init;\n        if (j.FunctionExpression.check(init) || j.ArrowFunctionExpression.check(init)) {\n          return variablePath.get('declarations', 0, 'init');\n        }\n      }\n    }\n    const functionDeclarations = root.find(j.FunctionDeclaration, {\n      id: {\n        name: idName\n      }\n    });\n    if (functionDeclarations.size()) {\n      return functionDeclarations.get();\n    }\n  }\n  return undefined;\n}\nfunction getFunctionPathFromExportPath(exportPath, j, root, namedExportFilter) {\n  // Default export\n  if (j.ExportDefaultDeclaration.check(exportPath.node)) {\n    const {\n      declaration\n    } = exportPath.node;\n    if (declaration) {\n      if (j.FunctionDeclaration.check(declaration) || j.FunctionExpression.check(declaration) || j.ArrowFunctionExpression.check(declaration)) {\n        return exportPath.get('declaration');\n      } else if (j.Identifier.check(declaration)) {\n        var _exportPath$scope$get;\n        const idName = declaration.name;\n        if (!namedExportFilter(idName)) return;\n        const exportBinding = (_exportPath$scope$get = exportPath.scope.getBindings()[idName]) === null || _exportPath$scope$get === void 0 ? void 0 : _exportPath$scope$get[0];\n        if (exportBinding) {\n          return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n        }\n      }\n    }\n  } else if (\n  // Named exports\n  j.ExportNamedDeclaration.check(exportPath.node)) {\n    const namedExportPath = exportPath;\n    // extract the named exports, name specifiers, and default specifiers\n    const {\n      declaration,\n      specifiers\n    } = namedExportPath.node;\n    if (declaration) {\n      if (j.VariableDeclaration.check(declaration)) {\n        const {\n          declarations\n        } = declaration;\n        for (const decl of declarations) {\n          if (j.VariableDeclarator.check(decl) && j.Identifier.check(decl.id)) {\n            var _namedExportPath$scop;\n            const idName = decl.id.name;\n            if (!namedExportFilter(idName)) return;\n            // get bindings for each variable declarator\n            const exportBinding = (_namedExportPath$scop = namedExportPath.scope.getBindings()[idName]) === null || _namedExportPath$scop === void 0 ? void 0 : _namedExportPath$scop[0];\n            if (exportBinding) {\n              return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n            }\n          }\n        }\n      } else if (j.FunctionDeclaration.check(declaration) || j.FunctionExpression.check(declaration) || j.ArrowFunctionExpression.check(declaration)) {\n        var _declaration$id;\n        const funcName = (_declaration$id = declaration.id) === null || _declaration$id === void 0 ? void 0 : _declaration$id.name;\n        if (!namedExportFilter(funcName)) return;\n        return namedExportPath.get('declaration');\n      }\n    }\n    if (specifiers) {\n      for (const specifier of specifiers) {\n        if (j.ExportSpecifier.check(specifier)) {\n          var _namedExportPath$scop2;\n          const idName = specifier.local.name;\n          if (!namedExportFilter(idName)) return;\n          const exportBinding = (_namedExportPath$scop2 = namedExportPath.scope.getBindings()[idName]) === null || _namedExportPath$scop2 === void 0 ? void 0 : _namedExportPath$scop2[0];\n          if (exportBinding) {\n            return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n          }\n        }\n      }\n    }\n  }\n  return undefined;\n}\nfunction wrapParentheseIfNeeded(hasChainAccess, j, expression) {\n  return hasChainAccess ? j.parenthesizedExpression(expression) : expression;\n}\nfunction existsComment(comments, comment) {\n  const isCodemodErrorComment = comment.trim().startsWith(exports.NEXT_CODEMOD_ERROR_PREFIX);\n  let hasIgnoreComment = false;\n  let hasComment = false;\n  if (comments) {\n    comments.forEach(commentNode => {\n      const currentComment = commentNode.value;\n      if (currentComment.trim().startsWith(NEXT_CODEMOD_IGNORE_ERROR_PREFIX)) {\n        hasIgnoreComment = true;\n      }\n      if (currentComment === comment) {\n        hasComment = true;\n      }\n    });\n    // If it's inserting codemod error comment,\n    // check if there's already a @next-codemod-ignore comment.\n    // if ignore comment exists, bypass the comment insertion.\n    if (hasIgnoreComment && isCodemodErrorComment) {\n      return true;\n    }\n    if (hasComment) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction insertCommentOnce(node, j, comment) {\n  const hasCommentInInlineComments = existsComment(node.comments, comment);\n  const hasCommentInLeadingComments = existsComment(node.leadingComments, comment);\n  if (!hasCommentInInlineComments && !hasCommentInLeadingComments) {\n    // Always insert into inline comment\n    node.comments = [j.commentBlock(comment), ...(node.comments || [])];\n    return true;\n  }\n  return false;\n}\nfunction getVariableDeclaratorId(path, j) {\n  const parent = path.parentPath;\n  if (j.VariableDeclarator.check(parent.node)) {\n    const id = parent.node.id;\n    if (j.Identifier.check(id)) {\n      return id;\n    }\n  }\n  return undefined;\n}\nfunction findFunctionBody(path) {\n  let functionBody = path.node.body;\n  if (functionBody && functionBody.type === 'BlockStatement') {\n    return functionBody.body;\n  }\n  return null;\n}\nconst isPascalCase = s => /^[A-Z][a-z0-9]*$/.test(s);\nconst isReactHookName = name =>\n// function name is `use`\nname === 'use' ||\n// function name is `useX*`\nname.startsWith('use') && name[3] === name[3].toUpperCase();\nexports.isReactHookName = isReactHookName;\n// Determine a path of function contains any React hooks call expressions.\n// e.g. if there's any of those call expressions in the function body:\n// use() => true\n// React.use() => false\n// useXxxx() => true\n// Foo.use() => true\n// Foo.useXxxx() => true\nfunction containsReactHooksCallExpressions(path, j) {\n  const hasReactHooks = j(path).find(j.CallExpression).filter(callPath => {\n    // It's matching:\n    // - use(<callPath>) => true\n    // - useX*(<callPath>) => true\n    const isUseHookOrReactHookCall = j.Identifier.check(callPath.value.callee) && (0, exports.isReactHookName)(callPath.value.callee.name);\n    // It's matching member access:\n    // - React.use(<callPath>) => true\n    // - Foo.useFoo(<callPath>) => true\n    // - foo.useFoo(<callPath>) => false\n    // - foo.use(<callPath>) => false\n    const isReactUseCall = j.MemberExpression.check(callPath.value.callee) && j.Identifier.check(callPath.value.callee.object) && j.Identifier.check(callPath.value.callee.property) && isPascalCase(callPath.value.callee.object.name) && (0, exports.isReactHookName)(callPath.value.callee.property.name);\n    return isUseHookOrReactHookCall || isReactUseCall;\n  }).size() > 0;\n  return hasReactHooks;\n}\n// Capture the parent of the current path is wrapped by `use()` call expression\n// e.g.\n// use(<path>) => true\n// use2(<path>) => false\n// React.use(<path>) => true\n// Robust.use(<path>) => false\nfunction isParentUseCallExpression(path, j) {\n  const isParentUseCall =\n  // member access parentPath is argument\n  j.CallExpression.check(path.parent.value) &&\n  // member access is first argument\n  path.parent.value.arguments[0] === path.value && path.parent.value.arguments.length === 1 &&\n  // function name is `use`\n  j.Identifier.check(path.parent.value.callee) && path.parent.value.callee.name === 'use';\n  const isParentReactUseCall =\n  // member access parentPath is argument\n  j.CallExpression.check(path.parent.value) &&\n  // member access is first argument\n  path.parent.value.arguments[0] === path.value && path.parent.value.arguments.length === 1 &&\n  // function name is `use`\n  j.MemberExpression.check(path.parent.value.callee) && j.Identifier.check(path.parent.value.callee.object) && path.parent.value.callee.object.name === 'React' && j.Identifier.check(path.parent.value.callee.property) && path.parent.value.callee.property.name === 'use';\n  return isParentUseCall || isParentReactUseCall;\n}\n// Determine if a path is wrapped by `Promise.all()`\n// e.g.\n// Promise.all(<path>) => true\n// Promise.allSettled(<path>) => false\nfunction isParentPromiseAllCallExpression(path, j) {\n  const argsParent = path.parent;\n  const callParent = argsParent === null || argsParent === void 0 ? void 0 : argsParent.parent;\n  if (argsParent && callParent && j.ArrayExpression.check(argsParent.value) && j.CallExpression.check(callParent.value) && j.MemberExpression.check(callParent.value.callee) && j.Identifier.check(callParent.value.callee.object) && callParent.value.callee.object.name === 'Promise' && j.Identifier.check(callParent.value.callee.property) && callParent.value.callee.property.name === 'all') {\n    return true;\n  }\n  return false;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzUmVhY3RIb29rTmFtZSIsIlRBUkdFVF9QUk9QX05BTUVTIiwiVEFSR0VUX05BTUVEX0VYUE9SVFMiLCJUQVJHRVRfUk9VVEVfRVhQT1JUUyIsIk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVgiLCJORVhUSlNfRU5UUllfRklMRVMiLCJpc0Z1bmN0aW9uVHlwZSIsImlzTWF0Y2hlZEZ1bmN0aW9uRXhwb3J0ZWQiLCJkZXRlcm1pbmVDbGllbnREaXJlY3RpdmUiLCJpc1Byb21pc2VUeXBlIiwidHVybkZ1bmN0aW9uUmV0dXJuVHlwZVRvQXN5bmMiLCJpbnNlcnRSZWFjdFVzZUltcG9ydCIsImdlbmVyYXRlVW5pcXVlSWRlbnRpZmllciIsImlzRnVuY3Rpb25TY29wZSIsImZpbmRDbG9zZXRQYXJlbnRGdW5jdGlvblNjb3BlIiwiZ2V0RnVuY3Rpb25QYXRoRnJvbUV4cG9ydFBhdGgiLCJ3cmFwUGFyZW50aGVzZUlmTmVlZGVkIiwiaW5zZXJ0Q29tbWVudE9uY2UiLCJnZXRWYXJpYWJsZURlY2xhcmF0b3JJZCIsImZpbmRGdW5jdGlvbkJvZHkiLCJjb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnMiLCJpc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uIiwiaXNQYXJlbnRQcm9taXNlQWxsQ2FsbEV4cHJlc3Npb24iLCJORVhUX0NPREVNT0RfSUdOT1JFX0VSUk9SX1BSRUZJWCIsIlNldCIsInR5cGUiLCJwYXRoIiwiaiIsIm1hdGNoZWRGdW5jdGlvbk5hbWVGaWx0ZXIiLCJpZE5hbWUiLCJoYXMiLCJkaXJlY3ROYW1lZEV4cG9ydCIsImNsb3Nlc3QiLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb24iLCJpZCIsIm5hbWUiLCJzaXplIiwiaXNEZWZhdWx0RXhwb3J0IiwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIiwicm9vdCIsImNsb3Nlc3RTY29wZSIsIlByb2dyYW0iLCJpc05hbWVkRXhwb3J0IiwiZmluZCIsInNwZWNpZmllcnMiLCJleHBvcnRlZCIsImlzVmFyaWFibGVFeHBvcnQiLCJkZWNsYXJhdGlvbnMiLCJpbml0IiwicHJvZ3JhbSIsImdldCIsIm5vZGUiLCJkaXJlY3RpdmUiLCJkaXJlY3RpdmVzIiwiRGlyZWN0aXZlIiwiY2hlY2siLCJ0eXBlQW5ub3RhdGlvbiIsInR5cGVOYW1lIiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwicmV0dXJuVHlwZSIsInJldHVyblR5cGVBbm5vdGF0aW9uIiwiaXNSZXR1cm5UeXBlUHJvbWlzZSIsIlRTVHlwZUFubm90YXRpb24iLCJUU1R5cGVSZWZlcmVuY2UiLCJUU1VuaW9uVHlwZSIsIlRTVHlwZVByZWRpY2F0ZSIsInRzVHlwZVJlZmVyZW5jZSIsImlkZW50aWZpZXIiLCJ0c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uIiwiaGFzUmVhY3RVc2VJbXBvcnQiLCJJbXBvcnRTcGVjaWZpZXIiLCJpbXBvcnRlZCIsInJlYWN0SW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWNsYXJhdGlvbiIsInNvdXJjZSIsImltcG9ydEtpbmQiLCJpbXBvcnROb2RlIiwicHVzaCIsImltcG9ydFNwZWNpZmllciIsImJvZHkiLCJ1bnNoaWZ0IiwiaW1wb3J0RGVjbGFyYXRpb24iLCJsaXRlcmFsIiwiZmluZFN1YlNjb3BlQXJndW1lbnRJZGVudGlmaWVyIiwiYXJnTmFtZSIsImRlZkNvdW50IiwiSWRlbnRpZmllciIsImRlZmF1bHRJZE5hbWUiLCJpZE5hbWVTdWZmaXgiLCJwcm9wc0lkZW50aWZpZXIiLCJzY29wZSIsInBhcmVudEZ1bmN0aW9uUGF0aCIsInBhcmVudCIsImdldEZ1bmN0aW9uTm9kZUZyb21CaW5kaW5nIiwiYmluZGluZ1BhdGgiLCJiaW5kaW5nTm9kZSIsIlZhcmlhYmxlRGVjbGFyYXRvciIsInZhcmlhYmxlUGF0aCIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJfdmFyaWFibGVQYXRoJGdldCIsInZhcmlhYmxlRGVjbGFyYXRvciIsImZ1bmN0aW9uRGVjbGFyYXRpb25zIiwidW5kZWZpbmVkIiwiZXhwb3J0UGF0aCIsIm5hbWVkRXhwb3J0RmlsdGVyIiwiX2V4cG9ydFBhdGgkc2NvcGUkZ2V0IiwiZXhwb3J0QmluZGluZyIsImdldEJpbmRpbmdzIiwibmFtZWRFeHBvcnRQYXRoIiwiZGVjbCIsIl9uYW1lZEV4cG9ydFBhdGgkc2NvcCIsIl9kZWNsYXJhdGlvbiRpZCIsImZ1bmNOYW1lIiwic3BlY2lmaWVyIiwiRXhwb3J0U3BlY2lmaWVyIiwiX25hbWVkRXhwb3J0UGF0aCRzY29wMiIsImxvY2FsIiwiaGFzQ2hhaW5BY2Nlc3MiLCJleHByZXNzaW9uIiwicGFyZW50aGVzaXplZEV4cHJlc3Npb24iLCJleGlzdHNDb21tZW50IiwiY29tbWVudHMiLCJjb21tZW50IiwiaXNDb2RlbW9kRXJyb3JDb21tZW50IiwidHJpbSIsInN0YXJ0c1dpdGgiLCJoYXNJZ25vcmVDb21tZW50IiwiaGFzQ29tbWVudCIsImZvckVhY2giLCJjb21tZW50Tm9kZSIsImN1cnJlbnRDb21tZW50IiwiaGFzQ29tbWVudEluSW5saW5lQ29tbWVudHMiLCJoYXNDb21tZW50SW5MZWFkaW5nQ29tbWVudHMiLCJsZWFkaW5nQ29tbWVudHMiLCJjb21tZW50QmxvY2siLCJwYXJlbnRQYXRoIiwiZnVuY3Rpb25Cb2R5IiwiaXNQYXNjYWxDYXNlIiwicyIsInRlc3QiLCJ0b1VwcGVyQ2FzZSIsImhhc1JlYWN0SG9va3MiLCJDYWxsRXhwcmVzc2lvbiIsImZpbHRlciIsImNhbGxQYXRoIiwiaXNVc2VIb29rT3JSZWFjdEhvb2tDYWxsIiwiY2FsbGVlIiwiaXNSZWFjdFVzZUNhbGwiLCJNZW1iZXJFeHByZXNzaW9uIiwib2JqZWN0IiwicHJvcGVydHkiLCJpc1BhcmVudFVzZUNhbGwiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpc1BhcmVudFJlYWN0VXNlQ2FsbCIsImFyZ3NQYXJlbnQiLCJjYWxsUGFyZW50IiwiQXJyYXlFeHByZXNzaW9uIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL0BuZXh0L2NvZGVtb2QvdHJhbnNmb3Jtcy9saWIvYXN5bmMtcmVxdWVzdC1hcGkvIiwic291cmNlcyI6WyJ1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNSZWFjdEhvb2tOYW1lID0gZXhwb3J0cy5UQVJHRVRfUFJPUF9OQU1FUyA9IGV4cG9ydHMuVEFSR0VUX05BTUVEX0VYUE9SVFMgPSBleHBvcnRzLlRBUkdFVF9ST1VURV9FWFBPUlRTID0gZXhwb3J0cy5ORVhUX0NPREVNT0RfRVJST1JfUFJFRklYID0gZXhwb3J0cy5ORVhUSlNfRU5UUllfRklMRVMgPSB2b2lkIDA7XG5leHBvcnRzLmlzRnVuY3Rpb25UeXBlID0gaXNGdW5jdGlvblR5cGU7XG5leHBvcnRzLmlzTWF0Y2hlZEZ1bmN0aW9uRXhwb3J0ZWQgPSBpc01hdGNoZWRGdW5jdGlvbkV4cG9ydGVkO1xuZXhwb3J0cy5kZXRlcm1pbmVDbGllbnREaXJlY3RpdmUgPSBkZXRlcm1pbmVDbGllbnREaXJlY3RpdmU7XG5leHBvcnRzLmlzUHJvbWlzZVR5cGUgPSBpc1Byb21pc2VUeXBlO1xuZXhwb3J0cy50dXJuRnVuY3Rpb25SZXR1cm5UeXBlVG9Bc3luYyA9IHR1cm5GdW5jdGlvblJldHVyblR5cGVUb0FzeW5jO1xuZXhwb3J0cy5pbnNlcnRSZWFjdFVzZUltcG9ydCA9IGluc2VydFJlYWN0VXNlSW1wb3J0O1xuZXhwb3J0cy5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIgPSBnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXI7XG5leHBvcnRzLmlzRnVuY3Rpb25TY29wZSA9IGlzRnVuY3Rpb25TY29wZTtcbmV4cG9ydHMuZmluZENsb3NldFBhcmVudEZ1bmN0aW9uU2NvcGUgPSBmaW5kQ2xvc2V0UGFyZW50RnVuY3Rpb25TY29wZTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25QYXRoRnJvbUV4cG9ydFBhdGggPSBnZXRGdW5jdGlvblBhdGhGcm9tRXhwb3J0UGF0aDtcbmV4cG9ydHMud3JhcFBhcmVudGhlc2VJZk5lZWRlZCA9IHdyYXBQYXJlbnRoZXNlSWZOZWVkZWQ7XG5leHBvcnRzLmluc2VydENvbW1lbnRPbmNlID0gaW5zZXJ0Q29tbWVudE9uY2U7XG5leHBvcnRzLmdldFZhcmlhYmxlRGVjbGFyYXRvcklkID0gZ2V0VmFyaWFibGVEZWNsYXJhdG9ySWQ7XG5leHBvcnRzLmZpbmRGdW5jdGlvbkJvZHkgPSBmaW5kRnVuY3Rpb25Cb2R5O1xuZXhwb3J0cy5jb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnMgPSBjb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnM7XG5leHBvcnRzLmlzUGFyZW50VXNlQ2FsbEV4cHJlc3Npb24gPSBpc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1BhcmVudFByb21pc2VBbGxDYWxsRXhwcmVzc2lvbiA9IGlzUGFyZW50UHJvbWlzZUFsbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5ORVhUSlNfRU5UUllfRklMRVMgPSAvKFtcXFxcL118XikocGFnZXxsYXlvdXR8cm91dGV8ZGVmYXVsdClcXC4odHxqKXN4PyQvO1xuZXhwb3J0cy5ORVhUX0NPREVNT0RfRVJST1JfUFJFRklYID0gJ0BuZXh0LWNvZGVtb2QtZXJyb3InO1xuY29uc3QgTkVYVF9DT0RFTU9EX0lHTk9SRV9FUlJPUl9QUkVGSVggPSAnQG5leHQtY29kZW1vZC1pZ25vcmUnO1xuZXhwb3J0cy5UQVJHRVRfUk9VVEVfRVhQT1JUUyA9IG5ldyBTZXQoW1xuICAgICdHRVQnLFxuICAgICdQT1NUJyxcbiAgICAnUFVUJyxcbiAgICAnUEFUQ0gnLFxuICAgICdERUxFVEUnLFxuICAgICdPUFRJT05TJyxcbiAgICAnSEVBRCcsXG5dKTtcbmV4cG9ydHMuVEFSR0VUX05BTUVEX0VYUE9SVFMgPSBuZXcgU2V0KFtcbiAgICAvLyBGb3IgcGFnZSBhbmQgbGF5b3V0XG4gICAgJ2dlbmVyYXRlTWV0YWRhdGEnLFxuICAgICdnZW5lcmF0ZVZpZXdwb3J0JyxcbiAgICAuLi5leHBvcnRzLlRBUkdFVF9ST1VURV9FWFBPUlRTLFxuXSk7XG5leHBvcnRzLlRBUkdFVF9QUk9QX05BTUVTID0gbmV3IFNldChbJ3BhcmFtcycsICdzZWFyY2hQYXJhbXMnXSk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyk7XG59XG5mdW5jdGlvbiBpc01hdGNoZWRGdW5jdGlvbkV4cG9ydGVkKHBhdGgsIGopIHtcbiAgICBjb25zdCBtYXRjaGVkRnVuY3Rpb25OYW1lRmlsdGVyID0gKGlkTmFtZSkgPT4gZXhwb3J0cy5UQVJHRVRfTkFNRURfRVhQT1JUUy5oYXMoaWROYW1lKTtcbiAgICBjb25zdCBkaXJlY3ROYW1lZEV4cG9ydCA9IGoocGF0aCkuY2xvc2VzdChqLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24sIHtcbiAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWF0Y2hlZEZ1bmN0aW9uTmFtZUZpbHRlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKGRpcmVjdE5hbWVkRXhwb3J0LnNpemUoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBkZWZhdWx0IGV4cG9ydCAoYGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge31gKVxuICAgIGNvbnN0IGlzRGVmYXVsdEV4cG9ydCA9IGoocGF0aCkuY2xvc2VzdChqLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbikuc2l6ZSgpID4gMDtcbiAgICBpZiAoaXNEZWZhdWx0RXhwb3J0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBMb29rIGZvciBuYW1lZCBleHBvcnQgZWxzZXdoZXJlIGluIHRoZSBmaWxlIChgZXhwb3J0IHsgPG5hbWVkPiB9YClcbiAgICBjb25zdCByb290ID0gaihwYXRoKS5jbG9zZXN0U2NvcGUoKS5jbG9zZXN0KGouUHJvZ3JhbSk7XG4gICAgY29uc3QgaXNOYW1lZEV4cG9ydCA9IHJvb3RcbiAgICAgICAgLmZpbmQoai5FeHBvcnROYW1lZERlY2xhcmF0aW9uLCB7XG4gICAgICAgIHNwZWNpZmllcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRXhwb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgICAgICBleHBvcnRlZDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaGVkRnVuY3Rpb25OYW1lRmlsdGVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pXG4gICAgICAgIC5zaXplKCkgPiAwO1xuICAgIC8vIExvb2sgZm9yIHZhcmlhYmxlIGV4cG9ydCBidXQgc3RpbGwgZnVuY3Rpb24sIGUuZy4gYGV4cG9ydCBjb25zdCA8bmFtZWQ+ID0gZnVuY3Rpb24oKSB7fWAsXG4gICAgLy8gYWxzbyBjaGVjayBpZiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIGFycm93IGZ1bmN0aW9uXG4gICAgY29uc3QgaXNWYXJpYWJsZUV4cG9ydCA9IHJvb3RcbiAgICAgICAgLmZpbmQoai5FeHBvcnROYW1lZERlY2xhcmF0aW9uLCB7XG4gICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWF0Y2hlZEZ1bmN0aW9uTmFtZUZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXNGdW5jdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAgICAgLnNpemUoKSA+IDA7XG4gICAgaWYgKGlzVmFyaWFibGVFeHBvcnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBpc05hbWVkRXhwb3J0O1xufVxuLy8gZGlyZWN0aXZlIGlzIG5vdCBwYXJzZWQgaW50byBBU1QsIHNvIHdlIG5lZWQgdG8gbWFudWFsbHkgZmluZCBpdFxuLy8gYnkgZ29pbmcgdGhyb3VnaCB0aGUgdG9rZW5zLiBVc2UgdGhlIDFzdCBzdHJpbmcgdG9rZW4gYXMgdGhlIGRpcmVjdGl2ZVxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2xpZW50RGlyZWN0aXZlKHJvb3QsIGopIHtcbiAgICBjb25zdCB7IHByb2dyYW0gfSA9IHJvb3QuZ2V0KCkubm9kZTtcbiAgICBjb25zdCBkaXJlY3RpdmUgPSBwcm9ncmFtLmRpcmVjdGl2ZXNbMF07XG4gICAgaWYgKGouRGlyZWN0aXZlLmNoZWNrKGRpcmVjdGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gJ3VzZSBjbGllbnQnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1Byb21pc2VUeXBlKHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuICh0eXBlQW5ub3RhdGlvbi50eXBlID09PSAnVFNUeXBlUmVmZXJlbmNlJyAmJlxuICAgICAgICB0eXBlQW5ub3RhdGlvbi50eXBlTmFtZS5uYW1lID09PSAnUHJvbWlzZScpO1xufVxuZnVuY3Rpb24gdHVybkZ1bmN0aW9uUmV0dXJuVHlwZVRvQXN5bmMobm9kZSwgaikge1xuICAgIGlmIChqLkZ1bmN0aW9uRGVjbGFyYXRpb24uY2hlY2sobm9kZSkgfHxcbiAgICAgICAgai5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2sobm9kZSkgfHxcbiAgICAgICAgai5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5UeXBlQW5ub3RhdGlvbiA9IG5vZGUucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGlzUmV0dXJuVHlwZVByb21pc2UgPSBpc1Byb21pc2VUeXBlKHJldHVyblR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIC8vIFR1cm4gPHJldHVybiB0eXBlPiB0byBQcm9taXNlPHJldHVybiB0eXBlPlxuICAgICAgICAgICAgLy8gZS5nLiAoKSA9PiB7IHNsdWc6IHN0cmluZyB9IHRvICgpID0+IFByb21pc2U8eyBzbHVnOiBzdHJpbmcgfT5cbiAgICAgICAgICAgIC8vIGUuZy4gQW55dGhpbmcgdG8gUHJvbWlzZTxBbnl0aGluZz5cbiAgICAgICAgICAgIGlmICghaXNSZXR1cm5UeXBlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnJldHVyblR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgai5UU1R5cGVBbm5vdGF0aW9uLmNoZWNrKG5vZGUucmV0dXJuVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGouVFNUeXBlUmVmZXJlbmNlLmNoZWNrKG5vZGUucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGouVFNVbmlvblR5cGUuY2hlY2sobm9kZS5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgai5UU1R5cGVQcmVkaWNhdGUuY2hlY2sobm9kZS5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSByZXR1cm4gdHlwZSB0byBQcm9taXNlPHZvaWQ+XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbiA9IGoudHNUeXBlUmVmZXJlbmNlKGouaWRlbnRpZmllcignUHJvbWlzZScpLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpZ25vcmUgdGhlIHN1cGVyIHN0cmljdCB0eXBlIGNoZWNraW5nIG9uIHRoZSB0eXBlIGFubm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgai50c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKFtyZXR1cm5UeXBlQW5ub3RhdGlvbl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnRSZWFjdFVzZUltcG9ydChyb290LCBqKSB7XG4gICAgY29uc3QgaGFzUmVhY3RVc2VJbXBvcnQgPSByb290XG4gICAgICAgIC5maW5kKGouSW1wb3J0U3BlY2lmaWVyLCB7XG4gICAgICAgIGltcG9ydGVkOiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiAndXNlJyxcbiAgICAgICAgfSxcbiAgICB9KVxuICAgICAgICAuc2l6ZSgpID4gMDtcbiAgICBpZiAoIWhhc1JlYWN0VXNlSW1wb3J0KSB7XG4gICAgICAgIGNvbnN0IHJlYWN0SW1wb3J0RGVjbGFyYXRpb24gPSByb290LmZpbmQoai5JbXBvcnREZWNsYXJhdGlvbiwge1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdyZWFjdCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gU2tpcCB0aGUgdHlwZSBvbmx5IHJlYWN0IGltcG9ydHNcbiAgICAgICAgICAgIGltcG9ydEtpbmQ6ICd2YWx1ZScsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVhY3RJbXBvcnREZWNsYXJhdGlvbi5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gcmVhY3RJbXBvcnREZWNsYXJhdGlvbi5nZXQoKS5ub2RlO1xuICAgICAgICAgICAgLy8gQWRkICd1c2UnIHRvIGV4aXN0aW5nICdyZWFjdCcgaW1wb3J0IGRlY2xhcmF0aW9uXG4gICAgICAgICAgICBpbXBvcnROb2RlLnNwZWNpZmllcnMucHVzaChqLmltcG9ydFNwZWNpZmllcihqLmlkZW50aWZpZXIoJ3VzZScpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhbGwgdHlwZSBpbXBvcnRzIHRvICdyZWFjdCdcbiAgICAgICAgICAgIGlmIChyZWFjdEltcG9ydERlY2xhcmF0aW9uLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICByZWFjdEltcG9ydERlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoKVxuICAgICAgICAgICAgICAgICAgICAubm9kZS5zcGVjaWZpZXJzLnB1c2goai5pbXBvcnRTcGVjaWZpZXIoai5pZGVudGlmaWVyKCd1c2UnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBpbXBvcnQgZGVjbGFyYXRpb24gZm9yICdyZWFjdCcgYW5kICd1c2UnXG4gICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICAgICAgICAuZ2V0KClcbiAgICAgICAgICAgICAgICAgICAgLm5vZGUucHJvZ3JhbS5ib2R5LnVuc2hpZnQoai5pbXBvcnREZWNsYXJhdGlvbihbai5pbXBvcnRTcGVjaWZpZXIoai5pZGVudGlmaWVyKCd1c2UnKSldLCBqLmxpdGVyYWwoJ3JlYWN0JykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTdWJTY29wZUFyZ3VtZW50SWRlbnRpZmllcihwYXRoLCBqLCBhcmdOYW1lKSB7XG4gICAgY29uc3QgZGVmQ291bnQgPSBqKHBhdGgpLmZpbmQoai5JZGVudGlmaWVyLCB7IG5hbWU6IGFyZ05hbWUgfSkuc2l6ZSgpO1xuICAgIHJldHVybiBkZWZDb3VudCA+IDA7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIoZGVmYXVsdElkTmFtZSwgcGF0aCwgaikge1xuICAgIGxldCBpZE5hbWUgPSBkZWZhdWx0SWROYW1lO1xuICAgIGxldCBpZE5hbWVTdWZmaXggPSAwO1xuICAgIHdoaWxlIChmaW5kU3ViU2NvcGVBcmd1bWVudElkZW50aWZpZXIocGF0aCwgaiwgaWROYW1lKSkge1xuICAgICAgICBpZE5hbWUgPSBkZWZhdWx0SWROYW1lICsgaWROYW1lU3VmZml4O1xuICAgICAgICBpZE5hbWVTdWZmaXgrKztcbiAgICB9XG4gICAgY29uc3QgcHJvcHNJZGVudGlmaWVyID0gai5pZGVudGlmaWVyKGlkTmFtZSk7XG4gICAgcmV0dXJuIHByb3BzSWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25TY29wZShwYXRoLCBqKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGgubm9kZTtcbiAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgZXhwcmVzc2lvbiwgb3IgYXJyb3cgZnVuY3Rpb24pXG4gICAgcmV0dXJuIChqLkZ1bmN0aW9uRGVjbGFyYXRpb24uY2hlY2sobm9kZSkgfHxcbiAgICAgICAgai5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2sobm9kZSkgfHxcbiAgICAgICAgai5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhub2RlKSk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2V0UGFyZW50RnVuY3Rpb25TY29wZShwYXRoLCBqKSB7XG4gICAgaWYgKCFwYXRoLnNjb3BlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcGFyZW50RnVuY3Rpb25QYXRoID0gcGF0aC5zY29wZS5wYXRoO1xuICAgIHdoaWxlIChwYXJlbnRGdW5jdGlvblBhdGggJiYgIWlzRnVuY3Rpb25TY29wZShwYXJlbnRGdW5jdGlvblBhdGgsIGopKSB7XG4gICAgICAgIHBhcmVudEZ1bmN0aW9uUGF0aCA9IHBhcmVudEZ1bmN0aW9uUGF0aC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRGdW5jdGlvblBhdGg7XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5vZGVGcm9tQmluZGluZyhiaW5kaW5nUGF0aCwgaWROYW1lLCBqLCByb290KSB7XG4gICAgY29uc3QgYmluZGluZ05vZGUgPSBiaW5kaW5nUGF0aC5ub2RlO1xuICAgIGlmIChqLkZ1bmN0aW9uRGVjbGFyYXRpb24uY2hlY2soYmluZGluZ05vZGUpIHx8XG4gICAgICAgIGouRnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGJpbmRpbmdOb2RlKSB8fFxuICAgICAgICBqLkFycm93RnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGJpbmRpbmdOb2RlKSkge1xuICAgICAgICByZXR1cm4gYmluZGluZ1BhdGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGouVmFyaWFibGVEZWNsYXJhdG9yLmNoZWNrKGJpbmRpbmdOb2RlKSkge1xuICAgICAgICBjb25zdCBpbml0ID0gYmluZGluZ05vZGUuaW5pdDtcbiAgICAgICAgLy8gSWYgdGhlIGluaXRpYWxpemVyIGlzIGEgZnVuY3Rpb24gKGFycm93IG9yIGZ1bmN0aW9uIGV4cHJlc3Npb24pLCByZWNvcmQgaXRcbiAgICAgICAgaWYgKGouRnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGluaXQpIHx8XG4gICAgICAgICAgICBqLkFycm93RnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGluaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZ1BhdGguZ2V0KCdpbml0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoai5JZGVudGlmaWVyLmNoZWNrKGJpbmRpbmdOb2RlKSkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZVBhdGggPSByb290LmZpbmQoai5WYXJpYWJsZURlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICAvLyBkZWNsYXJhdGlvbnMsIGVhY2ggaXMgVmFyaWFibGVEZWNsYXJhdG9yXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlRGVjbGFyYXRvclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWQgaXMgSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaWROYW1lLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhcmlhYmxlUGF0aC5zaXplKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlRGVjbGFyYXRvciA9IHZhcmlhYmxlUGF0aC5nZXQoKT8ubm9kZT8uZGVjbGFyYXRpb25zPy5bMF07XG4gICAgICAgICAgICBpZiAoai5WYXJpYWJsZURlY2xhcmF0b3IuY2hlY2sodmFyaWFibGVEZWNsYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSB2YXJpYWJsZURlY2xhcmF0b3IuaW5pdDtcbiAgICAgICAgICAgICAgICBpZiAoai5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2soaW5pdCkgfHxcbiAgICAgICAgICAgICAgICAgICAgai5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhpbml0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVQYXRoLmdldCgnZGVjbGFyYXRpb25zJywgMCwgJ2luaXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSByb290LmZpbmQoai5GdW5jdGlvbkRlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IGlkTmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbnMuc2l6ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvbnMuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uUGF0aEZyb21FeHBvcnRQYXRoKGV4cG9ydFBhdGgsIGosIHJvb3QsIG5hbWVkRXhwb3J0RmlsdGVyKSB7XG4gICAgLy8gRGVmYXVsdCBleHBvcnRcbiAgICBpZiAoai5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24uY2hlY2soZXhwb3J0UGF0aC5ub2RlKSkge1xuICAgICAgICBjb25zdCB7IGRlY2xhcmF0aW9uIH0gPSBleHBvcnRQYXRoLm5vZGU7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKGouRnVuY3Rpb25EZWNsYXJhdGlvbi5jaGVjayhkZWNsYXJhdGlvbikgfHxcbiAgICAgICAgICAgICAgICBqLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhkZWNsYXJhdGlvbikgfHxcbiAgICAgICAgICAgICAgICBqLkFycm93RnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGRlY2xhcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRQYXRoLmdldCgnZGVjbGFyYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGouSWRlbnRpZmllci5jaGVjayhkZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZE5hbWUgPSBkZWNsYXJhdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZWRFeHBvcnRGaWx0ZXIoaWROYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydEJpbmRpbmcgPSBleHBvcnRQYXRoLnNjb3BlLmdldEJpbmRpbmdzKClbaWROYW1lXT8uWzBdO1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRGdW5jdGlvbk5vZGVGcm9tQmluZGluZyhleHBvcnRCaW5kaW5nLCBpZE5hbWUsIGosIHJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvLyBOYW1lZCBleHBvcnRzXG4gICAgai5FeHBvcnROYW1lZERlY2xhcmF0aW9uLmNoZWNrKGV4cG9ydFBhdGgubm9kZSkpIHtcbiAgICAgICAgY29uc3QgbmFtZWRFeHBvcnRQYXRoID0gZXhwb3J0UGF0aDtcbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgbmFtZWQgZXhwb3J0cywgbmFtZSBzcGVjaWZpZXJzLCBhbmQgZGVmYXVsdCBzcGVjaWZpZXJzXG4gICAgICAgIGNvbnN0IHsgZGVjbGFyYXRpb24sIHNwZWNpZmllcnMgfSA9IG5hbWVkRXhwb3J0UGF0aC5ub2RlO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChqLlZhcmlhYmxlRGVjbGFyYXRpb24uY2hlY2soZGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IGRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGouVmFyaWFibGVEZWNsYXJhdG9yLmNoZWNrKGRlY2wpICYmIGouSWRlbnRpZmllci5jaGVjayhkZWNsLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWROYW1lID0gZGVjbC5pZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lZEV4cG9ydEZpbHRlcihpZE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBiaW5kaW5ncyBmb3IgZWFjaCB2YXJpYWJsZSBkZWNsYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRCaW5kaW5nID0gbmFtZWRFeHBvcnRQYXRoLnNjb3BlLmdldEJpbmRpbmdzKClbaWROYW1lXT8uWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydEJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RnVuY3Rpb25Ob2RlRnJvbUJpbmRpbmcoZXhwb3J0QmluZGluZywgaWROYW1lLCBqLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGouRnVuY3Rpb25EZWNsYXJhdGlvbi5jaGVjayhkZWNsYXJhdGlvbikgfHxcbiAgICAgICAgICAgICAgICBqLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhkZWNsYXJhdGlvbikgfHxcbiAgICAgICAgICAgICAgICBqLkFycm93RnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKGRlY2xhcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gZGVjbGFyYXRpb24uaWQ/Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lZEV4cG9ydEZpbHRlcihmdW5jTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZWRFeHBvcnRQYXRoLmdldCgnZGVjbGFyYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlY2lmaWVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2Ygc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChqLkV4cG9ydFNwZWNpZmllci5jaGVjayhzcGVjaWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkTmFtZSA9IHNwZWNpZmllci5sb2NhbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWVkRXhwb3J0RmlsdGVyKGlkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydEJpbmRpbmcgPSBuYW1lZEV4cG9ydFBhdGguc2NvcGUuZ2V0QmluZGluZ3MoKVtpZE5hbWVdPy5bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RnVuY3Rpb25Ob2RlRnJvbUJpbmRpbmcoZXhwb3J0QmluZGluZywgaWROYW1lLCBqLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gd3JhcFBhcmVudGhlc2VJZk5lZWRlZChoYXNDaGFpbkFjY2VzcywgaiwgZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBoYXNDaGFpbkFjY2VzcyA/IGoucGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcmVzc2lvbikgOiBleHByZXNzaW9uO1xufVxuZnVuY3Rpb24gZXhpc3RzQ29tbWVudChjb21tZW50cywgY29tbWVudCkge1xuICAgIGNvbnN0IGlzQ29kZW1vZEVycm9yQ29tbWVudCA9IGNvbW1lbnRcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3RhcnRzV2l0aChleHBvcnRzLk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVgpO1xuICAgIGxldCBoYXNJZ25vcmVDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGhhc0NvbW1lbnQgPSBmYWxzZTtcbiAgICBpZiAoY29tbWVudHMpIHtcbiAgICAgICAgY29tbWVudHMuZm9yRWFjaCgoY29tbWVudE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb21tZW50ID0gY29tbWVudE5vZGUudmFsdWU7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbW1lbnQudHJpbSgpLnN0YXJ0c1dpdGgoTkVYVF9DT0RFTU9EX0lHTk9SRV9FUlJPUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgaGFzSWdub3JlQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbW1lbnQgPT09IGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBoYXNDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIGl0J3MgaW5zZXJ0aW5nIGNvZGVtb2QgZXJyb3IgY29tbWVudCxcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgQG5leHQtY29kZW1vZC1pZ25vcmUgY29tbWVudC5cbiAgICAgICAgLy8gaWYgaWdub3JlIGNvbW1lbnQgZXhpc3RzLCBieXBhc3MgdGhlIGNvbW1lbnQgaW5zZXJ0aW9uLlxuICAgICAgICBpZiAoaGFzSWdub3JlQ29tbWVudCAmJiBpc0NvZGVtb2RFcnJvckNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnNlcnRDb21tZW50T25jZShub2RlLCBqLCBjb21tZW50KSB7XG4gICAgY29uc3QgaGFzQ29tbWVudEluSW5saW5lQ29tbWVudHMgPSBleGlzdHNDb21tZW50KG5vZGUuY29tbWVudHMsIGNvbW1lbnQpO1xuICAgIGNvbnN0IGhhc0NvbW1lbnRJbkxlYWRpbmdDb21tZW50cyA9IGV4aXN0c0NvbW1lbnQobm9kZS5sZWFkaW5nQ29tbWVudHMsIGNvbW1lbnQpO1xuICAgIGlmICghaGFzQ29tbWVudEluSW5saW5lQ29tbWVudHMgJiYgIWhhc0NvbW1lbnRJbkxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAvLyBBbHdheXMgaW5zZXJ0IGludG8gaW5saW5lIGNvbW1lbnRcbiAgICAgICAgbm9kZS5jb21tZW50cyA9IFtqLmNvbW1lbnRCbG9jayhjb21tZW50KSwgLi4uKG5vZGUuY29tbWVudHMgfHwgW10pXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFZhcmlhYmxlRGVjbGFyYXRvcklkKHBhdGgsIGopIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnBhcmVudFBhdGg7XG4gICAgaWYgKGouVmFyaWFibGVEZWNsYXJhdG9yLmNoZWNrKHBhcmVudC5ub2RlKSkge1xuICAgICAgICBjb25zdCBpZCA9IHBhcmVudC5ub2RlLmlkO1xuICAgICAgICBpZiAoai5JZGVudGlmaWVyLmNoZWNrKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBmaW5kRnVuY3Rpb25Cb2R5KHBhdGgpIHtcbiAgICBsZXQgZnVuY3Rpb25Cb2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgaWYgKGZ1bmN0aW9uQm9keSAmJiBmdW5jdGlvbkJvZHkudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25Cb2R5LmJvZHk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNQYXNjYWxDYXNlID0gKHMpID0+IC9eW0EtWl1bYS16MC05XSokLy50ZXN0KHMpO1xuY29uc3QgaXNSZWFjdEhvb2tOYW1lID0gKG5hbWUpID0+IFxuLy8gZnVuY3Rpb24gbmFtZSBpcyBgdXNlYFxubmFtZSA9PT0gJ3VzZScgfHxcbiAgICAvLyBmdW5jdGlvbiBuYW1lIGlzIGB1c2VYKmBcbiAgICAobmFtZS5zdGFydHNXaXRoKCd1c2UnKSAmJiBuYW1lWzNdID09PSBuYW1lWzNdLnRvVXBwZXJDYXNlKCkpO1xuZXhwb3J0cy5pc1JlYWN0SG9va05hbWUgPSBpc1JlYWN0SG9va05hbWU7XG4vLyBEZXRlcm1pbmUgYSBwYXRoIG9mIGZ1bmN0aW9uIGNvbnRhaW5zIGFueSBSZWFjdCBob29rcyBjYWxsIGV4cHJlc3Npb25zLlxuLy8gZS5nLiBpZiB0aGVyZSdzIGFueSBvZiB0aG9zZSBjYWxsIGV4cHJlc3Npb25zIGluIHRoZSBmdW5jdGlvbiBib2R5OlxuLy8gdXNlKCkgPT4gdHJ1ZVxuLy8gUmVhY3QudXNlKCkgPT4gZmFsc2Vcbi8vIHVzZVh4eHgoKSA9PiB0cnVlXG4vLyBGb28udXNlKCkgPT4gdHJ1ZVxuLy8gRm9vLnVzZVh4eHgoKSA9PiB0cnVlXG5mdW5jdGlvbiBjb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnMocGF0aCwgaikge1xuICAgIGNvbnN0IGhhc1JlYWN0SG9va3MgPSBqKHBhdGgpXG4gICAgICAgIC5maW5kKGouQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgIC5maWx0ZXIoKGNhbGxQYXRoKSA9PiB7XG4gICAgICAgIC8vIEl0J3MgbWF0Y2hpbmc6XG4gICAgICAgIC8vIC0gdXNlKDxjYWxsUGF0aD4pID0+IHRydWVcbiAgICAgICAgLy8gLSB1c2VYKig8Y2FsbFBhdGg+KSA9PiB0cnVlXG4gICAgICAgIGNvbnN0IGlzVXNlSG9va09yUmVhY3RIb29rQ2FsbCA9IGouSWRlbnRpZmllci5jaGVjayhjYWxsUGF0aC52YWx1ZS5jYWxsZWUpICYmXG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5pc1JlYWN0SG9va05hbWUpKGNhbGxQYXRoLnZhbHVlLmNhbGxlZS5uYW1lKTtcbiAgICAgICAgLy8gSXQncyBtYXRjaGluZyBtZW1iZXIgYWNjZXNzOlxuICAgICAgICAvLyAtIFJlYWN0LnVzZSg8Y2FsbFBhdGg+KSA9PiB0cnVlXG4gICAgICAgIC8vIC0gRm9vLnVzZUZvbyg8Y2FsbFBhdGg+KSA9PiB0cnVlXG4gICAgICAgIC8vIC0gZm9vLnVzZUZvbyg8Y2FsbFBhdGg+KSA9PiBmYWxzZVxuICAgICAgICAvLyAtIGZvby51c2UoPGNhbGxQYXRoPikgPT4gZmFsc2VcbiAgICAgICAgY29uc3QgaXNSZWFjdFVzZUNhbGwgPSBqLk1lbWJlckV4cHJlc3Npb24uY2hlY2soY2FsbFBhdGgudmFsdWUuY2FsbGVlKSAmJlxuICAgICAgICAgICAgai5JZGVudGlmaWVyLmNoZWNrKGNhbGxQYXRoLnZhbHVlLmNhbGxlZS5vYmplY3QpICYmXG4gICAgICAgICAgICBqLklkZW50aWZpZXIuY2hlY2soY2FsbFBhdGgudmFsdWUuY2FsbGVlLnByb3BlcnR5KSAmJlxuICAgICAgICAgICAgaXNQYXNjYWxDYXNlKGNhbGxQYXRoLnZhbHVlLmNhbGxlZS5vYmplY3QubmFtZSkgJiZcbiAgICAgICAgICAgICgwLCBleHBvcnRzLmlzUmVhY3RIb29rTmFtZSkoY2FsbFBhdGgudmFsdWUuY2FsbGVlLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICByZXR1cm4gaXNVc2VIb29rT3JSZWFjdEhvb2tDYWxsIHx8IGlzUmVhY3RVc2VDYWxsO1xuICAgIH0pXG4gICAgICAgIC5zaXplKCkgPiAwO1xuICAgIHJldHVybiBoYXNSZWFjdEhvb2tzO1xufVxuLy8gQ2FwdHVyZSB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50IHBhdGggaXMgd3JhcHBlZCBieSBgdXNlKClgIGNhbGwgZXhwcmVzc2lvblxuLy8gZS5nLlxuLy8gdXNlKDxwYXRoPikgPT4gdHJ1ZVxuLy8gdXNlMig8cGF0aD4pID0+IGZhbHNlXG4vLyBSZWFjdC51c2UoPHBhdGg+KSA9PiB0cnVlXG4vLyBSb2J1c3QudXNlKDxwYXRoPikgPT4gZmFsc2VcbmZ1bmN0aW9uIGlzUGFyZW50VXNlQ2FsbEV4cHJlc3Npb24ocGF0aCwgaikge1xuICAgIGNvbnN0IGlzUGFyZW50VXNlQ2FsbCA9IFxuICAgIC8vIG1lbWJlciBhY2Nlc3MgcGFyZW50UGF0aCBpcyBhcmd1bWVudFxuICAgIGouQ2FsbEV4cHJlc3Npb24uY2hlY2socGF0aC5wYXJlbnQudmFsdWUpICYmXG4gICAgICAgIC8vIG1lbWJlciBhY2Nlc3MgaXMgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgcGF0aC5wYXJlbnQudmFsdWUuYXJndW1lbnRzWzBdID09PSBwYXRoLnZhbHVlICYmXG4gICAgICAgIHBhdGgucGFyZW50LnZhbHVlLmFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgLy8gZnVuY3Rpb24gbmFtZSBpcyBgdXNlYFxuICAgICAgICBqLklkZW50aWZpZXIuY2hlY2socGF0aC5wYXJlbnQudmFsdWUuY2FsbGVlKSAmJlxuICAgICAgICBwYXRoLnBhcmVudC52YWx1ZS5jYWxsZWUubmFtZSA9PT0gJ3VzZSc7XG4gICAgY29uc3QgaXNQYXJlbnRSZWFjdFVzZUNhbGwgPSBcbiAgICAvLyBtZW1iZXIgYWNjZXNzIHBhcmVudFBhdGggaXMgYXJndW1lbnRcbiAgICBqLkNhbGxFeHByZXNzaW9uLmNoZWNrKHBhdGgucGFyZW50LnZhbHVlKSAmJlxuICAgICAgICAvLyBtZW1iZXIgYWNjZXNzIGlzIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgIHBhdGgucGFyZW50LnZhbHVlLmFyZ3VtZW50c1swXSA9PT0gcGF0aC52YWx1ZSAmJlxuICAgICAgICBwYXRoLnBhcmVudC52YWx1ZS5hcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIC8vIGZ1bmN0aW9uIG5hbWUgaXMgYHVzZWBcbiAgICAgICAgai5NZW1iZXJFeHByZXNzaW9uLmNoZWNrKHBhdGgucGFyZW50LnZhbHVlLmNhbGxlZSkgJiZcbiAgICAgICAgai5JZGVudGlmaWVyLmNoZWNrKHBhdGgucGFyZW50LnZhbHVlLmNhbGxlZS5vYmplY3QpICYmXG4gICAgICAgIHBhdGgucGFyZW50LnZhbHVlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ1JlYWN0JyAmJlxuICAgICAgICBqLklkZW50aWZpZXIuY2hlY2socGF0aC5wYXJlbnQudmFsdWUuY2FsbGVlLnByb3BlcnR5KSAmJlxuICAgICAgICBwYXRoLnBhcmVudC52YWx1ZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ3VzZSc7XG4gICAgcmV0dXJuIGlzUGFyZW50VXNlQ2FsbCB8fCBpc1BhcmVudFJlYWN0VXNlQ2FsbDtcbn1cbi8vIERldGVybWluZSBpZiBhIHBhdGggaXMgd3JhcHBlZCBieSBgUHJvbWlzZS5hbGwoKWBcbi8vIGUuZy5cbi8vIFByb21pc2UuYWxsKDxwYXRoPikgPT4gdHJ1ZVxuLy8gUHJvbWlzZS5hbGxTZXR0bGVkKDxwYXRoPikgPT4gZmFsc2VcbmZ1bmN0aW9uIGlzUGFyZW50UHJvbWlzZUFsbENhbGxFeHByZXNzaW9uKHBhdGgsIGopIHtcbiAgICBjb25zdCBhcmdzUGFyZW50ID0gcGF0aC5wYXJlbnQ7XG4gICAgY29uc3QgY2FsbFBhcmVudCA9IGFyZ3NQYXJlbnQ/LnBhcmVudDtcbiAgICBpZiAoYXJnc1BhcmVudCAmJlxuICAgICAgICBjYWxsUGFyZW50ICYmXG4gICAgICAgIGouQXJyYXlFeHByZXNzaW9uLmNoZWNrKGFyZ3NQYXJlbnQudmFsdWUpICYmXG4gICAgICAgIGouQ2FsbEV4cHJlc3Npb24uY2hlY2soY2FsbFBhcmVudC52YWx1ZSkgJiZcbiAgICAgICAgai5NZW1iZXJFeHByZXNzaW9uLmNoZWNrKGNhbGxQYXJlbnQudmFsdWUuY2FsbGVlKSAmJlxuICAgICAgICBqLklkZW50aWZpZXIuY2hlY2soY2FsbFBhcmVudC52YWx1ZS5jYWxsZWUub2JqZWN0KSAmJlxuICAgICAgICBjYWxsUGFyZW50LnZhbHVlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgIGouSWRlbnRpZmllci5jaGVjayhjYWxsUGFyZW50LnZhbHVlLmNhbGxlZS5wcm9wZXJ0eSkgJiZcbiAgICAgICAgY2FsbFBhcmVudC52YWx1ZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFDWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFBRUMsS0FBSyxFQUFFO0FBQUssQ0FBQyxDQUFDO0FBQzdERCxPQUFPLENBQUNFLGVBQWUsR0FBR0YsT0FBTyxDQUFDRyxpQkFBaUIsR0FBR0gsT0FBTyxDQUFDSSxvQkFBb0IsR0FBR0osT0FBTyxDQUFDSyxvQkFBb0IsR0FBR0wsT0FBTyxDQUFDTSx5QkFBeUIsR0FBR04sT0FBTyxDQUFD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QUNxRSxNQUFNLENBQUNoRyxLQUFLLENBQUNzSixNQUFNLENBQUNHLE1BQU0sQ0FBQ3BILElBQUksS0FBSyxPQUFPLElBQ2hEVCxDQUFDLENBQUM4RCxVQUFVLENBQUNqQyxLQUFLLENBQUM5QixJQUFJLENBQUNxRSxNQUFNLENBQUNoRyxLQUFLLENBQUNzSixNQUFNLENBQUNJLFFBQVEsQ0FBQyxJQUNyRC9ILElBQUksQ0FBQ3FFLE1BQU0sQ0FBQ2hHLEtBQUssQ0FBQ3NKLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDckgsSUFBSSxLQUFLLEtBQUs7RUFDcEQsT0FBT3NILGVBQWUsSUFBSUcsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTdkksZ0NBQWdDQSxDQUFDSSxJQUFJLEVBQUVDLENBQUMsRUFBRTtFQUMvQyxNQUFNbUksVUFBVSxHQUFHcEksSUFBSSxDQUFDcUUsTUFBTTtFQUM5QixNQUFNZ0UsVUFBVSxHQUFHRCxVQUFVLGFBQVZBLFVBQVUsdUJBQVZBLFVBQVUsQ0FBRS9ELE1BQU07RUFDckMsSUFBSStELFVBQVUsSUFDVkMsVUFBVSxJQUNWcEksQ0FBQyxDQUFDcUksZUFBZSxDQUFDeEcsS0FBSyxDQUFDc0csVUFBVSxDQUFDL0osS0FBSyxDQUFDLElBQ3pDNEIsQ0FBQyxDQUFDc0gsY0FBYyxDQUFDekYsS0FBSyxDQUFDdUcsVUFBVSxDQUFDaEssS0FBSyxDQUFDLElBQ3hDNEIsQ0FBQyxDQUFDNEgsZ0JBQWdCLENBQUMvRixLQUFLLENBQUN1RyxVQUFVLENBQUNoSyxLQUFLLENBQUNzSixNQUFNLENBQUMsSUFDakQxSCxDQUFDLENBQUM4RCxVQUFVLENBQUNqQyxLQUFLLENBQUN1RyxVQUFVLENBQUNoSyxLQUFLLENBQUNzSixNQUFNLENBQUNHLE1BQU0sQ0FBQyxJQUNsRE8sVUFBVSxDQUFDaEssS0FBSyxDQUFDc0osTUFBTSxDQUFDRyxNQUFNLENBQUNwSCxJQUFJLEtBQUssU0FBUyxJQUNqRFQsQ0FBQyxDQUFDOEQsVUFBVSxDQUFDakMsS0FBSyxDQUFDdUcsVUFBVSxDQUFDaEssS0FBSyxDQUFDc0osTUFBTSxDQUFDSSxRQUFRLENBQUMsSUFDcERNLFVBQVUsQ0FBQ2hLLEtBQUssQ0FBQ3NKLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDckgsSUFBSSxLQUFLLEtBQUssRUFBRTtJQUNqRCxPQUFPLElBQUk7RUFDZjtFQUNBLE9BQU8sS0FBSztBQUNoQiIsImlnbm9yZUxpc3QiOltdfQ==","map":{"version":3,"names":["Object","defineProperty","exports","value","isReactHookName","TARGET_PROP_NAMES","TARGET_NAMED_EXPORTS","TARGET_ROUTE_EXPORTS","NEXT_CODEMOD_ERROR_PREFIX","NEXTJS_ENTRY_FILES","isFunctionType","isMatchedFunctionExported","determineClientDirective","isPromiseType","turnFunctionReturnTypeToAsync","insertReactUseImport","generateUniqueIdentifier","isFunctionScope","findClosetParentFunctionScope","getFunctionPathFromExportPath","wrapParentheseIfNeeded","insertCommentOnce","getVariableDeclaratorId","findFunctionBody","containsReactHooksCallExpressions","isParentUseCallExpression","isParentPromiseAllCallExpression","NEXT_CODEMOD_IGNORE_ERROR_PREFIX","Set","type","path","j","matchedFunctionNameFilter","idName","has","directNamedExport","closest","ExportNamedDeclaration","declaration","id","name","size","isDefaultExport","ExportDefaultDeclaration","root","closestScope","Program","isNamedExport","find","specifiers","exported","isVariableExport","declarations","init","program","get","node","directive","directives","Directive","check","typeAnnotation","typeName","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","returnType","returnTypeAnnotation","isReturnTypePromise","TSTypeAnnotation","TSTypeReference","TSUnionType","TSTypePredicate","tsTypeReference","identifier","tsTypeParameterInstantiation","hasReactUseImport","ImportSpecifier","imported","reactImportDeclaration","ImportDeclaration","source","importKind","importNode","push","importSpecifier","body","unshift","importDeclaration","literal","findSubScopeArgumentIdentifier","argName","defCount","Identifier","defaultIdName","idNameSuffix","propsIdentifier","scope","parentFunctionPath","parent","getFunctionNodeFromBinding","bindingPath","bindingNode","VariableDeclarator","variablePath","VariableDeclaration","_variablePath$get","variableDeclarator","functionDeclarations","undefined","exportPath","namedExportFilter","_exportPath$scope$get","exportBinding","getBindings","namedExportPath","decl","_namedExportPath$scop","_declaration$id","funcName","specifier","ExportSpecifier","_namedExportPath$scop2","local","hasChainAccess","expression","parenthesizedExpression","existsComment","comments","comment","isCodemodErrorComment","trim","startsWith","hasIgnoreComment","hasComment","forEach","commentNode","currentComment","hasCommentInInlineComments","hasCommentInLeadingComments","leadingComments","commentBlock","parentPath","functionBody","isPascalCase","s","test","toUpperCase","hasReactHooks","CallExpression","filter","callPath","isUseHookOrReactHookCall","callee","isReactUseCall","MemberExpression","object","property","isParentUseCall","arguments","length","isParentReactUseCall","argsParent","callParent","ArrayExpression"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/","sources":["utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isReactHookName = exports.TARGET_PROP_NAMES = exports.TARGET_NAMED_EXPORTS = exports.TARGET_ROUTE_EXPORTS = exports.NEXT_CODEMOD_ERROR_PREFIX = exports.NEXTJS_ENTRY_FILES = void 0;\nexports.isFunctionType = isFunctionType;\nexports.isMatchedFunctionExported = isMatchedFunctionExported;\nexports.determineClientDirective = determineClientDirective;\nexports.isPromiseType = isPromiseType;\nexports.turnFunctionReturnTypeToAsync = turnFunctionReturnTypeToAsync;\nexports.insertReactUseImport = insertReactUseImport;\nexports.generateUniqueIdentifier = generateUniqueIdentifier;\nexports.isFunctionScope = isFunctionScope;\nexports.findClosetParentFunctionScope = findClosetParentFunctionScope;\nexports.getFunctionPathFromExportPath = getFunctionPathFromExportPath;\nexports.wrapParentheseIfNeeded = wrapParentheseIfNeeded;\nexports.insertCommentOnce = insertCommentOnce;\nexports.getVariableDeclaratorId = getVariableDeclaratorId;\nexports.findFunctionBody = findFunctionBody;\nexports.containsReactHooksCallExpressions = containsReactHooksCallExpressions;\nexports.isParentUseCallExpression = isParentUseCallExpression;\nexports.isParentPromiseAllCallExpression = isParentPromiseAllCallExpression;\nexports.NEXTJS_ENTRY_FILES = /([\\\\/]|^)(page|layout|route|default)\\.(t|j)sx?$/;\nexports.NEXT_CODEMOD_ERROR_PREFIX = '@next-codemod-error';\nconst NEXT_CODEMOD_IGNORE_ERROR_PREFIX = '@next-codemod-ignore';\nexports.TARGET_ROUTE_EXPORTS = new Set([\n    'GET',\n    'POST',\n    'PUT',\n    'PATCH',\n    'DELETE',\n    'OPTIONS',\n    'HEAD',\n]);\nexports.TARGET_NAMED_EXPORTS = new Set([\n    // For page and layout\n    'generateMetadata',\n    'generateViewport',\n    ...exports.TARGET_ROUTE_EXPORTS,\n]);\nexports.TARGET_PROP_NAMES = new Set(['params', 'searchParams']);\nfunction isFunctionType(type) {\n    return (type === 'FunctionDeclaration' ||\n        type === 'FunctionExpression' ||\n        type === 'ArrowFunctionExpression');\n}\nfunction isMatchedFunctionExported(path, j) {\n    const matchedFunctionNameFilter = (idName) => exports.TARGET_NAMED_EXPORTS.has(idName);\n    const directNamedExport = j(path).closest(j.ExportNamedDeclaration, {\n        declaration: {\n            type: 'FunctionDeclaration',\n            id: {\n                name: matchedFunctionNameFilter,\n            },\n        },\n    });\n    if (directNamedExport.size() > 0) {\n        return true;\n    }\n    // Check for default export (`export default function() {}`)\n    const isDefaultExport = j(path).closest(j.ExportDefaultDeclaration).size() > 0;\n    if (isDefaultExport) {\n        return true;\n    }\n    // Look for named export elsewhere in the file (`export { <named> }`)\n    const root = j(path).closestScope().closest(j.Program);\n    const isNamedExport = root\n        .find(j.ExportNamedDeclaration, {\n        specifiers: [\n            {\n                type: 'ExportSpecifier',\n                exported: {\n                    name: matchedFunctionNameFilter,\n                },\n            },\n        ],\n    })\n        .size() > 0;\n    // Look for variable export but still function, e.g. `export const <named> = function() {}`,\n    // also check if variable is a function or arrow function\n    const isVariableExport = root\n        .find(j.ExportNamedDeclaration, {\n        declaration: {\n            declarations: [\n                {\n                    type: 'VariableDeclarator',\n                    id: {\n                        type: 'Identifier',\n                        name: matchedFunctionNameFilter,\n                    },\n                    init: {\n                        type: isFunctionType,\n                    },\n                },\n            ],\n        },\n    })\n        .size() > 0;\n    if (isVariableExport)\n        return true;\n    return isNamedExport;\n}\n// directive is not parsed into AST, so we need to manually find it\n// by going through the tokens. Use the 1st string token as the directive\nfunction determineClientDirective(root, j) {\n    const { program } = root.get().node;\n    const directive = program.directives[0];\n    if (j.Directive.check(directive)) {\n        return directive.value.value === 'use client';\n    }\n    return false;\n}\nfunction isPromiseType(typeAnnotation) {\n    return (typeAnnotation.type === 'TSTypeReference' &&\n        typeAnnotation.typeName.name === 'Promise');\n}\nfunction turnFunctionReturnTypeToAsync(node, j) {\n    if (j.FunctionDeclaration.check(node) ||\n        j.FunctionExpression.check(node) ||\n        j.ArrowFunctionExpression.check(node)) {\n        if (node.returnType) {\n            const returnTypeAnnotation = node.returnType.typeAnnotation;\n            const isReturnTypePromise = isPromiseType(returnTypeAnnotation);\n            // Turn <return type> to Promise<return type>\n            // e.g. () => { slug: string } to () => Promise<{ slug: string }>\n            // e.g. Anything to Promise<Anything>\n            if (!isReturnTypePromise) {\n                if (node.returnType &&\n                    j.TSTypeAnnotation.check(node.returnType) &&\n                    (j.TSTypeReference.check(node.returnType.typeAnnotation) ||\n                        j.TSUnionType.check(node.returnType.typeAnnotation) ||\n                        j.TSTypePredicate.check(node.returnType.typeAnnotation))) {\n                    // Change the return type to Promise<void>\n                    node.returnType.typeAnnotation = j.tsTypeReference(j.identifier('Promise'), \n                    // @ts-ignore ignore the super strict type checking on the type annotation\n                    j.tsTypeParameterInstantiation([returnTypeAnnotation]));\n                }\n            }\n        }\n    }\n}\nfunction insertReactUseImport(root, j) {\n    const hasReactUseImport = root\n        .find(j.ImportSpecifier, {\n        imported: {\n            type: 'Identifier',\n            name: 'use',\n        },\n    })\n        .size() > 0;\n    if (!hasReactUseImport) {\n        const reactImportDeclaration = root.find(j.ImportDeclaration, {\n            source: {\n                value: 'react',\n            },\n            // Skip the type only react imports\n            importKind: 'value',\n        });\n        if (reactImportDeclaration.size() > 0) {\n            const importNode = reactImportDeclaration.get().node;\n            // Add 'use' to existing 'react' import declaration\n            importNode.specifiers.push(j.importSpecifier(j.identifier('use')));\n        }\n        else {\n            // Final all type imports to 'react'\n            if (reactImportDeclaration.size() > 0) {\n                reactImportDeclaration\n                    .get()\n                    .node.specifiers.push(j.importSpecifier(j.identifier('use')));\n            }\n            else {\n                // Add new import declaration for 'react' and 'use'\n                root\n                    .get()\n                    .node.program.body.unshift(j.importDeclaration([j.importSpecifier(j.identifier('use'))], j.literal('react')));\n            }\n        }\n    }\n}\nfunction findSubScopeArgumentIdentifier(path, j, argName) {\n    const defCount = j(path).find(j.Identifier, { name: argName }).size();\n    return defCount > 0;\n}\nfunction generateUniqueIdentifier(defaultIdName, path, j) {\n    let idName = defaultIdName;\n    let idNameSuffix = 0;\n    while (findSubScopeArgumentIdentifier(path, j, idName)) {\n        idName = defaultIdName + idNameSuffix;\n        idNameSuffix++;\n    }\n    const propsIdentifier = j.identifier(idName);\n    return propsIdentifier;\n}\nfunction isFunctionScope(path, j) {\n    if (!path)\n        return false;\n    const node = path.node;\n    // Check if the node is a function (declaration, expression, or arrow function)\n    return (j.FunctionDeclaration.check(node) ||\n        j.FunctionExpression.check(node) ||\n        j.ArrowFunctionExpression.check(node));\n}\nfunction findClosetParentFunctionScope(path, j) {\n    if (!path.scope)\n        return null;\n    let parentFunctionPath = path.scope.path;\n    while (parentFunctionPath && !isFunctionScope(parentFunctionPath, j)) {\n        parentFunctionPath = parentFunctionPath.parent;\n    }\n    return parentFunctionPath;\n}\nfunction getFunctionNodeFromBinding(bindingPath, idName, j, root) {\n    const bindingNode = bindingPath.node;\n    if (j.FunctionDeclaration.check(bindingNode) ||\n        j.FunctionExpression.check(bindingNode) ||\n        j.ArrowFunctionExpression.check(bindingNode)) {\n        return bindingPath;\n    }\n    else if (j.VariableDeclarator.check(bindingNode)) {\n        const init = bindingNode.init;\n        // If the initializer is a function (arrow or function expression), record it\n        if (j.FunctionExpression.check(init) ||\n            j.ArrowFunctionExpression.check(init)) {\n            return bindingPath.get('init');\n        }\n    }\n    else if (j.Identifier.check(bindingNode)) {\n        const variablePath = root.find(j.VariableDeclaration, {\n            // declarations, each is VariableDeclarator\n            declarations: [\n                {\n                    // VariableDeclarator\n                    type: 'VariableDeclarator',\n                    // id is Identifier\n                    id: {\n                        type: 'Identifier',\n                        name: idName,\n                    },\n                },\n            ],\n        });\n        if (variablePath.size()) {\n            const variableDeclarator = variablePath.get()?.node?.declarations?.[0];\n            if (j.VariableDeclarator.check(variableDeclarator)) {\n                const init = variableDeclarator.init;\n                if (j.FunctionExpression.check(init) ||\n                    j.ArrowFunctionExpression.check(init)) {\n                    return variablePath.get('declarations', 0, 'init');\n                }\n            }\n        }\n        const functionDeclarations = root.find(j.FunctionDeclaration, {\n            id: {\n                name: idName,\n            },\n        });\n        if (functionDeclarations.size()) {\n            return functionDeclarations.get();\n        }\n    }\n    return undefined;\n}\nfunction getFunctionPathFromExportPath(exportPath, j, root, namedExportFilter) {\n    // Default export\n    if (j.ExportDefaultDeclaration.check(exportPath.node)) {\n        const { declaration } = exportPath.node;\n        if (declaration) {\n            if (j.FunctionDeclaration.check(declaration) ||\n                j.FunctionExpression.check(declaration) ||\n                j.ArrowFunctionExpression.check(declaration)) {\n                return exportPath.get('declaration');\n            }\n            else if (j.Identifier.check(declaration)) {\n                const idName = declaration.name;\n                if (!namedExportFilter(idName))\n                    return;\n                const exportBinding = exportPath.scope.getBindings()[idName]?.[0];\n                if (exportBinding) {\n                    return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n                }\n            }\n        }\n    }\n    else if (\n    // Named exports\n    j.ExportNamedDeclaration.check(exportPath.node)) {\n        const namedExportPath = exportPath;\n        // extract the named exports, name specifiers, and default specifiers\n        const { declaration, specifiers } = namedExportPath.node;\n        if (declaration) {\n            if (j.VariableDeclaration.check(declaration)) {\n                const { declarations } = declaration;\n                for (const decl of declarations) {\n                    if (j.VariableDeclarator.check(decl) && j.Identifier.check(decl.id)) {\n                        const idName = decl.id.name;\n                        if (!namedExportFilter(idName))\n                            return;\n                        // get bindings for each variable declarator\n                        const exportBinding = namedExportPath.scope.getBindings()[idName]?.[0];\n                        if (exportBinding) {\n                            return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n                        }\n                    }\n                }\n            }\n            else if (j.FunctionDeclaration.check(declaration) ||\n                j.FunctionExpression.check(declaration) ||\n                j.ArrowFunctionExpression.check(declaration)) {\n                const funcName = declaration.id?.name;\n                if (!namedExportFilter(funcName))\n                    return;\n                return namedExportPath.get('declaration');\n            }\n        }\n        if (specifiers) {\n            for (const specifier of specifiers) {\n                if (j.ExportSpecifier.check(specifier)) {\n                    const idName = specifier.local.name;\n                    if (!namedExportFilter(idName))\n                        return;\n                    const exportBinding = namedExportPath.scope.getBindings()[idName]?.[0];\n                    if (exportBinding) {\n                        return getFunctionNodeFromBinding(exportBinding, idName, j, root);\n                    }\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction wrapParentheseIfNeeded(hasChainAccess, j, expression) {\n    return hasChainAccess ? j.parenthesizedExpression(expression) : expression;\n}\nfunction existsComment(comments, comment) {\n    const isCodemodErrorComment = comment\n        .trim()\n        .startsWith(exports.NEXT_CODEMOD_ERROR_PREFIX);\n    let hasIgnoreComment = false;\n    let hasComment = false;\n    if (comments) {\n        comments.forEach((commentNode) => {\n            const currentComment = commentNode.value;\n            if (currentComment.trim().startsWith(NEXT_CODEMOD_IGNORE_ERROR_PREFIX)) {\n                hasIgnoreComment = true;\n            }\n            if (currentComment === comment) {\n                hasComment = true;\n            }\n        });\n        // If it's inserting codemod error comment,\n        // check if there's already a @next-codemod-ignore comment.\n        // if ignore comment exists, bypass the comment insertion.\n        if (hasIgnoreComment && isCodemodErrorComment) {\n            return true;\n        }\n        if (hasComment) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction insertCommentOnce(node, j, comment) {\n    const hasCommentInInlineComments = existsComment(node.comments, comment);\n    const hasCommentInLeadingComments = existsComment(node.leadingComments, comment);\n    if (!hasCommentInInlineComments && !hasCommentInLeadingComments) {\n        // Always insert into inline comment\n        node.comments = [j.commentBlock(comment), ...(node.comments || [])];\n        return true;\n    }\n    return false;\n}\nfunction getVariableDeclaratorId(path, j) {\n    const parent = path.parentPath;\n    if (j.VariableDeclarator.check(parent.node)) {\n        const id = parent.node.id;\n        if (j.Identifier.check(id)) {\n            return id;\n        }\n    }\n    return undefined;\n}\nfunction findFunctionBody(path) {\n    let functionBody = path.node.body;\n    if (functionBody && functionBody.type === 'BlockStatement') {\n        return functionBody.body;\n    }\n    return null;\n}\nconst isPascalCase = (s) => /^[A-Z][a-z0-9]*$/.test(s);\nconst isReactHookName = (name) => \n// function name is `use`\nname === 'use' ||\n    // function name is `useX*`\n    (name.startsWith('use') && name[3] === name[3].toUpperCase());\nexports.isReactHookName = isReactHookName;\n// Determine a path of function contains any React hooks call expressions.\n// e.g. if there's any of those call expressions in the function body:\n// use() => true\n// React.use() => false\n// useXxxx() => true\n// Foo.use() => true\n// Foo.useXxxx() => true\nfunction containsReactHooksCallExpressions(path, j) {\n    const hasReactHooks = j(path)\n        .find(j.CallExpression)\n        .filter((callPath) => {\n        // It's matching:\n        // - use(<callPath>) => true\n        // - useX*(<callPath>) => true\n        const isUseHookOrReactHookCall = j.Identifier.check(callPath.value.callee) &&\n            (0, exports.isReactHookName)(callPath.value.callee.name);\n        // It's matching member access:\n        // - React.use(<callPath>) => true\n        // - Foo.useFoo(<callPath>) => true\n        // - foo.useFoo(<callPath>) => false\n        // - foo.use(<callPath>) => false\n        const isReactUseCall = j.MemberExpression.check(callPath.value.callee) &&\n            j.Identifier.check(callPath.value.callee.object) &&\n            j.Identifier.check(callPath.value.callee.property) &&\n            isPascalCase(callPath.value.callee.object.name) &&\n            (0, exports.isReactHookName)(callPath.value.callee.property.name);\n        return isUseHookOrReactHookCall || isReactUseCall;\n    })\n        .size() > 0;\n    return hasReactHooks;\n}\n// Capture the parent of the current path is wrapped by `use()` call expression\n// e.g.\n// use(<path>) => true\n// use2(<path>) => false\n// React.use(<path>) => true\n// Robust.use(<path>) => false\nfunction isParentUseCallExpression(path, j) {\n    const isParentUseCall = \n    // member access parentPath is argument\n    j.CallExpression.check(path.parent.value) &&\n        // member access is first argument\n        path.parent.value.arguments[0] === path.value &&\n        path.parent.value.arguments.length === 1 &&\n        // function name is `use`\n        j.Identifier.check(path.parent.value.callee) &&\n        path.parent.value.callee.name === 'use';\n    const isParentReactUseCall = \n    // member access parentPath is argument\n    j.CallExpression.check(path.parent.value) &&\n        // member access is first argument\n        path.parent.value.arguments[0] === path.value &&\n        path.parent.value.arguments.length === 1 &&\n        // function name is `use`\n        j.MemberExpression.check(path.parent.value.callee) &&\n        j.Identifier.check(path.parent.value.callee.object) &&\n        path.parent.value.callee.object.name === 'React' &&\n        j.Identifier.check(path.parent.value.callee.property) &&\n        path.parent.value.callee.property.name === 'use';\n    return isParentUseCall || isParentReactUseCall;\n}\n// Determine if a path is wrapped by `Promise.all()`\n// e.g.\n// Promise.all(<path>) => true\n// Promise.allSettled(<path>) => false\nfunction isParentPromiseAllCallExpression(path, j) {\n    const argsParent = path.parent;\n    const callParent = argsParent?.parent;\n    if (argsParent &&\n        callParent &&\n        j.ArrayExpression.check(argsParent.value) &&\n        j.CallExpression.check(callParent.value) &&\n        j.MemberExpression.check(callParent.value.callee) &&\n        j.Identifier.check(callParent.value.callee.object) &&\n        callParent.value.callee.object.name === 'Promise' &&\n        j.Identifier.check(callParent.value.callee.property) &&\n        callParent.value.callee.property.name === 'all') {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=utils.js.map"],"mappings":"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","ignoreList":[]}},"mtime":1769077344097},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/lib/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/lib/parser.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nvar __importDefault = void 0 && (void 0).__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParserFromPath = createParserFromPath;\nconst jscodeshift_1 = __importDefault(require(\"jscodeshift\"));\nconst babylon_1 = __importDefault(require(\"jscodeshift/parser/babylon\"));\nconst tsOptions_1 = __importDefault(require(\"jscodeshift/parser/tsOptions\"));\nconst dtsOptions = {\n  ...tsOptions_1.default,\n  plugins: [...tsOptions_1.default.plugins.filter(plugin => plugin !== 'typescript'), ['typescript', {\n    dts: true\n  }]]\n};\nfunction createParserFromPath(filePath) {\n  const isDeclarationFile = /\\.d\\.(m|c)?ts$/.test(filePath);\n  if (isDeclarationFile) {\n    return jscodeshift_1.default.withParser((0, babylon_1.default)(dtsOptions));\n  }\n  // jsx is allowed in .js files, feed them into the tsx parser.\n  // tsx parser :.js, .jsx, .tsx\n  // ts parser: .ts, .mts, .cts\n  const isTsFile = /\\.(m|c)?.ts$/.test(filePath);\n  return isTsFile ? jscodeshift_1.default.withParser('ts') : jscodeshift_1.default.withParser('tsx');\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVQYXJzZXJGcm9tUGF0aCIsImpzY29kZXNoaWZ0XzEiLCJyZXF1aXJlIiwiYmFieWxvbl8xIiwidHNPcHRpb25zXzEiLCJkdHNPcHRpb25zIiwiZGVmYXVsdCIsInBsdWdpbnMiLCJmaWx0ZXIiLCJwbHVnaW4iLCJkdHMiLCJmaWxlUGF0aCIsImlzRGVjbGFyYXRpb25GaWxlIiwidGVzdCIsIndpdGhQYXJzZXIiLCJpc1RzRmlsZSJdLCJzb3VyY2VSb290IjoiL1VzZXJzL2FsaWtoYW56aHVtYWJheWV2Ly5ucG0vX25weC82YTA5MDY2OWUyMWI0MzAzL25vZGVfbW9kdWxlcy9AbmV4dC9jb2RlbW9kL2xpYi8iLCJzb3VyY2VzIjpbInBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUGFyc2VyRnJvbVBhdGggPSBjcmVhdGVQYXJzZXJGcm9tUGF0aDtcbmNvbnN0IGpzY29kZXNoaWZ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzY29kZXNoaWZ0XCIpKTtcbmNvbnN0IGJhYnlsb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNjb2Rlc2hpZnQvcGFyc2VyL2JhYnlsb25cIikpO1xuY29uc3QgdHNPcHRpb25zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzY29kZXNoaWZ0L3BhcnNlci90c09wdGlvbnNcIikpO1xuY29uc3QgZHRzT3B0aW9ucyA9IHtcbiAgICAuLi50c09wdGlvbnNfMS5kZWZhdWx0LFxuICAgIHBsdWdpbnM6IFtcbiAgICAgICAgLi4udHNPcHRpb25zXzEuZGVmYXVsdC5wbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiBwbHVnaW4gIT09ICd0eXBlc2NyaXB0JyksXG4gICAgICAgIFsndHlwZXNjcmlwdCcsIHsgZHRzOiB0cnVlIH1dLFxuICAgIF0sXG59O1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyRnJvbVBhdGgoZmlsZVBhdGgpIHtcbiAgICBjb25zdCBpc0RlY2xhcmF0aW9uRmlsZSA9IC9cXC5kXFwuKG18Yyk/dHMkLy50ZXN0KGZpbGVQYXRoKTtcbiAgICBpZiAoaXNEZWNsYXJhdGlvbkZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGpzY29kZXNoaWZ0XzEuZGVmYXVsdC53aXRoUGFyc2VyKCgwLCBiYWJ5bG9uXzEuZGVmYXVsdCkoZHRzT3B0aW9ucykpO1xuICAgIH1cbiAgICAvLyBqc3ggaXMgYWxsb3dlZCBpbiAuanMgZmlsZXMsIGZlZWQgdGhlbSBpbnRvIHRoZSB0c3ggcGFyc2VyLlxuICAgIC8vIHRzeCBwYXJzZXIgOi5qcywgLmpzeCwgLnRzeFxuICAgIC8vIHRzIHBhcnNlcjogLnRzLCAubXRzLCAuY3RzXG4gICAgY29uc3QgaXNUc0ZpbGUgPSAvXFwuKG18Yyk/LnRzJC8udGVzdChmaWxlUGF0aCk7XG4gICAgcmV0dXJuIGlzVHNGaWxlID8ganNjb2Rlc2hpZnRfMS5kZWZhdWx0LndpdGhQYXJzZXIoJ3RzJykgOiBqc2NvZGVzaGlmdF8xLmRlZmF1bHQud2l0aFBhcnNlcigndHN4Jyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUNaLElBQUlBLGVBQWUsR0FBSSxVQUFRLFNBQUtBLGVBQWUsSUFBSyxVQUFVQyxHQUFHLEVBQUU7RUFDbkUsT0FBUUEsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsR0FBSUQsR0FBRyxHQUFHO0lBQUUsU0FBUyxFQUFFQTtFQUFJLENBQUM7QUFDN0QsQ0FBQztBQUNERSxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUFFQyxLQUFLLEVBQUU7QUFBSyxDQUFDLENBQUM7QUFDN0RELE9BQU8sQ0FBQ0Usb0JBQW9CLEdBQUdBLG9CQUFvQjtBQUNuRCxNQUFNQyxhQUFhLEdBQUdSLGVBQWUsQ0FBQ1MsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzdELE1BQU1DLFNBQVMsR0FBR1YsZUFBZSxDQUFDUyxPQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUN4RSxNQUFNRSxXQUFXLEdBQUdYLGVBQWUsQ0FBQ1MsT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFDNUUsTUFBTUcsVUFBVSxHQUFHO0VBQ2YsR0FBR0QsV0FBVyxDQUFDRSxPQUFPO0VBQ3RCQyxPQUFPLEVBQUUsQ0FDTCxHQUFHSCxXQUFXLENBQUNFLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDQyxNQUFNLENBQUVDLE1BQU0sSUFBS0EsTUFBTSxLQUFLLFlBQVksQ0FBQyxFQUMxRSxDQUFDLFlBQVksRUFBRTtJQUFFQyxHQUFHLEVBQUU7RUFBSyxDQUFDLENBQUM7QUFFckMsQ0FBQztBQUNELFNBQVNWLG9CQUFvQkEsQ0FBQ1csUUFBUSxFQUFFO0VBQ3BDLE1BQU1DLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDQyxJQUFJLENBQUNGLFFBQVEsQ0FBQztFQUN6RCxJQUFJQyxpQkFBaUIsRUFBRTtJQUNuQixPQUFPWCxhQUFhLENBQUNLLE9BQU8sQ0FBQ1EsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFWCxTQUFTLENBQUNHLE9BQU8sRUFBRUQsVUFBVSxDQUFDLENBQUM7RUFDL0U7RUFDQTtFQUNBO0VBQ0E7RUFDQSxNQUFNVSxRQUFRLEdBQUcsY0FBYyxDQUFDRixJQUFJLENBQUNGLFFBQVEsQ0FBQztFQUM5QyxPQUFPSSxRQUFRLEdBQUdkLGFBQWEsQ0FBQ0ssT0FBTyxDQUFDUSxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUdiLGFBQWEsQ0FBQ0ssT0FBTyxDQUFDUSxVQUFVLENBQUMsS0FBSyxDQUFDO0FBQ3RHIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","createParserFromPath","jscodeshift_1","require","babylon_1","tsOptions_1","dtsOptions","default","plugins","filter","plugin","dts","filePath","isDeclarationFile","test","withParser","isTsFile"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/lib/","sources":["parser.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createParserFromPath = createParserFromPath;\nconst jscodeshift_1 = __importDefault(require(\"jscodeshift\"));\nconst babylon_1 = __importDefault(require(\"jscodeshift/parser/babylon\"));\nconst tsOptions_1 = __importDefault(require(\"jscodeshift/parser/tsOptions\"));\nconst dtsOptions = {\n    ...tsOptions_1.default,\n    plugins: [\n        ...tsOptions_1.default.plugins.filter((plugin) => plugin !== 'typescript'),\n        ['typescript', { dts: true }],\n    ],\n};\nfunction createParserFromPath(filePath) {\n    const isDeclarationFile = /\\.d\\.(m|c)?ts$/.test(filePath);\n    if (isDeclarationFile) {\n        return jscodeshift_1.default.withParser((0, babylon_1.default)(dtsOptions));\n    }\n    // jsx is allowed in .js files, feed them into the tsx parser.\n    // tsx parser :.js, .jsx, .tsx\n    // ts parser: .ts, .mts, .cts\n    const isTsFile = /\\.(m|c)?.ts$/.test(filePath);\n    return isTsFile ? jscodeshift_1.default.withParser('ts') : jscodeshift_1.default.withParser('tsx');\n}\n//# sourceMappingURL=parser.js.map"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,UAAQ,SAAKA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB;AACnD,MAAMC,aAAa,GAAGR,eAAe,CAACS,OAAO,CAAC,aAAa,CAAC,CAAC;AAC7D,MAAMC,SAAS,GAAGV,eAAe,CAACS,OAAO,CAAC,4BAA4B,CAAC,CAAC;AACxE,MAAME,WAAW,GAAGX,eAAe,CAACS,OAAO,CAAC,8BAA8B,CAAC,CAAC;AAC5E,MAAMG,UAAU,GAAG;EACf,GAAGD,WAAW,CAACE,OAAO;EACtBC,OAAO,EAAE,CACL,GAAGH,WAAW,CAACE,OAAO,CAACC,OAAO,CAACC,MAAM,CAAEC,MAAM,IAAKA,MAAM,KAAK,YAAY,CAAC,EAC1E,CAAC,YAAY,EAAE;IAAEC,GAAG,EAAE;EAAK,CAAC,CAAC;AAErC,CAAC;AACD,SAASV,oBAAoBA,CAACW,QAAQ,EAAE;EACpC,MAAMC,iBAAiB,GAAG,gBAAgB,CAACC,IAAI,CAACF,QAAQ,CAAC;EACzD,IAAIC,iBAAiB,EAAE;IACnB,OAAOX,aAAa,CAACK,OAAO,CAACQ,UAAU,CAAC,CAAC,CAAC,EAAEX,SAAS,CAACG,OAAO,EAAED,UAAU,CAAC,CAAC;EAC/E;EACA;EACA;EACA;EACA,MAAMU,QAAQ,GAAG,cAAc,CAACF,IAAI,CAACF,QAAQ,CAAC;EAC9C,OAAOI,QAAQ,GAAGd,aAAa,CAACK,OAAO,CAACQ,UAAU,CAAC,IAAI,CAAC,GAAGb,aAAa,CAACK,OAAO,CAACQ,UAAU,CAAC,KAAK,CAAC;AACtG","ignoreList":[]}},"mtime":1769077344095},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/index.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = require('./src/core');\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiL1VzZXJzL2FsaWtoYW56aHVtYWJheWV2Ly5ucG0vX25weC82YTA5MDY2OWUyMWI0MzAzL25vZGVfbW9kdWxlcy9qc2NvZGVzaGlmdC8iLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2NvcmUnKTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUFBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["module","exports","require"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/","sources":["index.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = require('./src/core');\n"],"mappings":";;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAO,GAAGC,OAAO,CAAC,YAAY,CAAC","ignoreList":[]}},"mtime":1744019810779},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/babylon.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst defaultOptions = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [['flow', {\n    all: true\n  }], 'flowComments', 'jsx', 'asyncGenerators', 'bigInt', 'classProperties', 'classPrivateProperties', 'classPrivateMethods', ['decorators', {\n    decoratorsBeforeExport: false\n  }], 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {\n    proposal: 'minimal'\n  }], 'throwExpressions']\n};\n\n/**\n * Wrapper to set default options\n */\nmodule.exports = function (options = defaultOptions) {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiYWJ5bG9uIiwicmVxdWlyZSIsImRlZmF1bHRPcHRpb25zIiwic291cmNlVHlwZSIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uIiwic3RhcnRMaW5lIiwidG9rZW5zIiwicGx1Z2lucyIsImFsbCIsImRlY29yYXRvcnNCZWZvcmVFeHBvcnQiLCJwcm9wb3NhbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcHRpb25zIiwicGFyc2UiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL2pzY29kZXNoaWZ0L3BhcnNlci8iLCJzb3VyY2VzIjpbImJhYnlsb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgYmFieWxvbiA9IHJlcXVpcmUoJ0BiYWJlbC9wYXJzZXInKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IHRydWUsXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICBzdGFydExpbmU6IDEsXG4gIHRva2VuczogdHJ1ZSxcbiAgcGx1Z2luczogW1xuICAgIFsnZmxvdycsIHthbGw6IHRydWV9XSxcbiAgICAnZmxvd0NvbW1lbnRzJyxcbiAgICAnanN4JyxcblxuICAgICdhc3luY0dlbmVyYXRvcnMnLFxuICAgICdiaWdJbnQnLFxuICAgICdjbGFzc1Byb3BlcnRpZXMnLFxuICAgICdjbGFzc1ByaXZhdGVQcm9wZXJ0aWVzJyxcbiAgICAnY2xhc3NQcml2YXRlTWV0aG9kcycsXG4gICAgWydkZWNvcmF0b3JzJywge2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IGZhbHNlfV0sXG4gICAgJ2RvRXhwcmVzc2lvbnMnLFxuICAgICdkeW5hbWljSW1wb3J0JyxcbiAgICAnZXhwb3J0RGVmYXVsdEZyb20nLFxuICAgICdleHBvcnROYW1lc3BhY2VGcm9tJyxcbiAgICAnZnVuY3Rpb25CaW5kJyxcbiAgICAnZnVuY3Rpb25TZW50JyxcbiAgICAnaW1wb3J0TWV0YScsXG4gICAgJ2xvZ2ljYWxBc3NpZ25tZW50JyxcbiAgICAnbnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvcicsXG4gICAgJ251bWVyaWNTZXBhcmF0b3InLFxuICAgICdvYmplY3RSZXN0U3ByZWFkJyxcbiAgICAnb3B0aW9uYWxDYXRjaEJpbmRpbmcnLFxuICAgICdvcHRpb25hbENoYWluaW5nJyxcbiAgICBbJ3BpcGVsaW5lT3BlcmF0b3InLCB7cHJvcG9zYWw6ICdtaW5pbWFsJ31dLFxuICAgICd0aHJvd0V4cHJlc3Npb25zJyxcbiAgXSxcbn07XG5cbi8qKlxuICogV3JhcHBlciB0byBzZXQgZGVmYXVsdCBvcHRpb25zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucz1kZWZhdWx0T3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHBhcnNlKGNvZGUpIHtcbiAgICAgIHJldHVybiBiYWJ5bG9uLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWixNQUFNQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFFeEMsTUFBTUMsY0FBYyxHQUFHO0VBQ3JCQyxVQUFVLEVBQUUsUUFBUTtFQUNwQkMsMkJBQTJCLEVBQUUsSUFBSTtFQUNqQ0MsMEJBQTBCLEVBQUUsSUFBSTtFQUNoQ0MsU0FBUyxFQUFFLENBQUM7RUFDWkMsTUFBTSxFQUFFLElBQUk7RUFDWkMsT0FBTyxFQUFFLENBQ1AsQ0FBQyxNQUFNLEVBQUU7SUFBQ0MsR0FBRyxFQUFFO0VBQUksQ0FBQyxDQUFDLEVBQ3JCLGNBQWMsRUFDZCxLQUFLLEVBRUwsaUJBQWlCLEVBQ2pCLFFBQVEsRUFDUixpQkFBaUIsRUFDakIsd0JBQXdCLEVBQ3hCLHFCQUFxQixFQUNyQixDQUFDLFlBQVksRUFBRTtJQUFDQyxzQkFBc0IsRUFBRTtFQUFLLENBQUMsQ0FBQyxFQUMvQyxlQUFlLEVBQ2YsZUFBZSxFQUNmLG1CQUFtQixFQUNuQixxQkFBcUIsRUFDckIsY0FBYyxFQUNkLGNBQWMsRUFDZCxZQUFZLEVBQ1osbUJBQW1CLEVBQ25CLDJCQUEyQixFQUMzQixrQkFBa0IsRUFDbEIsa0JBQWtCLEVBQ2xCLHNCQUFzQixFQUN0QixrQkFBa0IsRUFDbEIsQ0FBQyxrQkFBa0IsRUFBRTtJQUFDQyxRQUFRLEVBQUU7RUFBUyxDQUFDLENBQUMsRUFDM0Msa0JBQWtCO0FBRXRCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVNDLE9BQU8sR0FBQ1osY0FBYyxFQUFFO0VBQ2hELE9BQU87SUFDTGEsS0FBS0EsQ0FBQ0MsSUFBSSxFQUFFO01BQ1YsT0FBT2hCLE9BQU8sQ0FBQ2UsS0FBSyxDQUFDQyxJQUFJLEVBQUVGLE9BQU8sQ0FBQztJQUNyQztFQUNGLENBQUM7QUFDSCxDQUFDIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["babylon","require","defaultOptions","sourceType","allowImportExportEverywhere","allowReturnOutsideFunction","startLine","tokens","plugins","all","decoratorsBeforeExport","proposal","module","exports","options","parse","code"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/","sources":["babylon.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\n\nconst defaultOptions = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    ['flow', {all: true}],\n    'flowComments',\n    'jsx',\n\n    'asyncGenerators',\n    'bigInt',\n    'classProperties',\n    'classPrivateProperties',\n    'classPrivateMethods',\n    ['decorators', {decoratorsBeforeExport: false}],\n    'doExpressions',\n    'dynamicImport',\n    'exportDefaultFrom',\n    'exportNamespaceFrom',\n    'functionBind',\n    'functionSent',\n    'importMeta',\n    'logicalAssignment',\n    'nullishCoalescingOperator',\n    'numericSeparator',\n    'objectRestSpread',\n    'optionalCatchBinding',\n    'optionalChaining',\n    ['pipelineOperator', {proposal: 'minimal'}],\n    'throwExpressions',\n  ],\n};\n\n/**\n * Wrapper to set default options\n */\nmodule.exports = function(options=defaultOptions) {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    },\n  };\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAe,CAAC;AAExC,MAAMC,cAAc,GAAG;EACrBC,UAAU,EAAE,QAAQ;EACpBC,2BAA2B,EAAE,IAAI;EACjCC,0BAA0B,EAAE,IAAI;EAChCC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,CACP,CAAC,MAAM,EAAE;IAACC,GAAG,EAAE;EAAI,CAAC,CAAC,EACrB,cAAc,EACd,KAAK,EAEL,iBAAiB,EACjB,QAAQ,EACR,iBAAiB,EACjB,wBAAwB,EACxB,qBAAqB,EACrB,CAAC,YAAY,EAAE;IAACC,sBAAsB,EAAE;EAAK,CAAC,CAAC,EAC/C,eAAe,EACf,eAAe,EACf,mBAAmB,EACnB,qBAAqB,EACrB,cAAc,EACd,cAAc,EACd,YAAY,EACZ,mBAAmB,EACnB,2BAA2B,EAC3B,kBAAkB,EAClB,kBAAkB,EAClB,sBAAsB,EACtB,kBAAkB,EAClB,CAAC,kBAAkB,EAAE;IAACC,QAAQ,EAAE;EAAS,CAAC,CAAC,EAC3C,kBAAkB;AAEtB,CAAC;;AAED;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,UAASC,OAAO,GAACZ,cAAc,EAAE;EAChD,OAAO;IACLa,KAAKA,CAACC,IAAI,EAAE;MACV,OAAOhB,OAAO,CAACe,KAAK,CAACC,IAAI,EAAEF,OAAO,CAAC;IACrC;EACF,CAAC;AACH,CAAC","ignoreList":[]}},"mtime":1744019810775},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/tsOptions.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: ['asyncGenerators', 'decoratorAutoAccessors', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportExtensions', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importAttributes', 'importMeta', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {\n    proposal: 'minimal'\n  }], 'throwExpressions', 'typescript']\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwic291cmNlVHlwZSIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uIiwic3RhcnRMaW5lIiwidG9rZW5zIiwicGx1Z2lucyIsInByb3Bvc2FsIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL2pzY29kZXNoaWZ0L3BhcnNlci8iLCJzb3VyY2VzIjpbInRzT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE9wdGlvbnMgc2hhcmVkIGJ5IHRoZSBUeXBlU2NyaXB0IGFuZCBUU1ggcGFyc2Vycy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IHRydWUsXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICBzdGFydExpbmU6IDEsXG4gIHRva2VuczogdHJ1ZSxcbiAgcGx1Z2luczogW1xuICAgICdhc3luY0dlbmVyYXRvcnMnLFxuICAgICdkZWNvcmF0b3JBdXRvQWNjZXNzb3JzJyxcbiAgICAnYmlnSW50JyxcbiAgICAnY2xhc3NQcml2YXRlTWV0aG9kcycsXG4gICAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAgICdjbGFzc1Byb3BlcnRpZXMnLFxuICAgICdkZWNvcmF0b3JzLWxlZ2FjeScsXG4gICAgJ2RvRXhwcmVzc2lvbnMnLFxuICAgICdkeW5hbWljSW1wb3J0JyxcbiAgICAnZXhwb3J0RGVmYXVsdEZyb20nLFxuICAgICdleHBvcnRFeHRlbnNpb25zJyxcbiAgICAnZXhwb3J0TmFtZXNwYWNlRnJvbScsXG4gICAgJ2Z1bmN0aW9uQmluZCcsXG4gICAgJ2Z1bmN0aW9uU2VudCcsXG4gICAgJ2ltcG9ydEF0dHJpYnV0ZXMnLFxuICAgICdpbXBvcnRNZXRhJyxcbiAgICAnbnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvcicsXG4gICAgJ251bWVyaWNTZXBhcmF0b3InLFxuICAgICdvYmplY3RSZXN0U3ByZWFkJyxcbiAgICAnb3B0aW9uYWxDYXRjaEJpbmRpbmcnLFxuICAgICdvcHRpb25hbENoYWluaW5nJyxcbiAgICBbJ3BpcGVsaW5lT3BlcmF0b3InLCB7IHByb3Bvc2FsOiAnbWluaW1hbCcgfV0sXG4gICAgJ3Rocm93RXhwcmVzc2lvbnMnLFxuICAgICd0eXBlc2NyaXB0J1xuICBdLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZDLFVBQVUsRUFBRSxRQUFRO0VBQ3BCQywyQkFBMkIsRUFBRSxJQUFJO0VBQ2pDQywwQkFBMEIsRUFBRSxJQUFJO0VBQ2hDQyxTQUFTLEVBQUUsQ0FBQztFQUNaQyxNQUFNLEVBQUUsSUFBSTtFQUNaQyxPQUFPLEVBQUUsQ0FDUCxpQkFBaUIsRUFDakIsd0JBQXdCLEVBQ3hCLFFBQVEsRUFDUixxQkFBcUIsRUFDckIsd0JBQXdCLEVBQ3hCLGlCQUFpQixFQUNqQixtQkFBbUIsRUFDbkIsZUFBZSxFQUNmLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsa0JBQWtCLEVBQ2xCLHFCQUFxQixFQUNyQixjQUFjLEVBQ2QsY0FBYyxFQUNkLGtCQUFrQixFQUNsQixZQUFZLEVBQ1osMkJBQTJCLEVBQzNCLGtCQUFrQixFQUNsQixrQkFBa0IsRUFDbEIsc0JBQXNCLEVBQ3RCLGtCQUFrQixFQUNsQixDQUFDLGtCQUFrQixFQUFFO0lBQUVDLFFBQVEsRUFBRTtFQUFVLENBQUMsQ0FBQyxFQUM3QyxrQkFBa0IsRUFDbEIsWUFBWTtBQUVoQixDQUFDIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["module","exports","sourceType","allowImportExportEverywhere","allowReturnOutsideFunction","startLine","tokens","plugins","proposal"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/","sources":["tsOptions.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    'asyncGenerators',\n    'decoratorAutoAccessors',\n    'bigInt',\n    'classPrivateMethods',\n    'classPrivateProperties',\n    'classProperties',\n    'decorators-legacy',\n    'doExpressions',\n    'dynamicImport',\n    'exportDefaultFrom',\n    'exportExtensions',\n    'exportNamespaceFrom',\n    'functionBind',\n    'functionSent',\n    'importAttributes',\n    'importMeta',\n    'nullishCoalescingOperator',\n    'numericSeparator',\n    'objectRestSpread',\n    'optionalCatchBinding',\n    'optionalChaining',\n    ['pipelineOperator', { proposal: 'minimal' }],\n    'throwExpressions',\n    'typescript'\n  ],\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG;EACfC,UAAU,EAAE,QAAQ;EACpBC,2BAA2B,EAAE,IAAI;EACjCC,0BAA0B,EAAE,IAAI;EAChCC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,CACP,iBAAiB,EACjB,wBAAwB,EACxB,QAAQ,EACR,qBAAqB,EACrB,wBAAwB,EACxB,iBAAiB,EACjB,mBAAmB,EACnB,eAAe,EACf,eAAe,EACf,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,YAAY,EACZ,2BAA2B,EAC3B,kBAAkB,EAClB,kBAAkB,EAClB,sBAAsB,EACtB,kBAAkB,EAClB,CAAC,kBAAkB,EAAE;IAAEC,QAAQ,EAAE;EAAU,CAAC,CAAC,EAC7C,kBAAkB,EAClB,YAAY;AAEhB,CAAC","ignoreList":[]}},"mtime":1744019810851},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/next-async-dynamic-api.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformDynamicAPI = transformDynamicAPI;\nconst utils_1 = require(\"./utils\");\nconst parser_1 = require(\"../../../lib/parser\");\nconst DYNAMIC_IMPORT_WARN_COMMENT = ` @next-codemod-error The APIs under 'next/headers' are async now, need to be manually awaited. `;\nfunction findDynamicImportsAndComment(root, j) {\n  let modified = false;\n  // find all the dynamic imports of `next/headers`,\n  // and add a comment to the import expression to inform this needs to be manually handled\n  // find all the dynamic imports of `next/cookies`,\n  // Notice, import() is not handled as ImportExpression in current jscodeshift version,\n  // we need to use CallExpression to capture the dynamic imports.\n  const importPaths = root.find(j.CallExpression, {\n    callee: {\n      type: 'Import'\n    },\n    arguments: [{\n      value: 'next/headers'\n    }]\n  });\n  importPaths.forEach(path => {\n    const inserted = (0, utils_1.insertCommentOnce)(path.node, j, DYNAMIC_IMPORT_WARN_COMMENT);\n    modified ||= inserted;\n  });\n  return modified;\n}\nfunction transformDynamicAPI(source, _api, filePath) {\n  const isEntryFile = utils_1.NEXTJS_ENTRY_FILES.test(filePath);\n  const j = (0, parser_1.createParserFromPath)(filePath);\n  const root = j(source);\n  let modified = false;\n  // Check if 'use' from 'react' needs to be imported\n  let needsReactUseImport = false;\n  const insertedTypes = new Set();\n  function isImportedInModule(path, functionName) {\n    const closestDef = j(path).closestScope().findVariableDeclarators(functionName);\n    return closestDef.size() === 0;\n  }\n  function processAsyncApiCalls(asyncRequestApiName, originRequestApiName) {\n    // Process each call to cookies() or headers()\n    root.find(j.CallExpression, {\n      callee: {\n        type: 'Identifier',\n        name: asyncRequestApiName\n      }\n    }).forEach(path => {\n      var _parentFunctionNode, _path$parentPath;\n      const isImportedTopLevel = isImportedInModule(path, asyncRequestApiName);\n      if (!isImportedTopLevel) {\n        return;\n      }\n      let parentFunctionPath = (0, utils_1.findClosetParentFunctionScope)(path, j);\n      // We found the parent scope is not a function\n      let parentFunctionNode;\n      if (parentFunctionPath) {\n        if ((0, utils_1.isFunctionScope)(parentFunctionPath, j)) {\n          parentFunctionNode = parentFunctionPath.node;\n        } else {\n          const scopeNode = parentFunctionPath.node;\n          if (scopeNode.type === 'ReturnStatement' && (0, utils_1.isFunctionType)(scopeNode.argument.type)) {\n            parentFunctionNode = scopeNode.argument;\n          }\n        }\n      }\n      const isAsyncFunction = ((_parentFunctionNode = parentFunctionNode) === null || _parentFunctionNode === void 0 ? void 0 : _parentFunctionNode.async) || false;\n      const isCallAwaited = ((_path$parentPath = path.parentPath) === null || _path$parentPath === void 0 || (_path$parentPath = _path$parentPath.node) === null || _path$parentPath === void 0 ? void 0 : _path$parentPath.type) === 'AwaitExpression';\n      const hasChainAccess = path.parentPath.value.type === 'MemberExpression' && path.parentPath.value.object === path.node;\n      const closetScope = j(path).closestScope();\n      // For cookies/headers API, only transform server and shared components\n      if (isAsyncFunction) {\n        if (!isCallAwaited) {\n          // Add 'await' in front of cookies() call\n          const expr = j.awaitExpression(\n          // add parentheses to wrap the function call\n          j.callExpression(j.identifier(asyncRequestApiName), []));\n          j(path).replaceWith((0, utils_1.wrapParentheseIfNeeded)(hasChainAccess, j, expr));\n          modified = true;\n        }\n      } else {\n        // Determine if the function is an export\n        const closetScopePath = closetScope.get();\n        const isEntryFileExport = isEntryFile && (0, utils_1.isMatchedFunctionExported)(closetScopePath, j);\n        const closestFunctionNode = closetScope.size() ? closetScopePath.node : null;\n        // If it's exporting a function directly, exportFunctionNode is same as exportNode\n        // e.g. export default function MyComponent() {}\n        // If it's exporting a variable declaration, exportFunctionNode is the function declaration\n        // e.g. export const MyComponent = function() {}\n        let exportFunctionNode;\n        if (isEntryFileExport) {\n          if (closestFunctionNode && (0, utils_1.isFunctionType)(closestFunctionNode.type)) {\n            exportFunctionNode = closestFunctionNode;\n          }\n        } else {\n          // Is normal async function\n          exportFunctionNode = closestFunctionNode;\n        }\n        let canConvertToAsync = false;\n        // check if current path is under the default export function\n        if (isEntryFileExport) {\n          // if default export function is not async, convert it to async, and await the api call\n          if (!isCallAwaited && (0, utils_1.isFunctionType)(exportFunctionNode.type)) {\n            const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(closetScopePath, j);\n            // If the scoped function is async function\n            if (exportFunctionNode.async === false && !hasReactHooksUsage) {\n              canConvertToAsync = true;\n              exportFunctionNode.async = true;\n            }\n            if (canConvertToAsync) {\n              const expr = j.awaitExpression(j.callExpression(j.identifier(asyncRequestApiName), []));\n              j(path).replaceWith((0, utils_1.wrapParentheseIfNeeded)(hasChainAccess, j, expr));\n              (0, utils_1.turnFunctionReturnTypeToAsync)(closetScopePath.node, j);\n              modified = true;\n            } else {\n              // If it's still sync function that cannot be converted to async, wrap the api call with 'use()' if needed\n              if (!(0, utils_1.isParentUseCallExpression)(path, j)) {\n                j(path).replaceWith(j.callExpression(j.identifier('use'), [j.callExpression(j.identifier(asyncRequestApiName), [])]));\n                needsReactUseImport = true;\n                modified = true;\n              }\n            }\n          }\n        } else {\n          // if parent is function and it's a hook, which starts with 'use', wrap the api call with 'use()'\n          const parentFunction = (0, utils_1.findClosetParentFunctionScope)(path, j);\n          if (parentFunction) {\n            var _parentFunction$get$n;\n            const parentFunctionName = ((_parentFunction$get$n = parentFunction.get().node.id) === null || _parentFunction$get$n === void 0 ? void 0 : _parentFunction$get$n.name) || '';\n            const isParentFunctionHook = (0, utils_1.isReactHookName)(parentFunctionName);\n            if (isParentFunctionHook && !(0, utils_1.isParentUseCallExpression)(path, j)) {\n              j(path).replaceWith(j.callExpression(j.identifier('use'), [j.callExpression(j.identifier(asyncRequestApiName), [])]));\n              needsReactUseImport = true;\n            } else {\n              const casted = castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} Manually await this call and refactor the function to be async `);\n              modified ||= casted;\n            }\n          } else {\n            const casted = castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} please manually await this call, codemod cannot transform due to undetermined async scope `);\n            modified ||= casted;\n          }\n        }\n      }\n    });\n    // Handle type usage of async API, e.g. `type Cookie = ReturnType<typeof cookies>`\n    // convert it to `type Cookie = Awaited<ReturnType<typeof cookies>>`\n    root.find(j.TSTypeReference, {\n      typeName: {\n        type: 'Identifier',\n        name: 'ReturnType'\n      }\n    }).forEach(path => {\n      var _path$node$typeParame;\n      const typeParam = (_path$node$typeParame = path.node.typeParameters) === null || _path$node$typeParame === void 0 ? void 0 : _path$node$typeParame.params[0];\n      // Check if the ReturnType is for 'cookies'\n      if (typeParam && j.TSTypeQuery.check(typeParam) && j.Identifier.check(typeParam.exprName) && typeParam.exprName.name === asyncRequestApiName) {\n        // Replace ReturnType<typeof cookies> with Awaited<ReturnType<typeof cookies>>\n        const awaitedTypeReference = j.tsTypeReference(j.identifier('Awaited'), j.tsTypeParameterInstantiation([j.tsTypeReference(j.identifier('ReturnType'), j.tsTypeParameterInstantiation([typeParam]))]));\n        j(path).replaceWith(awaitedTypeReference);\n        modified = true;\n      }\n    });\n  }\n  const isClientComponent = (0, utils_1.determineClientDirective)(root, j);\n  // Only transform the valid calls in server or shared components\n  if (isClientComponent) return null;\n  // Import declaration case, e.g. import { cookies } from 'next/headers'\n  const importedNextAsyncRequestApisMapping = findImportMappingFromNextHeaders(root, j);\n  for (const originName in importedNextAsyncRequestApisMapping) {\n    const aliasName = importedNextAsyncRequestApisMapping[originName];\n    processAsyncApiCalls(aliasName, originName);\n  }\n  // Add import { use } from 'react' if needed and not already imported\n  if (needsReactUseImport) {\n    (0, utils_1.insertReactUseImport)(root, j);\n  }\n  const commented = findDynamicImportsAndComment(root, j);\n  modified ||= commented;\n  return modified ? root.toSource() : null;\n}\n// cast to unknown first, then the specific type\nconst API_CAST_TYPE_MAP = {\n  cookies: 'UnsafeUnwrappedCookies',\n  headers: 'UnsafeUnwrappedHeaders',\n  draftMode: 'UnsafeUnwrappedDraftMode'\n};\nfunction castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, customMessage) {\n  let modified = false;\n  const isTsFile = filePath.endsWith('.ts') || filePath.endsWith('.tsx');\n  if (isTsFile) {\n    var _path$parentPath2;\n    // if the path of call expression is already being awaited, no need to cast\n    if (((_path$parentPath2 = path.parentPath) === null || _path$parentPath2 === void 0 || (_path$parentPath2 = _path$parentPath2.node) === null || _path$parentPath2 === void 0 ? void 0 : _path$parentPath2.type) === 'AwaitExpression') return false;\n    /* Do type cast for headers, cookies, draftMode\n      import {\n        type UnsafeUnwrappedHeaders,\n        type UnsafeUnwrappedCookies,\n        type UnsafeUnwrappedDraftMode\n      } from 'next/headers'\n      \n      cookies() as unknown as UnsafeUnwrappedCookies\n      headers() as unknown as UnsafeUnwrappedHeaders\n      draftMode() as unknown as UnsafeUnwrappedDraftMode\n      \n      e.g. `<path>` is cookies(), convert it to `(<path> as unknown as UnsafeUnwrappedCookies)`\n    */\n    const targetType = API_CAST_TYPE_MAP[originRequestApiName];\n    const newCastExpression = j.tsAsExpression(j.tsAsExpression(path.node, j.tsUnknownKeyword()), j.tsTypeReference(j.identifier(targetType)));\n    // Replace the original expression with the new cast expression,\n    // also wrap () around the new cast expression.\n    const parent = path.parent.value;\n    const wrappedExpression = j.parenthesizedExpression(newCastExpression);\n    path.replace(wrappedExpression);\n    // If the wrapped expression `(<expression>)` is the beginning of an expression statement,\n    // add a void operator to separate the statement, to avoid syntax error that being treated as part of previous statement.\n    // example:\n    // input:\n    // <expression>\n    // <expression>\n    // output:\n    // (<expression> as ...)\n    // void (<expression> as ...)\n    if (j.ExpressionStatement.check(parent) && parent.expression === path.node) {\n      // append a semicolon to the start of the expression statement\n      parent.expression = j.unaryExpression('void', parent.expression);\n    }\n    modified = true;\n    // If cast types are not imported, add them to the import list\n    const importDeclaration = root.find(j.ImportDeclaration, {\n      source: {\n        value: 'next/headers'\n      }\n    });\n    if (importDeclaration.size() > 0) {\n      const hasImportedType = importDeclaration.find(j.TSTypeAliasDeclaration, {\n        id: {\n          name: targetType\n        }\n      }).size() > 0 || importDeclaration.find(j.ImportSpecifier, {\n        imported: {\n          name: targetType\n        }\n      }).size() > 0;\n      if (!hasImportedType && !insertedTypes.has(targetType)) {\n        importDeclaration.get().node.specifiers.push(j.importSpecifier(j.identifier(`type ${targetType}`)));\n        insertedTypes.add(targetType);\n      }\n    }\n  } else {\n    // Otherwise for JS file, leave a message to the user to manually handle the transformation\n    const inserted = (0, utils_1.insertCommentOnce)(path.node, j, customMessage);\n    modified ||= inserted;\n  }\n  return modified;\n}\nfunction findImportMappingFromNextHeaders(root, j) {\n  const mappings = {};\n  // Find the import declaration from 'next/headers'\n  root.find(j.ImportDeclaration, {\n    source: {\n      value: 'next/headers'\n    }\n  }).forEach(importPath => {\n    const importDeclaration = importPath.node;\n    // Iterate over the specifiers and build the mappings\n    importDeclaration.specifiers.forEach(specifier => {\n      if (j.ImportSpecifier.check(specifier)) {\n        const importedName = specifier.imported.name; // Original name (e.g., cookies)\n        const localName = specifier.local.name; // Local name (e.g., myCookies or same as importedName)\n        // Add to the mappings\n        mappings[importedName] = localName;\n      }\n    });\n  });\n  return mappings;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRyYW5zZm9ybUR5bmFtaWNBUEkiLCJ1dGlsc18xIiwicmVxdWlyZSIsInBhcnNlcl8xIiwiRFlOQU1JQ19JTVBPUlRfV0FSTl9DT01NRU5UIiwiZmluZER5bmFtaWNJbXBvcnRzQW5kQ29tbWVudCIsInJvb3QiLCJqIiwibW9kaWZpZWQiLCJpbXBvcnRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsInR5cGUiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwicGF0aCIsImluc2VydGVkIiwiaW5zZXJ0Q29tbWVudE9uY2UiLCJub2RlIiwic291cmNlIiwiX2FwaSIsImZpbGVQYXRoIiwiaXNFbnRyeUZpbGUiLCJORVhUSlNfRU5UUllfRklMRVMiLCJ0ZXN0IiwiY3JlYXRlUGFyc2VyRnJvbVBhdGgiLCJuZWVkc1JlYWN0VXNlSW1wb3J0IiwiaW5zZXJ0ZWRUeXBlcyIsIlNldCIsImlzSW1wb3J0ZWRJbk1vZHVsZSIsImZ1bmN0aW9uTmFtZSIsImNsb3Nlc3REZWYiLCJjbG9zZXN0U2NvcGUiLCJmaW5kVmFyaWFibGVEZWNsYXJhdG9ycyIsInNpemUiLCJwcm9jZXNzQXN5bmNBcGlDYWxscyIsImFzeW5jUmVxdWVzdEFwaU5hbWUiLCJvcmlnaW5SZXF1ZXN0QXBpTmFtZSIsIm5hbWUiLCJfcGFyZW50RnVuY3Rpb25Ob2RlIiwiX3BhdGgkcGFyZW50UGF0aCIsImlzSW1wb3J0ZWRUb3BMZXZlbCIsInBhcmVudEZ1bmN0aW9uUGF0aCIsImZpbmRDbG9zZXRQYXJlbnRGdW5jdGlvblNjb3BlIiwicGFyZW50RnVuY3Rpb25Ob2RlIiwiaXNGdW5jdGlvblNjb3BlIiwic2NvcGVOb2RlIiwiaXNGdW5jdGlvblR5cGUiLCJhcmd1bWVudCIsImlzQXN5bmNGdW5jdGlvbiIsImFzeW5jIiwiaXNDYWxsQXdhaXRlZCIsInBhcmVudFBhdGgiLCJoYXNDaGFpbkFjY2VzcyIsIm9iamVjdCIsImNsb3NldFNjb3BlIiwiZXhwciIsImF3YWl0RXhwcmVzc2lvbiIsImNhbGxFeHByZXNzaW9uIiwiaWRlbnRpZmllciIsInJlcGxhY2VXaXRoIiwid3JhcFBhcmVudGhlc2VJZk5lZWRlZCIsImNsb3NldFNjb3BlUGF0aCIsImdldCIsImlzRW50cnlGaWxlRXhwb3J0IiwiaXNNYXRjaGVkRnVuY3Rpb25FeHBvcnRlZCIsImNsb3Nlc3RGdW5jdGlvbk5vZGUiLCJleHBvcnRGdW5jdGlvbk5vZGUiLCJjYW5Db252ZXJ0VG9Bc3luYyIsImhhc1JlYWN0SG9va3NVc2FnZSIsImNvbnRhaW5zUmVhY3RIb29rc0NhbGxFeHByZXNzaW9ucyIsInR1cm5GdW5jdGlvblJldHVyblR5cGVUb0FzeW5jIiwiaXNQYXJlbnRVc2VDYWxsRXhwcmVzc2lvbiIsInBhcmVudEZ1bmN0aW9uIiwiX3BhcmVudEZ1bmN0aW9uJGdldCRuIiwicGFyZW50RnVuY3Rpb25OYW1lIiwiaWQiLCJpc1BhcmVudEZ1bmN0aW9uSG9vayIsImlzUmVhY3RIb29rTmFtZSIsImNhc3RlZCIsImNhc3RUeXBlc09yQWRkQ29tbWVudCIsIk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVgiLCJUU1R5cGVSZWZlcmVuY2UiLCJ0eXBlTmFtZSIsIl9wYXRoJG5vZGUkdHlwZVBhcmFtZSIsInR5cGVQYXJhbSIsInR5cGVQYXJhbWV0ZXJzIiwicGFyYW1zIiwiVFNUeXBlUXVlcnkiLCJjaGVjayIsIklkZW50aWZpZXIiLCJleHByTmFtZSIsImF3YWl0ZWRUeXBlUmVmZXJlbmNlIiwidHNUeXBlUmVmZXJlbmNlIiwidHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiIsImlzQ2xpZW50Q29tcG9uZW50IiwiZGV0ZXJtaW5lQ2xpZW50RGlyZWN0aXZlIiwiaW1wb3J0ZWROZXh0QXN5bmNSZXF1ZXN0QXBpc01hcHBpbmciLCJmaW5kSW1wb3J0TWFwcGluZ0Zyb21OZXh0SGVhZGVycyIsIm9yaWdpbk5hbWUiLCJhbGlhc05hbWUiLCJpbnNlcnRSZWFjdFVzZUltcG9ydCIsImNvbW1lbnRlZCIsInRvU291cmNlIiwiQVBJX0NBU1RfVFlQRV9NQVAiLCJjb29raWVzIiwiaGVhZGVycyIsImRyYWZ0TW9kZSIsImN1c3RvbU1lc3NhZ2UiLCJpc1RzRmlsZSIsImVuZHNXaXRoIiwiX3BhdGgkcGFyZW50UGF0aDIiLCJ0YXJnZXRUeXBlIiwibmV3Q2FzdEV4cHJlc3Npb24iLCJ0c0FzRXhwcmVzc2lvbiIsInRzVW5rbm93bktleXdvcmQiLCJwYXJlbnQiLCJ3cmFwcGVkRXhwcmVzc2lvbiIsInBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwicmVwbGFjZSIsIkV4cHJlc3Npb25TdGF0ZW1lbnQiLCJleHByZXNzaW9uIiwidW5hcnlFeHByZXNzaW9uIiwiaW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWNsYXJhdGlvbiIsImhhc0ltcG9ydGVkVHlwZSIsIlRTVHlwZUFsaWFzRGVjbGFyYXRpb24iLCJJbXBvcnRTcGVjaWZpZXIiLCJpbXBvcnRlZCIsImhhcyIsInNwZWNpZmllcnMiLCJwdXNoIiwiaW1wb3J0U3BlY2lmaWVyIiwiYWRkIiwibWFwcGluZ3MiLCJpbXBvcnRQYXRoIiwic3BlY2lmaWVyIiwiaW1wb3J0ZWROYW1lIiwibG9jYWxOYW1lIiwibG9jYWwiXSwic291cmNlUm9vdCI6Ii9Vc2Vycy9hbGlraGFuemh1bWFiYXlldi8ubnBtL19ucHgvNmEwOTA2NjllMjFiNDMwMy9ub2RlX21vZHVsZXMvQG5leHQvY29kZW1vZC90cmFuc2Zvcm1zL2xpYi9hc3luYy1yZXF1ZXN0LWFwaS8iLCJzb3VyY2VzIjpbIm5leHQtYXN5bmMtZHluYW1pYy1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zZm9ybUR5bmFtaWNBUEkgPSB0cmFuc2Zvcm1EeW5hbWljQVBJO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL3BhcnNlclwiKTtcbmNvbnN0IERZTkFNSUNfSU1QT1JUX1dBUk5fQ09NTUVOVCA9IGAgQG5leHQtY29kZW1vZC1lcnJvciBUaGUgQVBJcyB1bmRlciAnbmV4dC9oZWFkZXJzJyBhcmUgYXN5bmMgbm93LCBuZWVkIHRvIGJlIG1hbnVhbGx5IGF3YWl0ZWQuIGA7XG5mdW5jdGlvbiBmaW5kRHluYW1pY0ltcG9ydHNBbmRDb21tZW50KHJvb3QsIGopIHtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAvLyBmaW5kIGFsbCB0aGUgZHluYW1pYyBpbXBvcnRzIG9mIGBuZXh0L2hlYWRlcnNgLFxuICAgIC8vIGFuZCBhZGQgYSBjb21tZW50IHRvIHRoZSBpbXBvcnQgZXhwcmVzc2lvbiB0byBpbmZvcm0gdGhpcyBuZWVkcyB0byBiZSBtYW51YWxseSBoYW5kbGVkXG4gICAgLy8gZmluZCBhbGwgdGhlIGR5bmFtaWMgaW1wb3J0cyBvZiBgbmV4dC9jb29raWVzYCxcbiAgICAvLyBOb3RpY2UsIGltcG9ydCgpIGlzIG5vdCBoYW5kbGVkIGFzIEltcG9ydEV4cHJlc3Npb24gaW4gY3VycmVudCBqc2NvZGVzaGlmdCB2ZXJzaW9uLFxuICAgIC8vIHdlIG5lZWQgdG8gdXNlIENhbGxFeHByZXNzaW9uIHRvIGNhcHR1cmUgdGhlIGR5bmFtaWMgaW1wb3J0cy5cbiAgICBjb25zdCBpbXBvcnRQYXRocyA9IHJvb3QuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XG4gICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydCcsXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3VtZW50czogW3sgdmFsdWU6ICduZXh0L2hlYWRlcnMnIH1dLFxuICAgIH0pO1xuICAgIGltcG9ydFBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSAoMCwgdXRpbHNfMS5pbnNlcnRDb21tZW50T25jZSkocGF0aC5ub2RlLCBqLCBEWU5BTUlDX0lNUE9SVF9XQVJOX0NPTU1FTlQpO1xuICAgICAgICBtb2RpZmllZCB8fD0gaW5zZXJ0ZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRHluYW1pY0FQSShzb3VyY2UsIF9hcGksIGZpbGVQYXRoKSB7XG4gICAgY29uc3QgaXNFbnRyeUZpbGUgPSB1dGlsc18xLk5FWFRKU19FTlRSWV9GSUxFUy50ZXN0KGZpbGVQYXRoKTtcbiAgICBjb25zdCBqID0gKDAsIHBhcnNlcl8xLmNyZWF0ZVBhcnNlckZyb21QYXRoKShmaWxlUGF0aCk7XG4gICAgY29uc3Qgcm9vdCA9IGooc291cmNlKTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiAndXNlJyBmcm9tICdyZWFjdCcgbmVlZHMgdG8gYmUgaW1wb3J0ZWRcbiAgICBsZXQgbmVlZHNSZWFjdFVzZUltcG9ydCA9IGZhbHNlO1xuICAgIGNvbnN0IGluc2VydGVkVHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaXNJbXBvcnRlZEluTW9kdWxlKHBhdGgsIGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBjbG9zZXN0RGVmID0gaihwYXRoKVxuICAgICAgICAgICAgLmNsb3Nlc3RTY29wZSgpXG4gICAgICAgICAgICAuZmluZFZhcmlhYmxlRGVjbGFyYXRvcnMoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3REZWYuc2l6ZSgpID09PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXN5bmNBcGlDYWxscyhhc3luY1JlcXVlc3RBcGlOYW1lLCBvcmlnaW5SZXF1ZXN0QXBpTmFtZSkge1xuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsbCB0byBjb29raWVzKCkgb3IgaGVhZGVycygpXG4gICAgICAgIHJvb3RcbiAgICAgICAgICAgIC5maW5kKGouQ2FsbEV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBhc3luY1JlcXVlc3RBcGlOYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0ltcG9ydGVkVG9wTGV2ZWwgPSBpc0ltcG9ydGVkSW5Nb2R1bGUocGF0aCwgYXN5bmNSZXF1ZXN0QXBpTmFtZSk7XG4gICAgICAgICAgICBpZiAoIWlzSW1wb3J0ZWRUb3BMZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnRGdW5jdGlvblBhdGggPSAoMCwgdXRpbHNfMS5maW5kQ2xvc2V0UGFyZW50RnVuY3Rpb25TY29wZSkocGF0aCwgaik7XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgcGFyZW50IHNjb3BlIGlzIG5vdCBhIGZ1bmN0aW9uXG4gICAgICAgICAgICBsZXQgcGFyZW50RnVuY3Rpb25Ob2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudEZ1bmN0aW9uUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc0Z1bmN0aW9uU2NvcGUpKHBhcmVudEZ1bmN0aW9uUGF0aCwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnVuY3Rpb25Ob2RlID0gcGFyZW50RnVuY3Rpb25QYXRoLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZU5vZGUgPSBwYXJlbnRGdW5jdGlvblBhdGgubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlTm9kZS50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuaXNGdW5jdGlvblR5cGUpKHNjb3BlTm9kZS5hcmd1bWVudC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RnVuY3Rpb25Ob2RlID0gc2NvcGVOb2RlLmFyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gcGFyZW50RnVuY3Rpb25Ob2RlPy5hc3luYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2FsbEF3YWl0ZWQgPSBwYXRoLnBhcmVudFBhdGg/Lm5vZGU/LnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nO1xuICAgICAgICAgICAgY29uc3QgaGFzQ2hhaW5BY2Nlc3MgPSBwYXRoLnBhcmVudFBhdGgudmFsdWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICAgICAgICAgICAgcGF0aC5wYXJlbnRQYXRoLnZhbHVlLm9iamVjdCA9PT0gcGF0aC5ub2RlO1xuICAgICAgICAgICAgY29uc3QgY2xvc2V0U2NvcGUgPSBqKHBhdGgpLmNsb3Nlc3RTY29wZSgpO1xuICAgICAgICAgICAgLy8gRm9yIGNvb2tpZXMvaGVhZGVycyBBUEksIG9ubHkgdHJhbnNmb3JtIHNlcnZlciBhbmQgc2hhcmVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGlmIChpc0FzeW5jRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FsbEF3YWl0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkICdhd2FpdCcgaW4gZnJvbnQgb2YgY29va2llcygpIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwciA9IGouYXdhaXRFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcGFyZW50aGVzZXMgdG8gd3JhcCB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgICAgICBqLmNhbGxFeHByZXNzaW9uKGouaWRlbnRpZmllcihhc3luY1JlcXVlc3RBcGlOYW1lKSwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgaihwYXRoKS5yZXBsYWNlV2l0aCgoMCwgdXRpbHNfMS53cmFwUGFyZW50aGVzZUlmTmVlZGVkKShoYXNDaGFpbkFjY2VzcywgaiwgZXhwcikpO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmdW5jdGlvbiBpcyBhbiBleHBvcnRcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXRTY29wZVBhdGggPSBjbG9zZXRTY29wZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VudHJ5RmlsZUV4cG9ydCA9IGlzRW50cnlGaWxlICYmICgwLCB1dGlsc18xLmlzTWF0Y2hlZEZ1bmN0aW9uRXhwb3J0ZWQpKGNsb3NldFNjb3BlUGF0aCwgaik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZ1bmN0aW9uTm9kZSA9IGNsb3NldFNjb3BlLnNpemUoKVxuICAgICAgICAgICAgICAgICAgICA/IGNsb3NldFNjb3BlUGF0aC5ub2RlXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGV4cG9ydGluZyBhIGZ1bmN0aW9uIGRpcmVjdGx5LCBleHBvcnRGdW5jdGlvbk5vZGUgaXMgc2FtZSBhcyBleHBvcnROb2RlXG4gICAgICAgICAgICAgICAgLy8gZS5nLiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHt9XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBleHBvcnRpbmcgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiwgZXhwb3J0RnVuY3Rpb25Ob2RlIGlzIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgIC8vIGUuZy4gZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgICAgIGxldCBleHBvcnRGdW5jdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW50cnlGaWxlRXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0RnVuY3Rpb25Ob2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5pc0Z1bmN0aW9uVHlwZSkoY2xvc2VzdEZ1bmN0aW9uTm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0RnVuY3Rpb25Ob2RlID0gY2xvc2VzdEZ1bmN0aW9uTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgbm9ybWFsIGFzeW5jIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEZ1bmN0aW9uTm9kZSA9IGNsb3Nlc3RGdW5jdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjYW5Db252ZXJ0VG9Bc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGF0aCBpcyB1bmRlciB0aGUgZGVmYXVsdCBleHBvcnQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoaXNFbnRyeUZpbGVFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGVmYXVsdCBleHBvcnQgZnVuY3Rpb24gaXMgbm90IGFzeW5jLCBjb252ZXJ0IGl0IHRvIGFzeW5jLCBhbmQgYXdhaXQgdGhlIGFwaSBjYWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWxsQXdhaXRlZCAmJiAoMCwgdXRpbHNfMS5pc0Z1bmN0aW9uVHlwZSkoZXhwb3J0RnVuY3Rpb25Ob2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNSZWFjdEhvb2tzVXNhZ2UgPSAoMCwgdXRpbHNfMS5jb250YWluc1JlYWN0SG9va3NDYWxsRXhwcmVzc2lvbnMpKGNsb3NldFNjb3BlUGF0aCwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NvcGVkIGZ1bmN0aW9uIGlzIGFzeW5jIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0RnVuY3Rpb25Ob2RlLmFzeW5jID09PSBmYWxzZSAmJiAhaGFzUmVhY3RIb29rc1VzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQ29udmVydFRvQXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEZ1bmN0aW9uTm9kZS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ29udmVydFRvQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByID0gai5hd2FpdEV4cHJlc3Npb24oai5jYWxsRXhwcmVzc2lvbihqLmlkZW50aWZpZXIoYXN5bmNSZXF1ZXN0QXBpTmFtZSksIFtdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaihwYXRoKS5yZXBsYWNlV2l0aCgoMCwgdXRpbHNfMS53cmFwUGFyZW50aGVzZUlmTmVlZGVkKShoYXNDaGFpbkFjY2VzcywgaiwgZXhwcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnR1cm5GdW5jdGlvblJldHVyblR5cGVUb0FzeW5jKShjbG9zZXRTY29wZVBhdGgubm9kZSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBzeW5jIGZ1bmN0aW9uIHRoYXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhc3luYywgd3JhcCB0aGUgYXBpIGNhbGwgd2l0aCAndXNlKCknIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNQYXJlbnRVc2VDYWxsRXhwcmVzc2lvbikocGF0aCwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaihwYXRoKS5yZXBsYWNlV2l0aChqLmNhbGxFeHByZXNzaW9uKGouaWRlbnRpZmllcigndXNlJyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGouY2FsbEV4cHJlc3Npb24oai5pZGVudGlmaWVyKGFzeW5jUmVxdWVzdEFwaU5hbWUpLCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWFjdFVzZUltcG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHBhcmVudCBpcyBmdW5jdGlvbiBhbmQgaXQncyBhIGhvb2ssIHdoaWNoIHN0YXJ0cyB3aXRoICd1c2UnLCB3cmFwIHRoZSBhcGkgY2FsbCB3aXRoICd1c2UoKSdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RnVuY3Rpb24gPSAoMCwgdXRpbHNfMS5maW5kQ2xvc2V0UGFyZW50RnVuY3Rpb25TY29wZSkocGF0aCwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RnVuY3Rpb25OYW1lID0gcGFyZW50RnVuY3Rpb24uZ2V0KCkubm9kZS5pZD8ubmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUGFyZW50RnVuY3Rpb25Ib29rID0gKDAsIHV0aWxzXzEuaXNSZWFjdEhvb2tOYW1lKShwYXJlbnRGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFyZW50RnVuY3Rpb25Ib29rICYmICEoMCwgdXRpbHNfMS5pc1BhcmVudFVzZUNhbGxFeHByZXNzaW9uKShwYXRoLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGoocGF0aCkucmVwbGFjZVdpdGgoai5jYWxsRXhwcmVzc2lvbihqLmlkZW50aWZpZXIoJ3VzZScpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGouY2FsbEV4cHJlc3Npb24oai5pZGVudGlmaWVyKGFzeW5jUmVxdWVzdEFwaU5hbWUpLCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVhY3RVc2VJbXBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdFR5cGVzT3JBZGRDb21tZW50KGosIHBhdGgsIG9yaWdpblJlcXVlc3RBcGlOYW1lLCByb290LCBmaWxlUGF0aCwgaW5zZXJ0ZWRUeXBlcywgYCAke3V0aWxzXzEuTkVYVF9DT0RFTU9EX0VSUk9SX1BSRUZJWH0gTWFudWFsbHkgYXdhaXQgdGhpcyBjYWxsIGFuZCByZWZhY3RvciB0aGUgZnVuY3Rpb24gdG8gYmUgYXN5bmMgYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgfHw9IGNhc3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RlZCA9IGNhc3RUeXBlc09yQWRkQ29tbWVudChqLCBwYXRoLCBvcmlnaW5SZXF1ZXN0QXBpTmFtZSwgcm9vdCwgZmlsZVBhdGgsIGluc2VydGVkVHlwZXMsIGAgJHt1dGlsc18xLk5FWFRfQ09ERU1PRF9FUlJPUl9QUkVGSVh9IHBsZWFzZSBtYW51YWxseSBhd2FpdCB0aGlzIGNhbGwsIGNvZGVtb2QgY2Fubm90IHRyYW5zZm9ybSBkdWUgdG8gdW5kZXRlcm1pbmVkIGFzeW5jIHNjb3BlIGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgfHw9IGNhc3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhhbmRsZSB0eXBlIHVzYWdlIG9mIGFzeW5jIEFQSSwgZS5nLiBgdHlwZSBDb29raWUgPSBSZXR1cm5UeXBlPHR5cGVvZiBjb29raWVzPmBcbiAgICAgICAgLy8gY29udmVydCBpdCB0byBgdHlwZSBDb29raWUgPSBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGNvb2tpZXM+PmBcbiAgICAgICAgcm9vdFxuICAgICAgICAgICAgLmZpbmQoai5UU1R5cGVSZWZlcmVuY2UsIHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSZXR1cm5UeXBlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZVBhcmFtID0gcGF0aC5ub2RlLnR5cGVQYXJhbWV0ZXJzPy5wYXJhbXNbMF07XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgUmV0dXJuVHlwZSBpcyBmb3IgJ2Nvb2tpZXMnXG4gICAgICAgICAgICBpZiAodHlwZVBhcmFtICYmXG4gICAgICAgICAgICAgICAgai5UU1R5cGVRdWVyeS5jaGVjayh0eXBlUGFyYW0pICYmXG4gICAgICAgICAgICAgICAgai5JZGVudGlmaWVyLmNoZWNrKHR5cGVQYXJhbS5leHByTmFtZSkgJiZcbiAgICAgICAgICAgICAgICB0eXBlUGFyYW0uZXhwck5hbWUubmFtZSA9PT0gYXN5bmNSZXF1ZXN0QXBpTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgUmV0dXJuVHlwZTx0eXBlb2YgY29va2llcz4gd2l0aCBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGNvb2tpZXM+PlxuICAgICAgICAgICAgICAgIGNvbnN0IGF3YWl0ZWRUeXBlUmVmZXJlbmNlID0gai50c1R5cGVSZWZlcmVuY2Uoai5pZGVudGlmaWVyKCdBd2FpdGVkJyksIGoudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihbXG4gICAgICAgICAgICAgICAgICAgIGoudHNUeXBlUmVmZXJlbmNlKGouaWRlbnRpZmllcignUmV0dXJuVHlwZScpLCBqLnRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oW3R5cGVQYXJhbV0pKSxcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgaihwYXRoKS5yZXBsYWNlV2l0aChhd2FpdGVkVHlwZVJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNDbGllbnRDb21wb25lbnQgPSAoMCwgdXRpbHNfMS5kZXRlcm1pbmVDbGllbnREaXJlY3RpdmUpKHJvb3QsIGopO1xuICAgIC8vIE9ubHkgdHJhbnNmb3JtIHRoZSB2YWxpZCBjYWxscyBpbiBzZXJ2ZXIgb3Igc2hhcmVkIGNvbXBvbmVudHNcbiAgICBpZiAoaXNDbGllbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEltcG9ydCBkZWNsYXJhdGlvbiBjYXNlLCBlLmcuIGltcG9ydCB7IGNvb2tpZXMgfSBmcm9tICduZXh0L2hlYWRlcnMnXG4gICAgY29uc3QgaW1wb3J0ZWROZXh0QXN5bmNSZXF1ZXN0QXBpc01hcHBpbmcgPSBmaW5kSW1wb3J0TWFwcGluZ0Zyb21OZXh0SGVhZGVycyhyb290LCBqKTtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbk5hbWUgaW4gaW1wb3J0ZWROZXh0QXN5bmNSZXF1ZXN0QXBpc01hcHBpbmcpIHtcbiAgICAgICAgY29uc3QgYWxpYXNOYW1lID0gaW1wb3J0ZWROZXh0QXN5bmNSZXF1ZXN0QXBpc01hcHBpbmdbb3JpZ2luTmFtZV07XG4gICAgICAgIHByb2Nlc3NBc3luY0FwaUNhbGxzKGFsaWFzTmFtZSwgb3JpZ2luTmFtZSk7XG4gICAgfVxuICAgIC8vIEFkZCBpbXBvcnQgeyB1c2UgfSBmcm9tICdyZWFjdCcgaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBpbXBvcnRlZFxuICAgIGlmIChuZWVkc1JlYWN0VXNlSW1wb3J0KSB7XG4gICAgICAgICgwLCB1dGlsc18xLmluc2VydFJlYWN0VXNlSW1wb3J0KShyb290LCBqKTtcbiAgICB9XG4gICAgY29uc3QgY29tbWVudGVkID0gZmluZER5bmFtaWNJbXBvcnRzQW5kQ29tbWVudChyb290LCBqKTtcbiAgICBtb2RpZmllZCB8fD0gY29tbWVudGVkO1xuICAgIHJldHVybiBtb2RpZmllZCA/IHJvb3QudG9Tb3VyY2UoKSA6IG51bGw7XG59XG4vLyBjYXN0IHRvIHVua25vd24gZmlyc3QsIHRoZW4gdGhlIHNwZWNpZmljIHR5cGVcbmNvbnN0IEFQSV9DQVNUX1RZUEVfTUFQID0ge1xuICAgIGNvb2tpZXM6ICdVbnNhZmVVbndyYXBwZWRDb29raWVzJyxcbiAgICBoZWFkZXJzOiAnVW5zYWZlVW53cmFwcGVkSGVhZGVycycsXG4gICAgZHJhZnRNb2RlOiAnVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlJyxcbn07XG5mdW5jdGlvbiBjYXN0VHlwZXNPckFkZENvbW1lbnQoaiwgcGF0aCwgb3JpZ2luUmVxdWVzdEFwaU5hbWUsIHJvb3QsIGZpbGVQYXRoLCBpbnNlcnRlZFR5cGVzLCBjdXN0b21NZXNzYWdlKSB7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgY29uc3QgaXNUc0ZpbGUgPSBmaWxlUGF0aC5lbmRzV2l0aCgnLnRzJykgfHwgZmlsZVBhdGguZW5kc1dpdGgoJy50c3gnKTtcbiAgICBpZiAoaXNUc0ZpbGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggb2YgY2FsbCBleHByZXNzaW9uIGlzIGFscmVhZHkgYmVpbmcgYXdhaXRlZCwgbm8gbmVlZCB0byBjYXN0XG4gICAgICAgIGlmIChwYXRoLnBhcmVudFBhdGg/Lm5vZGU/LnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvKiBEbyB0eXBlIGNhc3QgZm9yIGhlYWRlcnMsIGNvb2tpZXMsIGRyYWZ0TW9kZVxuICAgICAgICAgIGltcG9ydCB7XG4gICAgICAgICAgICB0eXBlIFVuc2FmZVVud3JhcHBlZEhlYWRlcnMsXG4gICAgICAgICAgICB0eXBlIFVuc2FmZVVud3JhcHBlZENvb2tpZXMsXG4gICAgICAgICAgICB0eXBlIFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZVxuICAgICAgICAgIH0gZnJvbSAnbmV4dC9oZWFkZXJzJ1xuICAgICAgICAgIFxuICAgICAgICAgIGNvb2tpZXMoKSBhcyB1bmtub3duIGFzIFVuc2FmZVVud3JhcHBlZENvb2tpZXNcbiAgICAgICAgICBoZWFkZXJzKCkgYXMgdW5rbm93biBhcyBVbnNhZmVVbndyYXBwZWRIZWFkZXJzXG4gICAgICAgICAgZHJhZnRNb2RlKCkgYXMgdW5rbm93biBhcyBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGVcbiAgICAgICAgICBcbiAgICAgICAgICBlLmcuIGA8cGF0aD5gIGlzIGNvb2tpZXMoKSwgY29udmVydCBpdCB0byBgKDxwYXRoPiBhcyB1bmtub3duIGFzIFVuc2FmZVVud3JhcHBlZENvb2tpZXMpYFxuICAgICAgICAqL1xuICAgICAgICBjb25zdCB0YXJnZXRUeXBlID0gQVBJX0NBU1RfVFlQRV9NQVBbb3JpZ2luUmVxdWVzdEFwaU5hbWVdO1xuICAgICAgICBjb25zdCBuZXdDYXN0RXhwcmVzc2lvbiA9IGoudHNBc0V4cHJlc3Npb24oai50c0FzRXhwcmVzc2lvbihwYXRoLm5vZGUsIGoudHNVbmtub3duS2V5d29yZCgpKSwgai50c1R5cGVSZWZlcmVuY2Uoai5pZGVudGlmaWVyKHRhcmdldFR5cGUpKSk7XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24gd2l0aCB0aGUgbmV3IGNhc3QgZXhwcmVzc2lvbixcbiAgICAgICAgLy8gYWxzbyB3cmFwICgpIGFyb3VuZCB0aGUgbmV3IGNhc3QgZXhwcmVzc2lvbi5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5wYXJlbnQudmFsdWU7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRFeHByZXNzaW9uID0gai5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbihuZXdDYXN0RXhwcmVzc2lvbik7XG4gICAgICAgIHBhdGgucmVwbGFjZSh3cmFwcGVkRXhwcmVzc2lvbik7XG4gICAgICAgIC8vIElmIHRoZSB3cmFwcGVkIGV4cHJlc3Npb24gYCg8ZXhwcmVzc2lvbj4pYCBpcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGV4cHJlc3Npb24gc3RhdGVtZW50LFxuICAgICAgICAvLyBhZGQgYSB2b2lkIG9wZXJhdG9yIHRvIHNlcGFyYXRlIHRoZSBzdGF0ZW1lbnQsIHRvIGF2b2lkIHN5bnRheCBlcnJvciB0aGF0IGJlaW5nIHRyZWF0ZWQgYXMgcGFydCBvZiBwcmV2aW91cyBzdGF0ZW1lbnQuXG4gICAgICAgIC8vIGV4YW1wbGU6XG4gICAgICAgIC8vIGlucHV0OlxuICAgICAgICAvLyA8ZXhwcmVzc2lvbj5cbiAgICAgICAgLy8gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIG91dHB1dDpcbiAgICAgICAgLy8gKDxleHByZXNzaW9uPiBhcyAuLi4pXG4gICAgICAgIC8vIHZvaWQgKDxleHByZXNzaW9uPiBhcyAuLi4pXG4gICAgICAgIGlmIChqLkV4cHJlc3Npb25TdGF0ZW1lbnQuY2hlY2socGFyZW50KSAmJlxuICAgICAgICAgICAgcGFyZW50LmV4cHJlc3Npb24gPT09IHBhdGgubm9kZSkge1xuICAgICAgICAgICAgLy8gYXBwZW5kIGEgc2VtaWNvbG9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZXhwcmVzc2lvbiBzdGF0ZW1lbnRcbiAgICAgICAgICAgIHBhcmVudC5leHByZXNzaW9uID0gai51bmFyeUV4cHJlc3Npb24oJ3ZvaWQnLCBwYXJlbnQuZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAvLyBJZiBjYXN0IHR5cGVzIGFyZSBub3QgaW1wb3J0ZWQsIGFkZCB0aGVtIHRvIHRoZSBpbXBvcnQgbGlzdFxuICAgICAgICBjb25zdCBpbXBvcnREZWNsYXJhdGlvbiA9IHJvb3QuZmluZChqLkltcG9ydERlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHsgdmFsdWU6ICduZXh0L2hlYWRlcnMnIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW1wb3J0RGVjbGFyYXRpb24uc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaGFzSW1wb3J0ZWRUeXBlID0gaW1wb3J0RGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAuZmluZChqLlRTVHlwZUFsaWFzRGVjbGFyYXRpb24sIHtcbiAgICAgICAgICAgICAgICBpZDogeyBuYW1lOiB0YXJnZXRUeXBlIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zaXplKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgaW1wb3J0RGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoai5JbXBvcnRTcGVjaWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWQ6IHsgbmFtZTogdGFyZ2V0VHlwZSB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zaXplKCkgPiAwO1xuICAgICAgICAgICAgaWYgKCFoYXNJbXBvcnRlZFR5cGUgJiYgIWluc2VydGVkVHlwZXMuaGFzKHRhcmdldFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0RGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLmdldCgpXG4gICAgICAgICAgICAgICAgICAgIC5ub2RlLnNwZWNpZmllcnMucHVzaChqLmltcG9ydFNwZWNpZmllcihqLmlkZW50aWZpZXIoYHR5cGUgJHt0YXJnZXRUeXBlfWApKSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRUeXBlcy5hZGQodGFyZ2V0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBmb3IgSlMgZmlsZSwgbGVhdmUgYSBtZXNzYWdlIHRvIHRoZSB1c2VyIHRvIG1hbnVhbGx5IGhhbmRsZSB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgY29uc3QgaW5zZXJ0ZWQgPSAoMCwgdXRpbHNfMS5pbnNlcnRDb21tZW50T25jZSkocGF0aC5ub2RlLCBqLCBjdXN0b21NZXNzYWdlKTtcbiAgICAgICAgbW9kaWZpZWQgfHw9IGluc2VydGVkO1xuICAgIH1cbiAgICByZXR1cm4gbW9kaWZpZWQ7XG59XG5mdW5jdGlvbiBmaW5kSW1wb3J0TWFwcGluZ0Zyb21OZXh0SGVhZGVycyhyb290LCBqKSB7XG4gICAgY29uc3QgbWFwcGluZ3MgPSB7fTtcbiAgICAvLyBGaW5kIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24gZnJvbSAnbmV4dC9oZWFkZXJzJ1xuICAgIHJvb3RcbiAgICAgICAgLmZpbmQoai5JbXBvcnREZWNsYXJhdGlvbiwgeyBzb3VyY2U6IHsgdmFsdWU6ICduZXh0L2hlYWRlcnMnIH0gfSlcbiAgICAgICAgLmZvckVhY2goKGltcG9ydFBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgaW1wb3J0RGVjbGFyYXRpb24gPSBpbXBvcnRQYXRoLm5vZGU7XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgc3BlY2lmaWVycyBhbmQgYnVpbGQgdGhlIG1hcHBpbmdzXG4gICAgICAgIGltcG9ydERlY2xhcmF0aW9uLnNwZWNpZmllcnMuZm9yRWFjaCgoc3BlY2lmaWVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoai5JbXBvcnRTcGVjaWZpZXIuY2hlY2soc3BlY2lmaWVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkTmFtZSA9IHNwZWNpZmllci5pbXBvcnRlZC5uYW1lOyAvLyBPcmlnaW5hbCBuYW1lIChlLmcuLCBjb29raWVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHNwZWNpZmllci5sb2NhbC5uYW1lOyAvLyBMb2NhbCBuYW1lIChlLmcuLCBteUNvb2tpZXMgb3Igc2FtZSBhcyBpbXBvcnRlZE5hbWUpXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXBwaW5nc1xuICAgICAgICAgICAgICAgIG1hcHBpbmdzW2ltcG9ydGVkTmFtZV0gPSBsb2NhbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBwaW5ncztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtYXN5bmMtZHluYW1pYy1hcGkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUNaQSxNQUFNLENBQUNDLGNB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","map":{"version":3,"names":["Object","defineProperty","exports","value","transformDynamicAPI","utils_1","require","parser_1","DYNAMIC_IMPORT_WARN_COMMENT","findDynamicImportsAndComment","root","j","modified","importPaths","find","CallExpression","callee","type","arguments","forEach","path","inserted","insertCommentOnce","node","source","_api","filePath","isEntryFile","NEXTJS_ENTRY_FILES","test","createParserFromPath","needsReactUseImport","insertedTypes","Set","isImportedInModule","functionName","closestDef","closestScope","findVariableDeclarators","size","processAsyncApiCalls","asyncRequestApiName","originRequestApiName","name","_parentFunctionNode","_path$parentPath","isImportedTopLevel","parentFunctionPath","findClosetParentFunctionScope","parentFunctionNode","isFunctionScope","scopeNode","isFunctionType","argument","isAsyncFunction","async","isCallAwaited","parentPath","hasChainAccess","object","closetScope","expr","awaitExpression","callExpression","identifier","replaceWith","wrapParentheseIfNeeded","closetScopePath","get","isEntryFileExport","isMatchedFunctionExported","closestFunctionNode","exportFunctionNode","canConvertToAsync","hasReactHooksUsage","containsReactHooksCallExpressions","turnFunctionReturnTypeToAsync","isParentUseCallExpression","parentFunction","_parentFunction$get$n","parentFunctionName","id","isParentFunctionHook","isReactHookName","casted","castTypesOrAddComment","NEXT_CODEMOD_ERROR_PREFIX","TSTypeReference","typeName","_path$node$typeParame","typeParam","typeParameters","params","TSTypeQuery","check","Identifier","exprName","awaitedTypeReference","tsTypeReference","tsTypeParameterInstantiation","isClientComponent","determineClientDirective","importedNextAsyncRequestApisMapping","findImportMappingFromNextHeaders","originName","aliasName","insertReactUseImport","commented","toSource","API_CAST_TYPE_MAP","cookies","headers","draftMode","customMessage","isTsFile","endsWith","_path$parentPath2","targetType","newCastExpression","tsAsExpression","tsUnknownKeyword","parent","wrappedExpression","parenthesizedExpression","replace","ExpressionStatement","expression","unaryExpression","importDeclaration","ImportDeclaration","hasImportedType","TSTypeAliasDeclaration","ImportSpecifier","imported","has","specifiers","push","importSpecifier","add","mappings","importPath","specifier","importedName","localName","local"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/@next/codemod/transforms/lib/async-request-api/","sources":["next-async-dynamic-api.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transformDynamicAPI = transformDynamicAPI;\nconst utils_1 = require(\"./utils\");\nconst parser_1 = require(\"../../../lib/parser\");\nconst DYNAMIC_IMPORT_WARN_COMMENT = ` @next-codemod-error The APIs under 'next/headers' are async now, need to be manually awaited. `;\nfunction findDynamicImportsAndComment(root, j) {\n    let modified = false;\n    // find all the dynamic imports of `next/headers`,\n    // and add a comment to the import expression to inform this needs to be manually handled\n    // find all the dynamic imports of `next/cookies`,\n    // Notice, import() is not handled as ImportExpression in current jscodeshift version,\n    // we need to use CallExpression to capture the dynamic imports.\n    const importPaths = root.find(j.CallExpression, {\n        callee: {\n            type: 'Import',\n        },\n        arguments: [{ value: 'next/headers' }],\n    });\n    importPaths.forEach((path) => {\n        const inserted = (0, utils_1.insertCommentOnce)(path.node, j, DYNAMIC_IMPORT_WARN_COMMENT);\n        modified ||= inserted;\n    });\n    return modified;\n}\nfunction transformDynamicAPI(source, _api, filePath) {\n    const isEntryFile = utils_1.NEXTJS_ENTRY_FILES.test(filePath);\n    const j = (0, parser_1.createParserFromPath)(filePath);\n    const root = j(source);\n    let modified = false;\n    // Check if 'use' from 'react' needs to be imported\n    let needsReactUseImport = false;\n    const insertedTypes = new Set();\n    function isImportedInModule(path, functionName) {\n        const closestDef = j(path)\n            .closestScope()\n            .findVariableDeclarators(functionName);\n        return closestDef.size() === 0;\n    }\n    function processAsyncApiCalls(asyncRequestApiName, originRequestApiName) {\n        // Process each call to cookies() or headers()\n        root\n            .find(j.CallExpression, {\n            callee: {\n                type: 'Identifier',\n                name: asyncRequestApiName,\n            },\n        })\n            .forEach((path) => {\n            const isImportedTopLevel = isImportedInModule(path, asyncRequestApiName);\n            if (!isImportedTopLevel) {\n                return;\n            }\n            let parentFunctionPath = (0, utils_1.findClosetParentFunctionScope)(path, j);\n            // We found the parent scope is not a function\n            let parentFunctionNode;\n            if (parentFunctionPath) {\n                if ((0, utils_1.isFunctionScope)(parentFunctionPath, j)) {\n                    parentFunctionNode = parentFunctionPath.node;\n                }\n                else {\n                    const scopeNode = parentFunctionPath.node;\n                    if (scopeNode.type === 'ReturnStatement' &&\n                        (0, utils_1.isFunctionType)(scopeNode.argument.type)) {\n                        parentFunctionNode = scopeNode.argument;\n                    }\n                }\n            }\n            const isAsyncFunction = parentFunctionNode?.async || false;\n            const isCallAwaited = path.parentPath?.node?.type === 'AwaitExpression';\n            const hasChainAccess = path.parentPath.value.type === 'MemberExpression' &&\n                path.parentPath.value.object === path.node;\n            const closetScope = j(path).closestScope();\n            // For cookies/headers API, only transform server and shared components\n            if (isAsyncFunction) {\n                if (!isCallAwaited) {\n                    // Add 'await' in front of cookies() call\n                    const expr = j.awaitExpression(\n                    // add parentheses to wrap the function call\n                    j.callExpression(j.identifier(asyncRequestApiName), []));\n                    j(path).replaceWith((0, utils_1.wrapParentheseIfNeeded)(hasChainAccess, j, expr));\n                    modified = true;\n                }\n            }\n            else {\n                // Determine if the function is an export\n                const closetScopePath = closetScope.get();\n                const isEntryFileExport = isEntryFile && (0, utils_1.isMatchedFunctionExported)(closetScopePath, j);\n                const closestFunctionNode = closetScope.size()\n                    ? closetScopePath.node\n                    : null;\n                // If it's exporting a function directly, exportFunctionNode is same as exportNode\n                // e.g. export default function MyComponent() {}\n                // If it's exporting a variable declaration, exportFunctionNode is the function declaration\n                // e.g. export const MyComponent = function() {}\n                let exportFunctionNode;\n                if (isEntryFileExport) {\n                    if (closestFunctionNode &&\n                        (0, utils_1.isFunctionType)(closestFunctionNode.type)) {\n                        exportFunctionNode = closestFunctionNode;\n                    }\n                }\n                else {\n                    // Is normal async function\n                    exportFunctionNode = closestFunctionNode;\n                }\n                let canConvertToAsync = false;\n                // check if current path is under the default export function\n                if (isEntryFileExport) {\n                    // if default export function is not async, convert it to async, and await the api call\n                    if (!isCallAwaited && (0, utils_1.isFunctionType)(exportFunctionNode.type)) {\n                        const hasReactHooksUsage = (0, utils_1.containsReactHooksCallExpressions)(closetScopePath, j);\n                        // If the scoped function is async function\n                        if (exportFunctionNode.async === false && !hasReactHooksUsage) {\n                            canConvertToAsync = true;\n                            exportFunctionNode.async = true;\n                        }\n                        if (canConvertToAsync) {\n                            const expr = j.awaitExpression(j.callExpression(j.identifier(asyncRequestApiName), []));\n                            j(path).replaceWith((0, utils_1.wrapParentheseIfNeeded)(hasChainAccess, j, expr));\n                            (0, utils_1.turnFunctionReturnTypeToAsync)(closetScopePath.node, j);\n                            modified = true;\n                        }\n                        else {\n                            // If it's still sync function that cannot be converted to async, wrap the api call with 'use()' if needed\n                            if (!(0, utils_1.isParentUseCallExpression)(path, j)) {\n                                j(path).replaceWith(j.callExpression(j.identifier('use'), [\n                                    j.callExpression(j.identifier(asyncRequestApiName), []),\n                                ]));\n                                needsReactUseImport = true;\n                                modified = true;\n                            }\n                        }\n                    }\n                }\n                else {\n                    // if parent is function and it's a hook, which starts with 'use', wrap the api call with 'use()'\n                    const parentFunction = (0, utils_1.findClosetParentFunctionScope)(path, j);\n                    if (parentFunction) {\n                        const parentFunctionName = parentFunction.get().node.id?.name || '';\n                        const isParentFunctionHook = (0, utils_1.isReactHookName)(parentFunctionName);\n                        if (isParentFunctionHook && !(0, utils_1.isParentUseCallExpression)(path, j)) {\n                            j(path).replaceWith(j.callExpression(j.identifier('use'), [\n                                j.callExpression(j.identifier(asyncRequestApiName), []),\n                            ]));\n                            needsReactUseImport = true;\n                        }\n                        else {\n                            const casted = castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} Manually await this call and refactor the function to be async `);\n                            modified ||= casted;\n                        }\n                    }\n                    else {\n                        const casted = castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, ` ${utils_1.NEXT_CODEMOD_ERROR_PREFIX} please manually await this call, codemod cannot transform due to undetermined async scope `);\n                        modified ||= casted;\n                    }\n                }\n            }\n        });\n        // Handle type usage of async API, e.g. `type Cookie = ReturnType<typeof cookies>`\n        // convert it to `type Cookie = Awaited<ReturnType<typeof cookies>>`\n        root\n            .find(j.TSTypeReference, {\n            typeName: {\n                type: 'Identifier',\n                name: 'ReturnType',\n            },\n        })\n            .forEach((path) => {\n            const typeParam = path.node.typeParameters?.params[0];\n            // Check if the ReturnType is for 'cookies'\n            if (typeParam &&\n                j.TSTypeQuery.check(typeParam) &&\n                j.Identifier.check(typeParam.exprName) &&\n                typeParam.exprName.name === asyncRequestApiName) {\n                // Replace ReturnType<typeof cookies> with Awaited<ReturnType<typeof cookies>>\n                const awaitedTypeReference = j.tsTypeReference(j.identifier('Awaited'), j.tsTypeParameterInstantiation([\n                    j.tsTypeReference(j.identifier('ReturnType'), j.tsTypeParameterInstantiation([typeParam])),\n                ]));\n                j(path).replaceWith(awaitedTypeReference);\n                modified = true;\n            }\n        });\n    }\n    const isClientComponent = (0, utils_1.determineClientDirective)(root, j);\n    // Only transform the valid calls in server or shared components\n    if (isClientComponent)\n        return null;\n    // Import declaration case, e.g. import { cookies } from 'next/headers'\n    const importedNextAsyncRequestApisMapping = findImportMappingFromNextHeaders(root, j);\n    for (const originName in importedNextAsyncRequestApisMapping) {\n        const aliasName = importedNextAsyncRequestApisMapping[originName];\n        processAsyncApiCalls(aliasName, originName);\n    }\n    // Add import { use } from 'react' if needed and not already imported\n    if (needsReactUseImport) {\n        (0, utils_1.insertReactUseImport)(root, j);\n    }\n    const commented = findDynamicImportsAndComment(root, j);\n    modified ||= commented;\n    return modified ? root.toSource() : null;\n}\n// cast to unknown first, then the specific type\nconst API_CAST_TYPE_MAP = {\n    cookies: 'UnsafeUnwrappedCookies',\n    headers: 'UnsafeUnwrappedHeaders',\n    draftMode: 'UnsafeUnwrappedDraftMode',\n};\nfunction castTypesOrAddComment(j, path, originRequestApiName, root, filePath, insertedTypes, customMessage) {\n    let modified = false;\n    const isTsFile = filePath.endsWith('.ts') || filePath.endsWith('.tsx');\n    if (isTsFile) {\n        // if the path of call expression is already being awaited, no need to cast\n        if (path.parentPath?.node?.type === 'AwaitExpression')\n            return false;\n        /* Do type cast for headers, cookies, draftMode\n          import {\n            type UnsafeUnwrappedHeaders,\n            type UnsafeUnwrappedCookies,\n            type UnsafeUnwrappedDraftMode\n          } from 'next/headers'\n          \n          cookies() as unknown as UnsafeUnwrappedCookies\n          headers() as unknown as UnsafeUnwrappedHeaders\n          draftMode() as unknown as UnsafeUnwrappedDraftMode\n          \n          e.g. `<path>` is cookies(), convert it to `(<path> as unknown as UnsafeUnwrappedCookies)`\n        */\n        const targetType = API_CAST_TYPE_MAP[originRequestApiName];\n        const newCastExpression = j.tsAsExpression(j.tsAsExpression(path.node, j.tsUnknownKeyword()), j.tsTypeReference(j.identifier(targetType)));\n        // Replace the original expression with the new cast expression,\n        // also wrap () around the new cast expression.\n        const parent = path.parent.value;\n        const wrappedExpression = j.parenthesizedExpression(newCastExpression);\n        path.replace(wrappedExpression);\n        // If the wrapped expression `(<expression>)` is the beginning of an expression statement,\n        // add a void operator to separate the statement, to avoid syntax error that being treated as part of previous statement.\n        // example:\n        // input:\n        // <expression>\n        // <expression>\n        // output:\n        // (<expression> as ...)\n        // void (<expression> as ...)\n        if (j.ExpressionStatement.check(parent) &&\n            parent.expression === path.node) {\n            // append a semicolon to the start of the expression statement\n            parent.expression = j.unaryExpression('void', parent.expression);\n        }\n        modified = true;\n        // If cast types are not imported, add them to the import list\n        const importDeclaration = root.find(j.ImportDeclaration, {\n            source: { value: 'next/headers' },\n        });\n        if (importDeclaration.size() > 0) {\n            const hasImportedType = importDeclaration\n                .find(j.TSTypeAliasDeclaration, {\n                id: { name: targetType },\n            })\n                .size() > 0 ||\n                importDeclaration\n                    .find(j.ImportSpecifier, {\n                    imported: { name: targetType },\n                })\n                    .size() > 0;\n            if (!hasImportedType && !insertedTypes.has(targetType)) {\n                importDeclaration\n                    .get()\n                    .node.specifiers.push(j.importSpecifier(j.identifier(`type ${targetType}`)));\n                insertedTypes.add(targetType);\n            }\n        }\n    }\n    else {\n        // Otherwise for JS file, leave a message to the user to manually handle the transformation\n        const inserted = (0, utils_1.insertCommentOnce)(path.node, j, customMessage);\n        modified ||= inserted;\n    }\n    return modified;\n}\nfunction findImportMappingFromNextHeaders(root, j) {\n    const mappings = {};\n    // Find the import declaration from 'next/headers'\n    root\n        .find(j.ImportDeclaration, { source: { value: 'next/headers' } })\n        .forEach((importPath) => {\n        const importDeclaration = importPath.node;\n        // Iterate over the specifiers and build the mappings\n        importDeclaration.specifiers.forEach((specifier) => {\n            if (j.ImportSpecifier.check(specifier)) {\n                const importedName = specifier.imported.name; // Original name (e.g., cookies)\n                const localName = specifier.local.name; // Local name (e.g., myCookies or same as importedName)\n                // Add to the mappings\n                mappings[importedName] = localName;\n            }\n        });\n    });\n    return mappings;\n}\n//# sourceMappingURL=next-async-dynamic-api.js.map"],"mappings":"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","ignoreList":[]}},"mtime":1769077344093},"{\"assumptions\":{},\"sourceRoot\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"filename\":\"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/tsx.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/alikhanzhumabayev/Downloads/qazaq_full_project/frontend\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.26.10:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst baseOptions = require('./tsOptions');\nconst options = Object.assign({}, baseOptions);\noptions.plugins = ['jsx'].concat(baseOptions.plugins);\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function () {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiYWJ5bG9uIiwicmVxdWlyZSIsImJhc2VPcHRpb25zIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInBsdWdpbnMiLCJjb25jYXQiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvYWxpa2hhbnpodW1hYmF5ZXYvLm5wbS9fbnB4LzZhMDkwNjY5ZTIxYjQzMDMvbm9kZV9tb2R1bGVzL2pzY29kZXNoaWZ0L3BhcnNlci8iLCJzb3VyY2VzIjpbInRzeC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBiYWJ5bG9uID0gcmVxdWlyZSgnQGJhYmVsL3BhcnNlcicpO1xuY29uc3QgYmFzZU9wdGlvbnMgPSByZXF1aXJlKCcuL3RzT3B0aW9ucycpO1xuXG5jb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMpO1xub3B0aW9ucy5wbHVnaW5zID0gWydqc3gnXS5jb25jYXQoYmFzZU9wdGlvbnMucGx1Z2lucyk7XG5cbi8qKlxuICogRG9lc24ndCBhY2NlcHQgY3VzdG9tIG9wdGlvbnMgYmVjYXVzZSBiYWJ5bG9uIHNob3VsZCBiZSB1c2VkIGRpcmVjdGx5IGluXG4gKiB0aGF0IGNhc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcGFyc2UoY29kZSkge1xuICAgICAgcmV0dXJuIGJhYnlsb24ucGFyc2UoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaLE1BQU1BLE9BQU8sR0FBR0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUN4QyxNQUFNQyxXQUFXLEdBQUdELE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFFMUMsTUFBTUUsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRUgsV0FBVyxDQUFDO0FBQzlDQyxPQUFPLENBQUNHLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDQyxNQUFNLENBQUNMLFdBQVcsQ0FBQ0ksT0FBTyxDQUFDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxZQUFXO0VBQzFCLE9BQU87SUFDTEMsS0FBS0EsQ0FBQ0MsSUFBSSxFQUFFO01BQ1YsT0FBT1gsT0FBTyxDQUFDVSxLQUFLLENBQUNDLElBQUksRUFBRVIsT0FBTyxDQUFDO0lBQ3JDO0VBQ0YsQ0FBQztBQUNILENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["babylon","require","baseOptions","options","Object","assign","plugins","concat","module","exports","parse","code"],"sourceRoot":"/Users/alikhanzhumabayev/.npm/_npx/6a090669e21b4303/node_modules/jscodeshift/parser/","sources":["tsx.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst baseOptions = require('./tsOptions');\n\nconst options = Object.assign({}, baseOptions);\noptions.plugins = ['jsx'].concat(baseOptions.plugins);\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function() {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    },\n  };\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAE1C,MAAME,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,WAAW,CAAC;AAC9CC,OAAO,CAACG,OAAO,GAAG,CAAC,KAAK,CAAC,CAACC,MAAM,CAACL,WAAW,CAACI,OAAO,CAAC;;AAErD;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,YAAW;EAC1B,OAAO;IACLC,KAAKA,CAACC,IAAI,EAAE;MACV,OAAOX,OAAO,CAACU,KAAK,CAACC,IAAI,EAAER,OAAO,CAAC;IACrC;EACF,CAAC;AACH,CAAC","ignoreList":[]}},"mtime":1744019810851}}